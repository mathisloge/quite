{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>For full documentation visit github.com/mathisloge/ng-quite.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/05/08/hello-world-/","title":"Hello world \ud83c\udf89","text":"<p>I\u2019m excited to introduce quite, an open\u2011source C++ library with python bindings designed to make end\u2011to\u2011end UI testing in Qt feel\u2026 well, not quite so painful.</p> <p>For now it's just Qt but I hope that the project is ready to take on other UI frameworks as well. Time will tell.</p>"},{"location":"blog/2025/05/08/hello-world-/#what-does-quite-do","title":"What does quite do?","text":"<p>At its core, quite lets you automate and inspect an application running on any device where you\u2019ve installed a small \u201cremote manager\u201d daemon. From your test code, you can:</p> <ul> <li> <p>Start and stop the application remotely</p> </li> <li> <p>Discover any object in the running app and inspect its class name, methods, and properties via the builtin meta\u2011object system (either registered with Qt-Meta-System or with the libraries provided one).</p> </li> <li> <p>Invoke methods dynamically</p> </li> <li> <p>Read and wait on property values, with configurable timeouts</p> </li> <li> <p>Capture screenshots of individual objects and compare them against reference images</p> </li> <li> <p>Simulate mouse actions \u2014 clicks, drags, moves \u2014 targeted at any object</p> </li> <li> <p>Write tests in either C++ or python, with the same API</p> </li> </ul> <p>This marks the initial release. The project is now entering a refactoring and API refinement phase, with no new features planned during this cycle.</p> <p>If you have any questions, feel free to leave a comment below. Bugs or issues can be reported via the GitHub issue tracker.</p> <p>I hope this project proves useful and contributes to improving and stabilizing your application. \ud83c\udf89</p>"},{"location":"quite/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class MyCustomClass </li> <li>namespace anonymous namespace{libs/core/src/meta/meta_types.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/object_tracker.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/main.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/test_method_invoker.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/test_property_collector.cpp} </li> <li>namespace anonymous namespace{libs/protocol/src/probe/rpc_mouse_injection.cpp} </li> <li>namespace ut </li> <li>namespace entt <ul> <li>struct meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; </li> <li>struct meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; </li> <li>struct meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; </li> </ul> </li> <li>namespace literals </li> <li>struct fmt <ul> <li>struct formatter&lt; entt::meta_any &gt; </li> </ul> </li> <li>namespace formatter fmt </li> <li>namespace quite <ul> <li>class Context </li> <li>struct Error </li> <li>struct GenericClass </li> <li>struct GrpcServer </li> <li>class Image <ul> <li>class Impl </li> </ul> </li> <li>struct ImageCompareResult </li> <li>struct ImageView </li> <li>struct ObjectMeta </li> <li>struct ObjectQuery </li> <li>class ObjectQueryBuilder </li> <li>struct ObjectReference </li> <li>struct PixelCompareOptions </li> <li>class QObjectOperationState </li> <li>class QObjectSender </li> <li>class QThreadOperationState </li> <li>class QThreadScheduler <ul> <li>struct DefaultEnv </li> <li>class QThreadSender </li> </ul> </li> <li>class ServiceHandle A lightweight handle for accessing shared service instances. </li> <li>class ValueRegistry </li> <li>struct Vector2 </li> <li>namespace client <ul> <li>class BasicProbe </li> <li>class GrpcProbe </li> <li>class GrpcProperty </li> <li>class GrpcRemoteObject </li> <li>class GrpcValueConverter </li> <li>class Probe </li> <li>class ProbeHandle </li> <li>class ProbeManager <ul> <li>struct Impl </li> </ul> </li> <li>class Property </li> <li>class RemoteObject </li> </ul> </li> <li>namespace core <ul> <li>class IMouseInjector </li> <li>struct MouseAction </li> </ul> </li> <li>namespace manager <ul> <li>class BasicProcessManager </li> <li>class NoopProcess </li> <li>class Process </li> <li>class ProcessHandle </li> <li>struct ProcessId </li> <li>class ProcessImpl </li> <li>class ProcessManager <ul> <li>struct Impl </li> </ul> </li> <li>class ProcessManagerClient </li> <li>class RemoteProcessManager </li> <li>class Server </li> </ul> </li> <li>namespace meta <ul> <li>struct EnumType </li> <li>struct ListType </li> <li>struct MapType </li> <li>class MetaRegistry </li> <li>struct Method </li> <li>struct ObjectType </li> <li>struct Property </li> </ul> </li> <li>namespace probe <ul> <li>class MetaAdapter </li> <li>class MethodInvoker </li> <li>class MouseInjector </li> <li>class ObjectTracker </li> <li>class ProbeContext </li> <li>class QtMetaRegistry </li> <li>class QtProbeHandler </li> </ul> </li> <li>namespace proto <ul> <li>class Client <ul> <li>struct Impl </li> </ul> </li> <li>struct FindObjectRpcHandler </li> <li>struct GetMetaObjectRpcHandler </li> <li>struct GetObjectPropertiesRpcHandler </li> <li>struct GetViewsRpcHandler </li> <li>class GrpcManager </li> <li>class IProbeHandler <ul> <li>struct ImageData </li> </ul> </li> <li>class IProbeService </li> <li>class IValueConverter </li> <li>struct InvokeMethodRpcHandler </li> <li>class MetaRegistryImpl </li> <li>struct MouseActionRpcHandler </li> <li>class MouseInjectorImpl </li> <li>class ProbeClient </li> <li>class ProbeClientImpl </li> <li>class ProbeServiceImpl </li> <li>class ProbeValueConverter </li> <li>struct ProtocolVisitor </li> <li>class Server <ul> <li>class Impl </li> </ul> </li> <li>struct SetObjectPropertyRpcHandler </li> <li>struct SnapshotRpcHandler </li> </ul> </li> <li>namespace test <ul> <li>struct IExpectBuilder </li> <li>class Probe </li> <li>class ProbeManager </li> <li>class Property </li> <li>class RemoteException </li> <li>class RemoteObject </li> <li>class RemoteObjectExpect </li> </ul> </li> <li>namespace testing </li> </ul> </li> <li>namespace quite </li> <li>struct StopCallback </li> <li>struct DefaultEnv </li> <li>namespace client </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace test </li> <li>namespace std </li> <li>namespace string_view_literals </li> </ul>"},{"location":"quite/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir libs <ul> <li>dir client <ul> <li>dir include <ul> <li>dir quite <ul> <li>dir client <ul> <li>dir testing <ul> <li>file verification_point.hpp </li> </ul> </li> <li>dir utils <ul> <li>file dump_properties.hpp </li> </ul> </li> <li>file probe.hpp </li> <li>file probe_handle.hpp </li> <li>file probe_manager.hpp </li> <li>file property.hpp </li> <li>file quite.hpp </li> <li>file remote_object.hpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file basic_probe.cpp </li> <li>file basic_probe.hpp </li> <li>file context.cpp </li> <li>file context.hpp </li> <li>dir grpc_impl <ul> <li>file grpc_probe.cpp </li> <li>file grpc_probe.hpp </li> <li>file grpc_property.cpp </li> <li>file grpc_property.hpp </li> <li>file grpc_remote_object.cpp </li> <li>file grpc_remote_object.hpp </li> <li>file grpc_value.cpp </li> <li>file grpc_value.hpp </li> </ul> </li> <li>dir testing <ul> <li>file verification_point.cpp </li> </ul> </li> <li>dir utils <ul> <li>file dump_properties.cpp </li> </ul> </li> <li>file probe_handle.cpp </li> <li>file probe_manager.cpp </li> <li>file property.cpp </li> <li>file quite.cpp </li> <li>file remote_object.cpp </li> </ul> </li> <li>dir test <ul> <li>file main.cpp </li> </ul> </li> </ul> </li> <li>dir core <ul> <li>file asio_config.hpp.in </li> <li>dir include <ul> <li>dir quite <ul> <li>file asio_context.hpp </li> <li>file async_result.hpp </li> <li>file disable_copy_move.hpp </li> <li>file error.hpp </li> <li>file geometry.hpp </li> <li>file image.hpp </li> <li>file image_utils.hpp </li> <li>dir injectors <ul> <li>file keys.hpp </li> <li>file mouse_injector.hpp </li> </ul> </li> <li>dir meta <ul> <li>file meta_registry.hpp </li> <li>file meta_type_id.hpp </li> <li>file meta_types.hpp </li> </ul> </li> <li>dir value <ul> <li>file generic_value_class.hpp </li> <li>file object_id.hpp </li> <li>file object_query.hpp </li> <li>file value_registry.hpp </li> </ul> </li> <li>file logger.hpp </li> <li>file meta_any_formatter.hpp </li> <li>file result.hpp </li> <li>file service_handle.hpp </li> <li>file setup_logger.hpp </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file asio_context.cpp </li> <li>file error.cpp </li> <li>file image.cpp </li> <li>file image_utils.cpp </li> <li>dir meta <ul> <li>file meta_types.cpp </li> </ul> </li> <li>dir value <ul> <li>file object_query.cpp </li> <li>file value_registry.cpp </li> </ul> </li> <li>file logger.cpp </li> </ul> </li> <li>dir test <ul> <li>file main.cpp </li> <li>file test_error.cpp </li> </ul> </li> <li>file version.hpp.in </li> </ul> </li> <li>dir manager <ul> <li>dir include <ul> <li>dir quite <ul> <li>dir manager <ul> <li>file basic_process_manager.hpp </li> <li>file process.hpp </li> <li>file process_handle.hpp </li> <li>file process_manager.hpp </li> <li>file server.hpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file basic_process_manager.cpp </li> <li>file noop_process.cpp </li> <li>file noop_process.hpp </li> <li>file process_handle.cpp </li> <li>file process_impl.cpp </li> <li>file process_impl.hpp </li> <li>file process_manager.cpp </li> <li>file process_manager_client.cpp </li> <li>file process_manager_client.hpp </li> <li>file remote_process_manager.cpp </li> <li>file remote_process_manager.hpp </li> <li>file server.cpp </li> </ul> </li> <li>dir tests <ul> <li>file runnable_exe.cpp </li> <li>file runnable_path.in.hpp </li> <li>file test_process_manager.cpp </li> </ul> </li> </ul> </li> <li>dir probe <ul> <li>dir include <ul> <li>dir quite <ul> <li>file probe.hpp </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file probe.cpp </li> </ul> </li> </ul> </li> <li>dir probeqt <ul> <li>dir injector <ul> <li>file clipboard_injector.hpp </li> <li>file keyboard_injector.hpp </li> <li>file mouse_injector.cpp </li> <li>file mouse_injector.hpp </li> <li>file touch_injector.hpp </li> </ul> </li> <li>dir tests <ul> <li>file main.cpp </li> <li>file test_method_invoker.cpp </li> <li>file test_object_tracker.cpp </li> <li>file test_probe_context.cpp </li> <li>file test_property_collector.cpp </li> <li>file test_qt_probe_handler.cpp </li> <li>file test_value_containers.cpp </li> </ul> </li> <li>file meta_adapter.cpp </li> <li>file meta_adapter.hpp </li> <li>file meta_qt_containers.hpp </li> <li>file method_invoker.cpp </li> <li>file method_invoker.hpp </li> <li>file object_tracker.cpp </li> <li>file object_tracker.hpp </li> <li>file probe_context.cpp </li> <li>file probe_context.hpp </li> <li>file property_collector.cpp </li> <li>file property_collector.hpp </li> <li>file qt_meta_registry.cpp </li> <li>file qt_meta_registry.hpp </li> <li>file qt_meta_type_accessor.cpp </li> <li>file qt_meta_type_accessor.hpp </li> <li>file qt_probe_handler.cpp </li> <li>file qt_probe_handler.hpp </li> <li>file qtstdexec.h </li> <li>file to_object_id.hpp </li> <li>file value_converters.cpp </li> <li>file value_converters.hpp </li> </ul> </li> <li>dir protocol <ul> <li>dir include <ul> <li>dir quite <ul> <li>dir proto <ul> <li>dir client <ul> <li>file client.hpp </li> <li>file probe_client.hpp </li> <li>file probe_service.hpp </li> <li>file value_converter.hpp </li> </ul> </li> <li>dir probe <ul> <li>file probe_handler.hpp </li> <li>file server.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file error_helper.cpp </li> <li>file error_helper.hpp </li> <li>dir client <ul> <li>file client.cpp </li> <li>file configure_client_context.cpp </li> <li>file configure_client_context.hpp </li> <li>file grpc_manager.cpp </li> <li>file grpc_manager.hpp </li> <li>file meta_registry_impl.cpp </li> <li>file meta_registry_impl.hpp </li> <li>file mouse_injector_impl.cpp </li> <li>file mouse_injector_impl.hpp </li> <li>file probe_client.cpp </li> <li>file probe_client_impl.cpp </li> <li>file probe_client_impl.hpp </li> <li>file probe_service_impl.cpp </li> <li>file probe_service_impl.hpp </li> </ul> </li> <li>dir probe <ul> <li>file probe_handler_handle.hpp </li> <li>file probe_value_converter.hpp </li> <li>file rpc_fetch_windows.cpp </li> <li>file rpc_fetch_windows.hpp </li> <li>file rpc_find_object.cpp </li> <li>file rpc_find_object.hpp </li> <li>file rpc_invoke_method.cpp </li> <li>file rpc_invoke_method.hpp </li> <li>file rpc_meta_find_type.cpp </li> <li>file rpc_meta_find_type.hpp </li> <li>file rpc_mouse_injection.cpp </li> <li>file rpc_mouse_injection.hpp </li> <li>file rpc_object_properties.cpp </li> <li>file rpc_object_properties.hpp </li> <li>file rpc_set_object_property.cpp </li> <li>file rpc_set_object_property.hpp </li> <li>file rpc_snapshot.cpp </li> <li>file rpc_snapshot.hpp </li> <li>file server.cpp </li> </ul> </li> <li>file meta_converters.cpp </li> <li>file meta_converters.hpp </li> <li>file value.cpp </li> <li>file value.hpp </li> </ul> </li> <li>dir tests <ul> <li>file main.cpp </li> <li>file test_server.cpp </li> </ul> </li> </ul> </li> <li>dir testing <ul> <li>dir include <ul> <li>dir quite <ul> <li>dir test <ul> <li>file exceptions.hpp </li> <li>file expect.hpp </li> <li>file probe.hpp </li> <li>file probe_manager.hpp </li> <li>file property.hpp </li> <li>file remote_object.hpp </li> </ul> </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>file exceptions.cpp </li> <li>file expect.cpp </li> <li>file expect_screenshot.cpp </li> <li>file expect_screenshot.hpp </li> <li>file probe.cpp </li> <li>file probe_manager.cpp </li> <li>file property.cpp </li> <li>file remote_object.cpp </li> <li>file throw_unexpected.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"quite/classMyCustomClass/","title":"Class MyCustomClass","text":"<p>ClassList &gt; MyCustomClass</p> <p>Inherits the following classes: QObject</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_object_tracker.cpp</code></p>"},{"location":"quite/namespace_0d54/","title":"Namespace anonymous namespace{libs/core/src/meta/meta_types.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/core/src/meta/meta_types.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/core/src/meta/meta_types.cpp</code></p>"},{"location":"quite/namespace_0d91/","title":"Namespace anonymous namespace{libs/probeqt/object_tracker.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/probeqt/object_tracker.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/object_tracker.cpp</code></p>"},{"location":"quite/namespace_0d104/","title":"Namespace anonymous namespace{libs/probeqt/tests/main.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/probeqt/tests/main.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/main.cpp</code></p>"},{"location":"quite/namespace_0d105/","title":"Namespace anonymous namespace{libs/probeqt/tests/test_method_invoker.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/probeqt/tests/test_method_invoker.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_method_invoker.cpp</code></p>"},{"location":"quite/namespace_0d108/","title":"Namespace anonymous namespace{libs/probeqt/tests/test_property_collector.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/probeqt/tests/test_property_collector.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_property_collector.cpp</code></p>"},{"location":"quite/namespace_0d148/","title":"Namespace anonymous namespace{libs/protocol/src/probe/rpc_mouse_injection.cpp}","text":"<p>Namespace List &gt; anonymous namespace{libs/protocol/src/probe/rpc_mouse_injection.cpp}</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_mouse_injection.cpp</code></p>"},{"location":"quite/namespaceboost_1_1ut/","title":"Namespace boost::ut","text":"<p>Namespace List &gt; ut</p> <p>The documentation for this class was generated from the following file <code>libs/client/test/main.cpp</code></p>"},{"location":"quite/namespaceentt/","title":"Namespace entt","text":"<p>Namespace List &gt; entt</p>"},{"location":"quite/namespaceentt/#classes","title":"Classes","text":"Type Name struct meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; &lt;Args&gt; struct meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; &lt;Args&gt; struct meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; &lt;Args&gt;"},{"location":"quite/namespaceentt/#public-functions","title":"Public Functions","text":"Type Name void to_json (json &amp; j, const entt::meta_any &amp; v)"},{"location":"quite/namespaceentt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespaceentt/#function-to_json","title":"function to_json","text":"<pre><code>void entt::to_json (\n    json &amp; j,\n    const entt::meta_any &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/utils/dump_properties.cpp</code></p>"},{"location":"quite/structentt_1_1meta__associative__container__traits_3_01QHash_3_01Args_8_8_8_01_4_01_4/","title":"Struct entt::meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt;","text":"<p>template &lt;typename... Args&gt;</p> <p>ClassList &gt; entt &gt; meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt;</p> <p>Inherits the following classes: basic_meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_qt_containers.hpp</code></p>"},{"location":"quite/structentt_1_1meta__associative__container__traits_3_01QMap_3_01Args_8_8_8_01_4_01_4/","title":"Struct entt::meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt;","text":"<p>template &lt;typename... Args&gt;</p> <p>ClassList &gt; entt &gt; meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt;</p> <p>Inherits the following classes: basic_meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_qt_containers.hpp</code></p>"},{"location":"quite/structentt_1_1meta__sequence__container__traits_3_01QList_3_01Args_8_8_8_01_4_01_4/","title":"Struct entt::meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt;","text":"<p>template &lt;typename... Args&gt;</p> <p>ClassList &gt; entt &gt; meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt;</p> <p>Inherits the following classes: basic_meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt;</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_qt_containers.hpp</code></p>"},{"location":"quite/namespaceentt_1_1literals/","title":"Namespace entt::literals","text":"<p>Namespace List &gt; literals</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/method_invoker.cpp</code></p>"},{"location":"quite/structfmt/","title":"Struct fmt","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; fmt</p> <p>Inherits the following classes: formatter&lt; quite::ErrorCode &gt; fmt::formatter,  formatter&lt; quite::Error &gt; fmt::formatter,  formatter&lt; quite::meta::Property &gt; fmt::formatter,  formatter&lt; quite::meta::Method &gt; fmt::formatter,  formatter&lt; quite::meta::ObjectType &gt; fmt::formatter,  formatter&lt; quite::meta::MapType &gt; fmt::formatter,  formatter&lt; quite::meta::ListType &gt; fmt::formatter,  formatter&lt; quite::meta::EnumType &gt; fmt::formatter,  formatter&lt; quite::meta::PrimitiveType &gt; fmt::formatter,  formatter&lt; quite::meta::Type &gt; fmt::formatter,  formatter&lt; quite::ObjectQuery &gt; fmt::formatter</p>"},{"location":"quite/structfmt/#classes","title":"Classes","text":"Type Name struct formatter&lt; entt::meta_any &gt; &lt;&gt;"},{"location":"quite/structfmt/#public-functions","title":"Public Functions","text":"Type Name auto format (quite::ErrorCode error_code, format_context &amp; ctx) const auto format (const quite::Error &amp; error, format_context &amp; ctx) const auto format (const quite::meta::Property &amp; type, format_context &amp; ctx) const auto format (const quite::meta::Method &amp; type, format_context &amp; ctx) const auto format (const quite::meta::ObjectType &amp; type, format_context &amp; ctx) const auto format (const quite::meta::MapType &amp; type, format_context &amp; ctx) const auto format (const quite::meta::ListType &amp; type, format_context &amp; ctx) const auto format (const quite::meta::EnumType &amp; type, format_context &amp; ctx) const auto format (const quite::meta::PrimitiveType &amp; type, format_context &amp; ctx) const auto format (const quite::meta::Type &amp; type, format_context &amp; ctx) const auto format (const quite::ObjectQuery &amp; query, format_context &amp; ctx) const"},{"location":"quite/structfmt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structfmt/#function-format-111","title":"function format [1/11]","text":"<pre><code>auto fmt::format (\n    quite::ErrorCode error_code,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-211","title":"function format [2/11]","text":"<pre><code>auto fmt::format (\n    const quite::Error &amp; error,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-311","title":"function format [3/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::Property &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-411","title":"function format [4/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::Method &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-511","title":"function format [5/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::ObjectType &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-611","title":"function format [6/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::MapType &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-711","title":"function format [7/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::ListType &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-811","title":"function format [8/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::EnumType &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-911","title":"function format [9/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::PrimitiveType &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-1011","title":"function format [10/11]","text":"<pre><code>auto fmt::format (\n    const quite::meta::Type &amp; type,\n    format_context &amp; ctx\n) const\n</code></pre>"},{"location":"quite/structfmt/#function-format-1111","title":"function format [11/11]","text":"<pre><code>auto fmt::format (\n    const quite::ObjectQuery &amp; query,\n    format_context &amp; ctx\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/error.hpp</code></p>"},{"location":"quite/structfmt_1_1formatter_3_01entt_1_1meta__any_01_4/","title":"Struct fmt::formatter&lt; entt::meta_any &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; fmt &gt; formatter&lt; entt::meta_any &gt;</p> <p>Inherits the following classes: fmt::formatter&lt; std::string_view &gt;</p>"},{"location":"quite/structfmt_1_1formatter_3_01entt_1_1meta__any_01_4/#public-functions","title":"Public Functions","text":"Type Name auto format (const entt::meta_any &amp; value, format_context &amp; ctx) const"},{"location":"quite/structfmt_1_1formatter_3_01entt_1_1meta__any_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structfmt_1_1formatter_3_01entt_1_1meta__any_01_4/#function-format","title":"function format","text":"<pre><code>inline auto fmt::formatter&lt; entt::meta_any &gt;::format (\n    const entt::meta_any &amp; value,\n    format_context &amp; ctx\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta_any_formatter.hpp</code></p>"},{"location":"quite/namespaceformatter_01fmt/","title":"Namespace formatter fmt","text":"<p>Namespace List &gt; formatter fmt</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"quite/namespacequite/","title":"Namespace quite","text":"<p>Namespace List &gt; quite</p>"},{"location":"quite/namespacequite/#namespaces","title":"Namespaces","text":"Type Name namespace client namespace core namespace manager namespace meta namespace probe namespace proto namespace test namespace testing"},{"location":"quite/namespacequite/#classes","title":"Classes","text":"Type Name class Context struct Error struct GenericClass struct GrpcServer class Image struct ImageCompareResult struct ImageView struct ObjectMeta struct ObjectQuery class ObjectQueryBuilder struct ObjectReference struct PixelCompareOptions class QObjectOperationState &lt;class Recv, class QObj, class Ret, Args&gt; class QObjectSender &lt;class QObj, class Ret, Args&gt; class QThreadOperationState &lt;class Recv&gt; class QThreadScheduler class ServiceHandle &lt;typename T&gt;A lightweight handle for accessing shared service instances. class ValueRegistry struct Vector2"},{"location":"quite/namespacequite/#public-types","title":"Public Types","text":"Type Name typedef exec::task&lt; Result&lt; T &gt; &gt; AsyncResult enum ErrorCode typedef std::uint64_t ObjectId typedef std::span&lt; std::byte &gt; PixelData typedef std::expected&lt; T, Error &gt; Result Alias for a result type that holds either a value of type T or an Error ."},{"location":"quite/namespacequite/#public-attributes","title":"Public Attributes","text":"Type Name class QUITE_CORE_EXPORT ObjectQueryBuilder"},{"location":"quite/namespacequite/#public-functions","title":"Public Functions","text":"Type Name entt::dense_map&lt; std::string, entt::meta_any &gt; collect_properties (ObjectMeta object_meta, std::span&lt; const std::string &gt; property_names)  QUITE_CORE_EXPORT quill::Logger * create_logger (std::string_view logger_name)  QUITE_CORE_EXPORT auto get_executor () Returns the executor associated with the global ASIO thread pool. constexpr auto make_error_result (const ErrorCode code, MessageT &amp;&amp; message) Helper function to create an error result. QUITE_CORE_EXPORT ObjectQueryBuilder make_query ()  QUITE_CORE_EXPORT Result&lt; ImageCompareResult &gt; pixel_match (const ImageView &amp; expected_img, const ImageView &amp; actual_img, const PixelCompareOptions &amp; options={})  QObjectSender&lt; QObj, Ret, Args... &gt; qobject_as_sender (QObj * obj, Ret(QObj::*)(Args...) ptr)  auto qobject_as_tuple_sender (QObj * obj, Ret(QObj::*)(Args...) ptr)  QThreadScheduler qthread_as_scheduler (QThread * thread)  QThreadScheduler qthread_as_scheduler (QThread &amp; thread)  std::pair&lt; std::string, entt::meta_any &gt; read_property (const QVariant property_value, const QMetaProperty &amp; property)  PROBE_EXPORT void setup_hooks ()  void setup_hooks (GrpcServer server_config)  QUITE_CORE_EXPORT void setup_logger (bool log_to_file=false)  QUITE_CORE_EXPORT execpools::asio_thread_pool &amp; thread_pool () Returns a reference to the global ASIO thread pool. void to_json (json &amp; j, const GenericClass &amp; v)  Result&lt; void &gt; write_property (const ObjectMeta &amp; meta, const std::string &amp; property_name, const entt::meta_any &amp; property_value)"},{"location":"quite/namespacequite/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/namespacequite/#typedef-asyncresult","title":"typedef AsyncResult","text":"<pre><code>using quite::AsyncResult = typedef exec::task&lt;Result&lt;T&gt; &gt;;\n</code></pre>"},{"location":"quite/namespacequite/#enum-errorcode","title":"enum ErrorCode","text":"<pre><code>enum quite::ErrorCode {\n    unknown,\n    cancelled,\n    invalid_argument,\n    deadline_exceeded,\n    not_found,\n    failed_precondition,\n    aborted,\n    unimplemented,\n    unavailable\n};\n</code></pre>"},{"location":"quite/namespacequite/#typedef-objectid","title":"typedef ObjectId","text":"<pre><code>using quite::ObjectId = typedef std::uint64_t;\n</code></pre>"},{"location":"quite/namespacequite/#typedef-pixeldata","title":"typedef PixelData","text":"<pre><code>using quite::PixelData = typedef std::span&lt;std::byte&gt;;\n</code></pre>"},{"location":"quite/namespacequite/#typedef-result","title":"typedef Result","text":"<p>Alias for a result type that holds either a value of type T or an Error .</p> <pre><code>using quite::Result = typedef std::expected&lt;T, Error&gt;;\n</code></pre> <p>This is a convenience alias for std::expected&lt;T, Error&gt;, used to represent the result of an operation that may fail with a quite::Error.</p> <p>Template parameters:</p> <ul> <li><code>T</code> The type of the expected value on success. </li> </ul>"},{"location":"quite/namespacequite/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/namespacequite/#variable-objectquerybuilder","title":"variable ObjectQueryBuilder","text":"<pre><code>class QUITE_CORE_EXPORT quite::ObjectQueryBuilder;\n</code></pre>"},{"location":"quite/namespacequite/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite/#function-collect_properties","title":"function collect_properties","text":"<pre><code>entt::dense_map&lt; std::string, entt::meta_any &gt; quite::collect_properties (\n    ObjectMeta object_meta,\n    std::span&lt; const std::string &gt; property_names\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-create_logger","title":"function create_logger","text":"<pre><code>QUITE_CORE_EXPORT quill::Logger * quite::create_logger (\n    std::string_view logger_name\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-get_executor","title":"function get_executor","text":"<p>Returns the executor associated with the global ASIO thread pool. </p> <pre><code>QUITE_CORE_EXPORT auto quite::get_executor () \n</code></pre> <p>This executor can be used to schedule tasks on the global thread pool.</p> <p>Returns:</p> <p>The executor object from the global thread pool. </p>"},{"location":"quite/namespacequite/#function-make_error_result","title":"function make_error_result","text":"<p>Helper function to create an error result. </p> <pre><code>template&lt;typename MessageT&gt;\nconstexpr auto quite::make_error_result (\n    const ErrorCode code,\n    MessageT &amp;&amp; message\n) \n</code></pre> <p>Constructs a std::unexpected containing a quite::Error with the given code and message.</p> <p>Template parameters:</p> <ul> <li><code>MessageT</code> The type of the error message (deduced). </li> </ul> <p>Parameters:</p> <ul> <li><code>code</code> The error code. </li> <li><code>message</code> The error message. </li> </ul> <p>Returns:</p> <p>std::unexpected&lt;Error&gt; containing the error. </p>"},{"location":"quite/namespacequite/#function-make_query","title":"function make_query","text":"<pre><code>QUITE_CORE_EXPORT ObjectQueryBuilder quite::make_query () \n</code></pre>"},{"location":"quite/namespacequite/#function-pixel_match","title":"function pixel_match","text":"<pre><code>QUITE_CORE_EXPORT Result&lt; ImageCompareResult &gt; quite::pixel_match (\n    const ImageView &amp; expected_img,\n    const ImageView &amp; actual_img,\n    const PixelCompareOptions &amp; options={}\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-qobject_as_sender","title":"function qobject_as_sender","text":"<pre><code>template&lt;class QObj, class Ret, class... Args&gt;\ninline QObjectSender &lt; QObj, Ret, Args... &gt; quite::qobject_as_sender (\n    QObj * obj,\n    Ret(QObj::*)(Args...) ptr\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-qobject_as_tuple_sender","title":"function qobject_as_tuple_sender","text":"<pre><code>template&lt;class QObj, class Ret, class... Args&gt;\ninline auto quite::qobject_as_tuple_sender (\n    QObj * obj,\n    Ret(QObj::*)(Args...) ptr\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-qthread_as_scheduler","title":"function qthread_as_scheduler","text":"<pre><code>inline QThreadScheduler quite::qthread_as_scheduler (\n    QThread * thread\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-qthread_as_scheduler_1","title":"function qthread_as_scheduler","text":"<pre><code>inline QThreadScheduler quite::qthread_as_scheduler (\n    QThread &amp; thread\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-read_property","title":"function read_property","text":"<pre><code>std::pair&lt; std::string, entt::meta_any &gt; quite::read_property (\n    const QVariant property_value,\n    const QMetaProperty &amp; property\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-setup_hooks","title":"function setup_hooks","text":"<pre><code>PROBE_EXPORT void quite::setup_hooks () \n</code></pre>"},{"location":"quite/namespacequite/#function-setup_hooks_1","title":"function setup_hooks","text":"<pre><code>void quite::setup_hooks (\n    GrpcServer server_config\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-setup_logger","title":"function setup_logger","text":"<pre><code>QUITE_CORE_EXPORT void quite::setup_logger (\n    bool log_to_file=false\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-thread_pool","title":"function thread_pool","text":"<p>Returns a reference to the global ASIO thread pool. </p> <pre><code>QUITE_CORE_EXPORT execpools::asio_thread_pool &amp; quite::thread_pool () \n</code></pre> <p>This thread pool is managed as a singleton and is used for all asynchronous operations that require an ASIO execution context within the quite framework.</p> <p>Returns:</p> <p>Reference to the global execpools::asio_thread_pool instance. </p>"},{"location":"quite/namespacequite/#function-to_json","title":"function to_json","text":"<pre><code>void quite::to_json (\n    json &amp; j,\n    const GenericClass &amp; v\n) \n</code></pre>"},{"location":"quite/namespacequite/#function-write_property","title":"function write_property","text":"<pre><code>Result&lt; void &gt; quite::write_property (\n    const ObjectMeta &amp; meta,\n    const std::string &amp; property_name,\n    const entt::meta_any &amp; property_value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe.hpp</code></p>"},{"location":"quite/classquite_1_1Context/","title":"Class quite::Context","text":"<p>ClassList &gt; quite &gt; Context</p>"},{"location":"quite/classquite_1_1Context/#public-functions","title":"Public Functions","text":"Type Name execpools::asio_thread_pool &amp; asio_context ()  proto::Client &amp; backend_client ()  ~Context ()"},{"location":"quite/classquite_1_1Context/#public-static-functions","title":"Public Static Functions","text":"Type Name Context &amp; Instance ()"},{"location":"quite/classquite_1_1Context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1Context/#function-asio_context","title":"function asio_context","text":"<pre><code>execpools::asio_thread_pool &amp; quite::Context::asio_context () \n</code></pre>"},{"location":"quite/classquite_1_1Context/#function-backend_client","title":"function backend_client","text":"<pre><code>proto::Client &amp; quite::Context::backend_client () \n</code></pre>"},{"location":"quite/classquite_1_1Context/#function-context","title":"function ~Context","text":"<pre><code>quite::Context::~Context () \n</code></pre>"},{"location":"quite/classquite_1_1Context/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"quite/classquite_1_1Context/#function-instance","title":"function Instance","text":"<pre><code>static Context &amp; quite::Context::Instance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/context.hpp</code></p>"},{"location":"quite/structquite_1_1Error/","title":"Struct quite::Error","text":"<p>ClassList &gt; quite &gt; Error</p>"},{"location":"quite/structquite_1_1Error/#public-attributes","title":"Public Attributes","text":"Type Name ErrorCode code std::string message"},{"location":"quite/structquite_1_1Error/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1Error/#variable-code","title":"variable code","text":"<pre><code>ErrorCode quite::Error::code;\n</code></pre>"},{"location":"quite/structquite_1_1Error/#variable-message","title":"variable message","text":"<pre><code>std::string quite::Error::message;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/error.hpp</code></p>"},{"location":"quite/structquite_1_1GenericClass/","title":"Struct quite::GenericClass","text":"<p>ClassList &gt; quite &gt; GenericClass</p>"},{"location":"quite/structquite_1_1GenericClass/#public-types","title":"Public Types","text":"Type Name typedef std::unordered_map&lt; std::string, entt::meta_any &gt; PropertyMap"},{"location":"quite/structquite_1_1GenericClass/#public-attributes","title":"Public Attributes","text":"Type Name PropertyMap properties"},{"location":"quite/structquite_1_1GenericClass/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/structquite_1_1GenericClass/#typedef-propertymap","title":"typedef PropertyMap","text":"<pre><code>using quite::GenericClass::PropertyMap =  std::unordered_map&lt;std::string, entt::meta_any&gt;;\n</code></pre>"},{"location":"quite/structquite_1_1GenericClass/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1GenericClass/#variable-properties","title":"variable properties","text":"<pre><code>PropertyMap quite::GenericClass::properties;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/generic_value_class.hpp</code></p>"},{"location":"quite/structquite_1_1GrpcServer/","title":"Struct quite::GrpcServer","text":"<p>ClassList &gt; quite &gt; GrpcServer</p>"},{"location":"quite/structquite_1_1GrpcServer/#public-attributes","title":"Public Attributes","text":"Type Name std::string server_address TODO: add potential secure channels."},{"location":"quite/structquite_1_1GrpcServer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1GrpcServer/#variable-server_address","title":"variable server_address","text":"<p>TODO: add potential secure channels. </p> <pre><code>std::string quite::GrpcServer::server_address;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probe/include/quite/probe.hpp</code></p>"},{"location":"quite/classquite_1_1Image/","title":"Class quite::Image","text":"<p>ClassList &gt; quite &gt; Image</p>"},{"location":"quite/classquite_1_1Image/#classes","title":"Classes","text":"Type Name class Impl"},{"location":"quite/classquite_1_1Image/#public-functions","title":"Public Functions","text":"Type Name Image ()  Image (std::vector&lt; std::byte &gt; image_data, std::uint32_t width, std::uint32_t height, int channels)  Image (const std::filesystem::path &amp; filename)  Image (Image &amp;&amp; other) noexcept Image (const Image &amp; other)  ImageView data () const Image &amp; operator= (Image &amp;&amp; other) noexcept Image &amp; operator= (const Image &amp; other)  void save_to (const std::filesystem::path &amp; destination) const virtual ~Image ()"},{"location":"quite/classquite_1_1Image/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1Image/#function-image-15","title":"function Image [1/5]","text":"<pre><code>quite::Image::Image () \n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-image-25","title":"function Image [2/5]","text":"<pre><code>explicit quite::Image::Image (\n    std::vector&lt; std::byte &gt; image_data,\n    std::uint32_t width,\n    std::uint32_t height,\n    int channels\n) \n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-image-35","title":"function Image [3/5]","text":"<pre><code>explicit quite::Image::Image (\n    const std::filesystem::path &amp; filename\n) \n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-image-45","title":"function Image [4/5]","text":"<pre><code>quite::Image::Image (\n    Image &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-image-55","title":"function Image [5/5]","text":"<pre><code>quite::Image::Image (\n    const Image &amp; other\n) \n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-data","title":"function data","text":"<pre><code>ImageView quite::Image::data () const\n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-operator","title":"function operator=","text":"<pre><code>Image &amp; quite::Image::operator= (\n    Image &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-operator_1","title":"function operator=","text":"<pre><code>Image &amp; quite::Image::operator= (\n    const Image &amp; other\n) \n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-save_to","title":"function save_to","text":"<pre><code>void quite::Image::save_to (\n    const std::filesystem::path &amp; destination\n) const\n</code></pre>"},{"location":"quite/classquite_1_1Image/#function-image","title":"function ~Image","text":"<pre><code>virtual quite::Image::~Image () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image.hpp</code></p>"},{"location":"quite/classquite_1_1Image_1_1Impl/","title":"Class quite::Image::Impl","text":"<p>ClassList &gt; quite &gt; Image &gt; Impl</p>"},{"location":"quite/classquite_1_1Image_1_1Impl/#public-attributes","title":"Public Attributes","text":"Type Name int channels_ std::uint32_t height_ std::vector&lt; std::byte &gt; image_data_ std::uint32_t width_"},{"location":"quite/classquite_1_1Image_1_1Impl/#public-functions","title":"Public Functions","text":"Type Name Impl (std::vector&lt; std::byte &gt; image_data, std::uint32_t width, std::uint32_t height, int channels)  ~Impl () = default"},{"location":"quite/classquite_1_1Image_1_1Impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/classquite_1_1Image_1_1Impl/#variable-channels_","title":"variable channels_","text":"<pre><code>int quite::Image::Impl::channels_;\n</code></pre>"},{"location":"quite/classquite_1_1Image_1_1Impl/#variable-height_","title":"variable height_","text":"<pre><code>std::uint32_t quite::Image::Impl::height_;\n</code></pre>"},{"location":"quite/classquite_1_1Image_1_1Impl/#variable-image_data_","title":"variable image_data_","text":"<pre><code>std::vector&lt;std::byte&gt; quite::Image::Impl::image_data_;\n</code></pre>"},{"location":"quite/classquite_1_1Image_1_1Impl/#variable-width_","title":"variable width_","text":"<pre><code>std::uint32_t quite::Image::Impl::width_;\n</code></pre>"},{"location":"quite/classquite_1_1Image_1_1Impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1Image_1_1Impl/#function-impl","title":"function Impl","text":"<pre><code>inline explicit quite::Image::Impl::Impl (\n    std::vector&lt; std::byte &gt; image_data,\n    std::uint32_t width,\n    std::uint32_t height,\n    int channels\n) \n</code></pre>"},{"location":"quite/classquite_1_1Image_1_1Impl/#function-impl_1","title":"function ~Impl","text":"<pre><code>quite::Image::Impl::~Impl () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/src/image.cpp</code></p>"},{"location":"quite/structquite_1_1ImageCompareResult/","title":"Struct quite::ImageCompareResult","text":"<p>ClassList &gt; quite &gt; ImageCompareResult</p>"},{"location":"quite/structquite_1_1ImageCompareResult/#public-attributes","title":"Public Attributes","text":"Type Name int diff   = <code>{}</code> Image diff_image"},{"location":"quite/structquite_1_1ImageCompareResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1ImageCompareResult/#variable-diff","title":"variable diff","text":"<pre><code>int quite::ImageCompareResult::diff;\n</code></pre>"},{"location":"quite/structquite_1_1ImageCompareResult/#variable-diff_image","title":"variable diff_image","text":"<pre><code>Image quite::ImageCompareResult::diff_image;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image_utils.hpp</code></p>"},{"location":"quite/structquite_1_1ImageView/","title":"Struct quite::ImageView","text":"<p>ClassList &gt; quite &gt; ImageView</p>"},{"location":"quite/structquite_1_1ImageView/#public-attributes","title":"Public Attributes","text":"Type Name int channels PixelData data std::uint32_t height std::uint32_t width"},{"location":"quite/structquite_1_1ImageView/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1ImageView/#variable-channels","title":"variable channels","text":"<pre><code>int quite::ImageView::channels;\n</code></pre>"},{"location":"quite/structquite_1_1ImageView/#variable-data","title":"variable data","text":"<pre><code>PixelData quite::ImageView::data;\n</code></pre>"},{"location":"quite/structquite_1_1ImageView/#variable-height","title":"variable height","text":"<pre><code>std::uint32_t quite::ImageView::height;\n</code></pre>"},{"location":"quite/structquite_1_1ImageView/#variable-width","title":"variable width","text":"<pre><code>std::uint32_t quite::ImageView::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image.hpp</code></p>"},{"location":"quite/structquite_1_1ObjectMeta/","title":"Struct quite::ObjectMeta","text":"<p>ClassList &gt; quite &gt; ObjectMeta</p>"},{"location":"quite/structquite_1_1ObjectMeta/#public-attributes","title":"Public Attributes","text":"Type Name const QMetaObject * meta_object QObject * object"},{"location":"quite/structquite_1_1ObjectMeta/#public-static-functions","title":"Public Static Functions","text":"Type Name ObjectMeta from_qobject (QObject * object)"},{"location":"quite/structquite_1_1ObjectMeta/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1ObjectMeta/#variable-meta_object","title":"variable meta_object","text":"<pre><code>const QMetaObject* quite::ObjectMeta::meta_object;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectMeta/#variable-object","title":"variable object","text":"<pre><code>QObject* quite::ObjectMeta::object;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectMeta/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"quite/structquite_1_1ObjectMeta/#function-from_qobject","title":"function from_qobject","text":"<pre><code>static ObjectMeta quite::ObjectMeta::from_qobject (\n    QObject * object\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/property_collector.hpp</code></p>"},{"location":"quite/structquite_1_1ObjectQuery/","title":"Struct quite::ObjectQuery","text":"<p>ClassList &gt; quite &gt; ObjectQuery</p>"},{"location":"quite/structquite_1_1ObjectQuery/#public-types","title":"Public Types","text":"Type Name typedef std::unordered_map&lt; std::string, entt::meta_any &gt; PropertyMap"},{"location":"quite/structquite_1_1ObjectQuery/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; ObjectQuery &gt; container PropertyMap properties std::string type_name"},{"location":"quite/structquite_1_1ObjectQuery/#public-functions","title":"Public Functions","text":"Type Name ObjectQuery () = default ObjectQuery (const ObjectQuery &amp; other) = default ObjectQuery (ObjectQuery &amp;&amp; other) noexcept ObjectQuery (const ObjectQueryBuilder &amp; builder)  ObjectQuery &amp; operator= (const ObjectQuery &amp; other) = default ObjectQuery &amp; operator= (ObjectQuery &amp;&amp; other) noexcept ~ObjectQuery () = default"},{"location":"quite/structquite_1_1ObjectQuery/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/structquite_1_1ObjectQuery/#typedef-propertymap","title":"typedef PropertyMap","text":"<pre><code>using quite::ObjectQuery::PropertyMap =  std::unordered_map&lt;std::string, entt::meta_any&gt;;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1ObjectQuery/#variable-container","title":"variable container","text":"<pre><code>std::shared_ptr&lt;ObjectQuery&gt; quite::ObjectQuery::container;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#variable-properties","title":"variable properties","text":"<pre><code>PropertyMap quite::ObjectQuery::properties;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#variable-type_name","title":"variable type_name","text":"<pre><code>std::string quite::ObjectQuery::type_name;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1ObjectQuery/#function-objectquery-14","title":"function ObjectQuery [1/4]","text":"<pre><code>quite::ObjectQuery::ObjectQuery () = default\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-objectquery-24","title":"function ObjectQuery [2/4]","text":"<pre><code>quite::ObjectQuery::ObjectQuery (\n    const ObjectQuery &amp; other\n) = default\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-objectquery-34","title":"function ObjectQuery [3/4]","text":"<pre><code>quite::ObjectQuery::ObjectQuery (\n    ObjectQuery &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-objectquery-44","title":"function ObjectQuery [4/4]","text":"<pre><code>quite::ObjectQuery::ObjectQuery (\n    const ObjectQueryBuilder &amp; builder\n) \n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-operator","title":"function operator=","text":"<pre><code>ObjectQuery &amp; quite::ObjectQuery::operator= (\n    const ObjectQuery &amp; other\n) = default\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-operator_1","title":"function operator=","text":"<pre><code>ObjectQuery &amp; quite::ObjectQuery::operator= (\n    ObjectQuery &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"quite/structquite_1_1ObjectQuery/#function-objectquery","title":"function ~ObjectQuery","text":"<pre><code>quite::ObjectQuery::~ObjectQuery () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/object_query.hpp</code></p>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/","title":"Class quite::ObjectQueryBuilder","text":"<p>ClassList &gt; quite &gt; ObjectQueryBuilder</p>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#public-functions","title":"Public Functions","text":"Type Name ObjectQueryBuilder ()  shared_ptr&lt; ObjectQuery &gt; () const ObjectQueryBuilder &amp; with_parent (std::shared_ptr&lt; ObjectQuery &gt; parent)  ObjectQueryBuilder &amp; with_property (std::initializer_list&lt; std::pair&lt; std::string, entt::meta_any &gt; &gt; props)  ObjectQueryBuilder &amp; with_property (std::string key, std::int64_t value)  ObjectQueryBuilder &amp; with_property (std::string key, std::uint64_t value)  ObjectQueryBuilder &amp; with_property (std::string key, double value)  ObjectQueryBuilder &amp; with_property (std::string key, bool value)  ObjectQueryBuilder &amp; with_property (std::string key, std::string value)  ObjectQueryBuilder &amp; with_type (std::string type_name)"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-objectquerybuilder","title":"function ObjectQueryBuilder","text":"<pre><code>quite::ObjectQueryBuilder::ObjectQueryBuilder () \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-shared_ptr-objectquery","title":"function shared_ptr&lt; ObjectQuery &gt;","text":"<pre><code>quite::ObjectQueryBuilder::shared_ptr&lt; ObjectQuery &gt; () const\n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_parent","title":"function with_parent","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_parent (\n    std::shared_ptr&lt; ObjectQuery &gt; parent\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-16","title":"function with_property [1/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::initializer_list&lt; std::pair&lt; std::string, entt::meta_any &gt; &gt; props\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-26","title":"function with_property [2/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::string key,\n    std::int64_t value\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-36","title":"function with_property [3/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::string key,\n    std::uint64_t value\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-46","title":"function with_property [4/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::string key,\n    double value\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-56","title":"function with_property [5/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::string key,\n    bool value\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_property-66","title":"function with_property [6/6]","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_property (\n    std::string key,\n    std::string value\n) \n</code></pre>"},{"location":"quite/classquite_1_1ObjectQueryBuilder/#function-with_type","title":"function with_type","text":"<pre><code>ObjectQueryBuilder &amp; quite::ObjectQueryBuilder::with_type (\n    std::string type_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/object_query.hpp</code></p>"},{"location":"quite/structquite_1_1ObjectReference/","title":"Struct quite::ObjectReference","text":"<p>ClassList &gt; quite &gt; ObjectReference</p>"},{"location":"quite/structquite_1_1ObjectReference/#public-attributes","title":"Public Attributes","text":"Type Name ObjectId object_id meta::TypeId type_id"},{"location":"quite/structquite_1_1ObjectReference/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1ObjectReference/#variable-object_id","title":"variable object_id","text":"<pre><code>ObjectId quite::ObjectReference::object_id;\n</code></pre>"},{"location":"quite/structquite_1_1ObjectReference/#variable-type_id","title":"variable type_id","text":"<pre><code>meta::TypeId quite::ObjectReference::type_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/object_id.hpp</code></p>"},{"location":"quite/structquite_1_1PixelCompareOptions/","title":"Struct quite::PixelCompareOptions","text":"<p>ClassList &gt; quite &gt; PixelCompareOptions</p>"},{"location":"quite/structquite_1_1PixelCompareOptions/#public-attributes","title":"Public Attributes","text":"Type Name float alpha   = <code>{0.1}</code> std::array&lt; uint8_t, 3 &gt; anti_aliased_color   = <code>{255, 255, 0}</code> std::array&lt; uint8_t, 3 &gt; diff_color   = <code>{255, 0, 0}</code> std::optional&lt; std::array&lt; uint8_t, 3 &gt; &gt; diff_color_alt bool diff_mask   = <code>{false}</code> bool skip_anti_aliasing   = <code>{false}</code> float threshold   = <code>{0.1}</code>"},{"location":"quite/structquite_1_1PixelCompareOptions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-alpha","title":"variable alpha","text":"<pre><code>float quite::PixelCompareOptions::alpha;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-anti_aliased_color","title":"variable anti_aliased_color","text":"<pre><code>std::array&lt;uint8_t, 3&gt; quite::PixelCompareOptions::anti_aliased_color;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-diff_color","title":"variable diff_color","text":"<pre><code>std::array&lt;uint8_t, 3&gt; quite::PixelCompareOptions::diff_color;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-diff_color_alt","title":"variable diff_color_alt","text":"<pre><code>std::optional&lt;std::array&lt;uint8_t, 3&gt; &gt; quite::PixelCompareOptions::diff_color_alt;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-diff_mask","title":"variable diff_mask","text":"<pre><code>bool quite::PixelCompareOptions::diff_mask;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-skip_anti_aliasing","title":"variable skip_anti_aliasing","text":"<pre><code>bool quite::PixelCompareOptions::skip_anti_aliasing;\n</code></pre>"},{"location":"quite/structquite_1_1PixelCompareOptions/#variable-threshold","title":"variable threshold","text":"<pre><code>float quite::PixelCompareOptions::threshold;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image_utils.hpp</code></p>"},{"location":"quite/classquite_1_1QObjectOperationState/","title":"Class quite::QObjectOperationState","text":"<p>template &lt;class Recv, class QObj, class Ret, class... Args&gt;</p> <p>ClassList &gt; quite &gt; QObjectOperationState</p>"},{"location":"quite/classquite_1_1QObjectOperationState/#public-types","title":"Public Types","text":"Type Name typedef Ret(QObj::*)(Args...) m_ptr_type typedef stdexec::operation_state_t operation_state_concept"},{"location":"quite/classquite_1_1QObjectOperationState/#public-functions","title":"Public Functions","text":"Type Name QObjectOperationState (Recv &amp;&amp; receiver, QObj * obj, m_ptr_type ptr)  void start () noexcept"},{"location":"quite/classquite_1_1QObjectOperationState/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1QObjectOperationState/#typedef-m_ptr_type","title":"typedef m_ptr_type","text":"<pre><code>using quite::QObjectOperationState&lt; Recv, QObj, Ret, Args &gt;::m_ptr_type =  Ret (QObj::*)(Args...);\n</code></pre>"},{"location":"quite/classquite_1_1QObjectOperationState/#typedef-operation_state_concept","title":"typedef operation_state_concept","text":"<pre><code>using quite::QObjectOperationState&lt; Recv, QObj, Ret, Args &gt;::operation_state_concept =  stdexec::operation_state_t;\n</code></pre>"},{"location":"quite/classquite_1_1QObjectOperationState/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1QObjectOperationState/#function-qobjectoperationstate","title":"function QObjectOperationState","text":"<pre><code>inline quite::QObjectOperationState::QObjectOperationState (\n    Recv &amp;&amp; receiver,\n    QObj * obj,\n    m_ptr_type ptr\n) \n</code></pre>"},{"location":"quite/classquite_1_1QObjectOperationState/#function-start","title":"function start","text":"<pre><code>inline void quite::QObjectOperationState::start () noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/classquite_1_1QObjectSender/","title":"Class quite::QObjectSender","text":"<p>template &lt;class QObj, class Ret, class... Args&gt;</p> <p>ClassList &gt; quite &gt; QObjectSender</p>"},{"location":"quite/classquite_1_1QObjectSender/#public-types","title":"Public Types","text":"Type Name typedef Ret(QObj::*)(Args...) MemberPointer typedef stdexec::completion_signatures&lt; stdexec::set_value_t(Args...), stdexec::set_error_t(std::exception_ptr), stdexec::set_stopped_t()&gt; completion_signatures typedef void is_sender"},{"location":"quite/classquite_1_1QObjectSender/#public-functions","title":"Public Functions","text":"Type Name QObjectSender (QObj * obj, MemberPointer ptr)  QObjectOperationState&lt; Recv, QObj, Ret, Args... &gt; connect (Recv &amp;&amp; receiver)  MemberPointer member_ptr ()  QObj * object ()"},{"location":"quite/classquite_1_1QObjectSender/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1QObjectSender/#typedef-memberpointer","title":"typedef MemberPointer","text":"<pre><code>using quite::QObjectSender&lt; QObj, Ret, Args &gt;::MemberPointer =  Ret (QObj::*)(Args...);\n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#typedef-completion_signatures","title":"typedef completion_signatures","text":"<pre><code>using quite::QObjectSender&lt; QObj, Ret, Args &gt;::completion_signatures =  stdexec::completion_signatures&lt;stdexec::set_value_t(Args...), stdexec::set_error_t(std::exception_ptr), stdexec::set_stopped_t()&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#typedef-is_sender","title":"typedef is_sender","text":"<pre><code>using quite::QObjectSender&lt; QObj, Ret, Args &gt;::is_sender =  void;\n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1QObjectSender/#function-qobjectsender","title":"function QObjectSender","text":"<pre><code>inline quite::QObjectSender::QObjectSender (\n    QObj * obj,\n    MemberPointer ptr\n) \n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#function-connect","title":"function connect","text":"<pre><code>template&lt;class Recv&gt;\ninline QObjectOperationState &lt; Recv, QObj, Ret, Args... &gt; quite::QObjectSender::connect (\n    Recv &amp;&amp; receiver\n) \n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#function-member_ptr","title":"function member_ptr","text":"<pre><code>inline MemberPointer quite::QObjectSender::member_ptr () \n</code></pre>"},{"location":"quite/classquite_1_1QObjectSender/#function-object","title":"function object","text":"<pre><code>inline QObj * quite::QObjectSender::object () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/classquite_1_1QThreadOperationState/","title":"Class quite::QThreadOperationState","text":"<p>template &lt;class Recv&gt;</p> <p>ClassList &gt; quite &gt; QThreadOperationState</p>"},{"location":"quite/classquite_1_1QThreadOperationState/#public-types","title":"Public Types","text":"Type Name typedef stdexec::operation_state_t operation_state_concept"},{"location":"quite/classquite_1_1QThreadOperationState/#public-functions","title":"Public Functions","text":"Type Name QThreadOperationState (Recv &amp;&amp; receiver, QThread * thread)  Q_DISABLE_COPY_MOVE (QThreadOperationState)  void start () noexcept ~QThreadOperationState () = default"},{"location":"quite/classquite_1_1QThreadOperationState/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1QThreadOperationState/#typedef-operation_state_concept","title":"typedef operation_state_concept","text":"<pre><code>using quite::QThreadOperationState&lt; Recv &gt;::operation_state_concept =  stdexec::operation_state_t;\n</code></pre>"},{"location":"quite/classquite_1_1QThreadOperationState/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1QThreadOperationState/#function-qthreadoperationstate","title":"function QThreadOperationState","text":"<pre><code>inline quite::QThreadOperationState::QThreadOperationState (\n    Recv &amp;&amp; receiver,\n    QThread * thread\n) \n</code></pre>"},{"location":"quite/classquite_1_1QThreadOperationState/#function-q_disable_copy_move","title":"function Q_DISABLE_COPY_MOVE","text":"<pre><code>quite::QThreadOperationState::Q_DISABLE_COPY_MOVE (\n    QThreadOperationState\n) \n</code></pre>"},{"location":"quite/classquite_1_1QThreadOperationState/#function-start","title":"function start","text":"<pre><code>inline void quite::QThreadOperationState::start () noexcept\n</code></pre>"},{"location":"quite/classquite_1_1QThreadOperationState/#function-qthreadoperationstate_1","title":"function ~QThreadOperationState","text":"<pre><code>quite::QThreadOperationState::~QThreadOperationState () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/classquite_1_1QThreadScheduler/","title":"Class quite::QThreadScheduler","text":"<p>ClassList &gt; quite &gt; QThreadScheduler</p>"},{"location":"quite/classquite_1_1QThreadScheduler/#classes","title":"Classes","text":"Type Name struct DefaultEnv class QThreadSender"},{"location":"quite/classquite_1_1QThreadScheduler/#public-functions","title":"Public Functions","text":"Type Name QThreadScheduler (QThread * thread)  bool operator== (const QThreadScheduler &amp; b) noexcept const DefaultEnv query (stdexec::get_env_t) noexcept auto schedule () noexcept const QThread * thread ()"},{"location":"quite/classquite_1_1QThreadScheduler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1QThreadScheduler/#function-qthreadscheduler","title":"function QThreadScheduler","text":"<pre><code>inline explicit quite::QThreadScheduler::QThreadScheduler (\n    QThread * thread\n) \n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler/#function-operator","title":"function operator==","text":"<pre><code>bool quite::QThreadScheduler::operator== (\n    const QThreadScheduler &amp; b\n) noexcept const\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler/#function-query","title":"function query","text":"<pre><code>inline DefaultEnv quite::QThreadScheduler::query (\n    stdexec::get_env_t\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler/#function-schedule","title":"function schedule","text":"<pre><code>inline auto quite::QThreadScheduler::schedule () noexcept const\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler/#function-thread","title":"function thread","text":"<pre><code>inline QThread * quite::QThreadScheduler::thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/","title":"Struct quite::QThreadScheduler::DefaultEnv","text":"<p>ClassList &gt; quite &gt; QThreadScheduler &gt; DefaultEnv</p>"},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#public-attributes","title":"Public Attributes","text":"Type Name QThread * thread"},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#public-functions","title":"Public Functions","text":"Type Name auto query (stdexec::get_completion_scheduler_t&lt; CPO &gt;) noexcept const"},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#variable-thread","title":"variable thread","text":"<pre><code>QThread* quite::QThreadScheduler::DefaultEnv::thread;\n</code></pre>"},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1QThreadScheduler_1_1DefaultEnv/#function-query","title":"function query","text":"<pre><code>template&lt;typename CPO&gt;\ninline auto quite::QThreadScheduler::DefaultEnv::query (\n    stdexec::get_completion_scheduler_t&lt; CPO &gt;\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/","title":"Class quite::QThreadScheduler::QThreadSender","text":"<p>ClassList &gt; quite &gt; QThreadScheduler &gt; QThreadSender</p>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#public-types","title":"Public Types","text":"Type Name typedef stdexec::completion_signatures&lt; stdexec::set_value_t(), stdexec::set_error_t(std::exception_ptr)&gt; completion_signatures typedef void is_sender"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#public-functions","title":"Public Functions","text":"Type Name QThreadSender (QThread * thread)  QThreadOperationState&lt; Recv &gt; connect (Recv &amp;&amp; receiver)  DefaultEnv query (stdexec::get_env_t) noexcept const QThread * thread ()"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#typedef-completion_signatures","title":"typedef completion_signatures","text":"<pre><code>using quite::QThreadScheduler::QThreadSender::completion_signatures =  stdexec::completion_signatures&lt;stdexec::set_value_t(), stdexec::set_error_t(std::exception_ptr)&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#typedef-is_sender","title":"typedef is_sender","text":"<pre><code>using quite::QThreadScheduler::QThreadSender::is_sender =  void;\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#function-qthreadsender","title":"function QThreadSender","text":"<pre><code>inline explicit quite::QThreadScheduler::QThreadSender::QThreadSender (\n    QThread * thread\n) \n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#function-connect","title":"function connect","text":"<pre><code>template&lt;class Recv&gt;\ninline QThreadOperationState &lt; Recv &gt; quite::QThreadScheduler::QThreadSender::connect (\n    Recv &amp;&amp; receiver\n) \n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#function-query","title":"function query","text":"<pre><code>inline DefaultEnv quite::QThreadScheduler::QThreadSender::query (\n    stdexec::get_env_t\n) noexcept const\n</code></pre>"},{"location":"quite/classquite_1_1QThreadScheduler_1_1QThreadSender/#function-thread","title":"function thread","text":"<pre><code>inline QThread * quite::QThreadScheduler::QThreadSender::thread () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/classquite_1_1ServiceHandle/","title":"Class quite::ServiceHandle","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; quite &gt; ServiceHandle</p> <p>A lightweight handle for accessing shared service instances. More...</p> <ul> <li><code>#include &lt;service_handle.hpp&gt;</code></li> </ul>"},{"location":"quite/classquite_1_1ServiceHandle/#public-types","title":"Public Types","text":"Type Name typedef T Type"},{"location":"quite/classquite_1_1ServiceHandle/#public-functions","title":"Public Functions","text":"Type Name ServiceHandle () = defaultConstructs an empty ServiceHandle . ServiceHandle (std::shared_ptr&lt; T &gt; service) Constructs a ServiceHandle from a shared_ptr to a service. ServiceHandle (std::in_place_t, Args &amp;&amp;... args) Constructs a ServiceHandle with a new service instance. operator bool () constChecks if the handle refers to a valid service. T &amp; operator* () constDereferences the handle to access the service instance. T * operator-&gt; () constProvides pointer-like access to the underlying service."},{"location":"quite/classquite_1_1ServiceHandle/#detailed-description","title":"Detailed Description","text":"<p>ServiceHandle provides pointer-like semantics for accessing services managed via std::shared_ptr. It is intended to be used as a safe, convenient wrapper for dependency injection or service locator patterns.</p> <p>Template parameters:</p> <ul> <li><code>T</code> The service type. </li> </ul>"},{"location":"quite/classquite_1_1ServiceHandle/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1ServiceHandle/#typedef-type","title":"typedef Type","text":"<pre><code>using quite::ServiceHandle&lt; T &gt;::Type =  T;\n</code></pre>"},{"location":"quite/classquite_1_1ServiceHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1ServiceHandle/#function-servicehandle-13","title":"function ServiceHandle [1/3]","text":"<p>Constructs an empty ServiceHandle .</p> <pre><code>quite::ServiceHandle::ServiceHandle () = default\n</code></pre>"},{"location":"quite/classquite_1_1ServiceHandle/#function-servicehandle-23","title":"function ServiceHandle [2/3]","text":"<p>Constructs a ServiceHandle from a shared_ptr to a service.</p> <pre><code>inline explicit quite::ServiceHandle::ServiceHandle (\n    std::shared_ptr&lt; T &gt; service\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>service</code> The shared_ptr managing the service instance. </li> </ul>"},{"location":"quite/classquite_1_1ServiceHandle/#function-servicehandle-33","title":"function ServiceHandle [3/3]","text":"<p>Constructs a ServiceHandle with a new service instance.</p> <pre><code>template&lt;typename... Args&gt;\ninline explicit quite::ServiceHandle::ServiceHandle (\n    std::in_place_t,\n    Args &amp;&amp;... args\n) \n</code></pre> <p>Template parameters:</p> <ul> <li><code>Args</code> Types of arguments to pass to the service constructor. </li> </ul> <p>Parameters:</p> <ul> <li><code>args</code> Arguments to construct the service instance. </li> </ul>"},{"location":"quite/classquite_1_1ServiceHandle/#function-operator-bool","title":"function operator bool","text":"<p>Checks if the handle refers to a valid service. </p> <pre><code>inline explicit quite::ServiceHandle::operator bool () const\n</code></pre> <p>Returns:</p> <p>true if the handle is non-empty, false otherwise. </p>"},{"location":"quite/classquite_1_1ServiceHandle/#function-operator","title":"function operator*","text":"<p>Dereferences the handle to access the service instance. </p> <pre><code>inline T &amp; quite::ServiceHandle::operator* () const\n</code></pre> <p>Returns:</p> <p>Reference to the service instance. </p>"},{"location":"quite/classquite_1_1ServiceHandle/#function-operator-","title":"function operator-&gt;","text":"<p>Provides pointer-like access to the underlying service. </p> <pre><code>inline T * quite::ServiceHandle::operator-&gt; () const\n</code></pre> <p>Returns:</p> <p>Pointer to the service instance, or nullptr if empty. </p> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/service_handle.hpp</code></p>"},{"location":"quite/classquite_1_1ValueRegistry/","title":"Class quite::ValueRegistry","text":"<p>ClassList &gt; quite &gt; ValueRegistry</p>"},{"location":"quite/classquite_1_1ValueRegistry/#public-types","title":"Public Types","text":"Type Name typedef entt::dense_map&lt; entt::id_type, std::string &gt; PropertyNameMap"},{"location":"quite/classquite_1_1ValueRegistry/#public-functions","title":"Public Functions","text":"Type Name entt::meta_ctx &amp; context () const entt::id_type named_property (std::string name)  const PropertyNameMap &amp; property_names () const"},{"location":"quite/classquite_1_1ValueRegistry/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1ValueRegistry/#typedef-propertynamemap","title":"typedef PropertyNameMap","text":"<pre><code>using quite::ValueRegistry::PropertyNameMap =  entt::dense_map&lt;entt::id_type, std::string&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1ValueRegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1ValueRegistry/#function-context","title":"function context","text":"<pre><code>entt::meta_ctx &amp; quite::ValueRegistry::context () const\n</code></pre>"},{"location":"quite/classquite_1_1ValueRegistry/#function-named_property","title":"function named_property","text":"<pre><code>entt::id_type quite::ValueRegistry::named_property (\n    std::string name\n) \n</code></pre>"},{"location":"quite/classquite_1_1ValueRegistry/#function-property_names","title":"function property_names","text":"<pre><code>const PropertyNameMap &amp; quite::ValueRegistry::property_names () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/value_registry.hpp</code></p>"},{"location":"quite/structquite_1_1Vector2/","title":"Struct quite::Vector2","text":"<p>ClassList &gt; quite &gt; Vector2</p>"},{"location":"quite/structquite_1_1Vector2/#public-attributes","title":"Public Attributes","text":"Type Name double x double y"},{"location":"quite/structquite_1_1Vector2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1Vector2/#variable-x","title":"variable x","text":"<pre><code>double quite::Vector2::x;\n</code></pre>"},{"location":"quite/structquite_1_1Vector2/#variable-y","title":"variable y","text":"<pre><code>double quite::Vector2::y;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/geometry.hpp</code></p>"},{"location":"quite/namespacequite_1_1client/","title":"Namespace quite::client","text":"<p>Namespace List &gt; quite &gt; client</p>"},{"location":"quite/namespacequite_1_1client/#classes","title":"Classes","text":"Type Name class BasicProbe class GrpcProbe class GrpcProperty class GrpcRemoteObject class GrpcValueConverter class Probe class ProbeHandle class ProbeManager class Property class RemoteObject"},{"location":"quite/namespacequite_1_1client/#public-types","title":"Public Types","text":"Type Name typedef std::uint64_t ObjectId typedef std::shared_ptr&lt; Property &gt; PropertyPtr typedef std::shared_ptr&lt; RemoteObject &gt; RemoteObjectPtr"},{"location":"quite/namespacequite_1_1client/#public-functions","title":"Public Functions","text":"Type Name QUITE_CLIENT_EXPORT execpools::asio_thread_pool &amp; asio_context ()  AsyncResult&lt; nlohmann::json &gt; QUITE_CLIENT_EXPORT dump_properties (RemoteObjectPtr remote_object, std::vector&lt; std::string &gt; properties)"},{"location":"quite/namespacequite_1_1client/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/namespacequite_1_1client/#typedef-objectid","title":"typedef ObjectId","text":"<pre><code>using quite::client::ObjectId = typedef std::uint64_t;\n</code></pre>"},{"location":"quite/namespacequite_1_1client/#typedef-propertyptr","title":"typedef PropertyPtr","text":"<pre><code>using quite::client::PropertyPtr = typedef std::shared_ptr&lt;Property&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1client/#typedef-remoteobjectptr","title":"typedef RemoteObjectPtr","text":"<pre><code>using quite::client::RemoteObjectPtr = typedef std::shared_ptr&lt;RemoteObject&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite_1_1client/#function-asio_context","title":"function asio_context","text":"<pre><code>QUITE_CLIENT_EXPORT execpools::asio_thread_pool &amp; quite::client::asio_context () \n</code></pre>"},{"location":"quite/namespacequite_1_1client/#function-dump_properties","title":"function dump_properties","text":"<pre><code>AsyncResult&lt; nlohmann::json &gt; QUITE_CLIENT_EXPORT quite::client::dump_properties (\n    RemoteObjectPtr remote_object,\n    std::vector&lt; std::string &gt; properties\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1BasicProbe/","title":"Class quite::client::BasicProbe","text":"<p>ClassList &gt; quite &gt; client &gt; BasicProbe</p> <p>Inherits the following classes: quite::client::Probe</p> <p>Inherited by the following classes: quite::client::GrpcProbe</p>"},{"location":"quite/classquite_1_1client_1_1BasicProbe/#public-functions","title":"Public Functions","text":"Type Name BasicProbe (manager::ProcessHandle process)  virtual AsyncResult&lt; void &gt; exit () override manager::Process &amp; process ()"},{"location":"quite/classquite_1_1client_1_1BasicProbe/#public-functions-inherited-from-quiteclientprobe","title":"Public Functions inherited from quite::client::Probe","text":"<p>See quite::client::Probe</p> Type Name Probe () = default QUITE_DISABLE_COPY_MOVE (Probe)  virtual AsyncResult&lt; void &gt; exit () = 0 virtual AsyncResult&lt; RemoteObjectPtr &gt; find_object (ObjectQuery query) = 0 virtual AsyncResult&lt; std::vector&lt; RemoteObjectPtr &gt; &gt; get_views () = 0 virtual meta::MetaRegistry &amp; meta_registry () = 0 virtual AsyncResult&lt; void &gt; wait_for_started (std::chrono::seconds timeout) = 0 virtual ~Probe () = default"},{"location":"quite/classquite_1_1client_1_1BasicProbe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1BasicProbe/#function-basicprobe","title":"function BasicProbe","text":"<pre><code>explicit quite::client::BasicProbe::BasicProbe (\n    manager::ProcessHandle process\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1BasicProbe/#function-exit","title":"function exit","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::BasicProbe::exit () override\n</code></pre> <p>Implements quite::client::Probe::exit</p>"},{"location":"quite/classquite_1_1client_1_1BasicProbe/#function-process","title":"function process","text":"<pre><code>manager::Process &amp; quite::client::BasicProbe::process () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/basic_probe.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/","title":"Class quite::client::GrpcProbe","text":"<p>ClassList &gt; quite &gt; client &gt; GrpcProbe</p> <p>Inherits the following classes: quite::client::BasicProbe</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#public-functions","title":"Public Functions","text":"Type Name GrpcProbe (manager::ProcessHandle process, proto::Client &amp; client, std::string connection_uri)  virtual AsyncResult&lt; std::shared_ptr&lt; RemoteObject &gt; &gt; find_object (ObjectQuery query) override virtual AsyncResult&lt; std::vector&lt; std::shared_ptr&lt; RemoteObject &gt; &gt; &gt; get_views () override virtual meta::MetaRegistry &amp; meta_registry () override virtual AsyncResult&lt; void &gt; wait_for_started (std::chrono::seconds timeout) override"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#public-functions-inherited-from-quiteclientbasicprobe","title":"Public Functions inherited from quite::client::BasicProbe","text":"<p>See quite::client::BasicProbe</p> Type Name BasicProbe (manager::ProcessHandle process)  virtual AsyncResult&lt; void &gt; exit () override manager::Process &amp; process ()"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#public-functions-inherited-from-quiteclientprobe","title":"Public Functions inherited from quite::client::Probe","text":"<p>See quite::client::Probe</p> Type Name Probe () = default QUITE_DISABLE_COPY_MOVE (Probe)  virtual AsyncResult&lt; void &gt; exit () = 0 virtual AsyncResult&lt; RemoteObjectPtr &gt; find_object (ObjectQuery query) = 0 virtual AsyncResult&lt; std::vector&lt; RemoteObjectPtr &gt; &gt; get_views () = 0 virtual meta::MetaRegistry &amp; meta_registry () = 0 virtual AsyncResult&lt; void &gt; wait_for_started (std::chrono::seconds timeout) = 0 virtual ~Probe () = default"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#function-grpcprobe","title":"function GrpcProbe","text":"<pre><code>explicit quite::client::GrpcProbe::GrpcProbe (\n    manager::ProcessHandle process,\n    proto::Client &amp; client,\n    std::string connection_uri\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; std::shared_ptr&lt; RemoteObject &gt; &gt; quite::client::GrpcProbe::find_object (\n    ObjectQuery query\n) override\n</code></pre> <p>Implements quite::client::Probe::find_object</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#function-get_views","title":"function get_views","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; std::shared_ptr&lt; RemoteObject &gt; &gt; &gt; quite::client::GrpcProbe::get_views () override\n</code></pre> <p>Implements quite::client::Probe::get_views</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#function-meta_registry","title":"function meta_registry","text":"<pre><code>virtual meta::MetaRegistry &amp; quite::client::GrpcProbe::meta_registry () override\n</code></pre> <p>Implements quite::client::Probe::meta_registry</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProbe/#function-wait_for_started","title":"function wait_for_started","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::GrpcProbe::wait_for_started (\n    std::chrono::seconds timeout\n) override\n</code></pre> <p>Implements quite::client::Probe::wait_for_started</p> <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_probe.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/","title":"Class quite::client::GrpcProperty","text":"<p>ClassList &gt; quite &gt; client &gt; GrpcProperty</p> <p>Inherits the following classes: quite::client::Property</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#public-functions","title":"Public Functions","text":"Type Name GrpcProperty (std::shared_ptr&lt; GrpcRemoteObject &gt; parent, std::string name, entt::meta_any initial_value)  QUITE_DISABLE_COPY_MOVE (GrpcProperty)  virtual const std::string &amp; name () override const virtual AsyncResult&lt; entt::meta_any &gt; read () override virtual meta::TypeId type_id () override const virtual const Result&lt; entt::meta_any &gt; &amp; value () override const virtual AsyncResult&lt; void &gt; write (entt::meta_any value) override ~GrpcProperty () override"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#public-functions-inherited-from-quiteclientproperty","title":"Public Functions inherited from quite::client::Property","text":"<p>See quite::client::Property</p> Type Name Property () = default QUITE_DISABLE_COPY_MOVE (Property)  virtual const std::string &amp; name () const = 0 virtual AsyncResult&lt; entt::meta_any &gt; read () = 0 virtual meta::TypeId type_id () const = 0 virtual const Result&lt; entt::meta_any &gt; &amp; value () const = 0 virtual AsyncResult&lt; void &gt; write (entt::meta_any value) = 0 virtual ~Property ()"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-grpcproperty","title":"function GrpcProperty","text":"<pre><code>explicit quite::client::GrpcProperty::GrpcProperty (\n    std::shared_ptr&lt; GrpcRemoteObject &gt; parent,\n    std::string name,\n    entt::meta_any initial_value\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::client::GrpcProperty::QUITE_DISABLE_COPY_MOVE (\n    GrpcProperty\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-name","title":"function name","text":"<pre><code>virtual const std::string &amp; quite::client::GrpcProperty::name () override const\n</code></pre> <p>Implements quite::client::Property::name</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-read","title":"function read","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::client::GrpcProperty::read () override\n</code></pre> <p>Implements quite::client::Property::read</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-type_id","title":"function type_id","text":"<pre><code>virtual meta::TypeId quite::client::GrpcProperty::type_id () override const\n</code></pre> <p>Implements quite::client::Property::type_id</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-value","title":"function value","text":"<pre><code>virtual const Result&lt; entt::meta_any &gt; &amp; quite::client::GrpcProperty::value () override const\n</code></pre> <p>Implements quite::client::Property::value</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-write","title":"function write","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::GrpcProperty::write (\n    entt::meta_any value\n) override\n</code></pre> <p>Implements quite::client::Property::write</p>"},{"location":"quite/classquite_1_1client_1_1GrpcProperty/#function-grpcproperty_1","title":"function ~GrpcProperty","text":"<pre><code>quite::client::GrpcProperty::~GrpcProperty () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_property.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/","title":"Class quite::client::GrpcRemoteObject","text":"<p>ClassList &gt; quite &gt; client &gt; GrpcRemoteObject</p> <p>Inherits the following classes: std::enable_shared_from_this&lt; GrpcRemoteObject &gt;,  quite::client::RemoteObject</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#public-functions","title":"Public Functions","text":"Type Name GrpcRemoteObject (ObjectReference reference, std::shared_ptr&lt; proto::ProbeClient &gt; client)  virtual AsyncResult&lt; std::unordered_map&lt; std::string, PropertyPtr &gt; &gt; fetch_properties (std::vector&lt; std::string &gt; properties) override AsyncResult&lt; entt::meta_any &gt; fetch_property (std::string property_name)  virtual AsyncResult&lt; void &gt; invoke_method (std::string method_name) override virtual AsyncResult&lt; void &gt; mouse_action () override virtual AsyncResult&lt; PropertyPtr &gt; property (std::string property_name) override virtual AsyncResult&lt; Image &gt; take_snapshot () override virtual meta::TypeId type_id () override const virtual AsyncResult&lt; void &gt; write_property (std::string property_name, entt::meta_any value) override"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#public-functions-inherited-from-quiteclientremoteobject","title":"Public Functions inherited from quite::client::RemoteObject","text":"<p>See quite::client::RemoteObject</p> Type Name RemoteObject (ObjectId id)  virtual AsyncResult&lt; std::unordered_map&lt; std::string, PropertyPtr &gt; &gt; fetch_properties (std::vector&lt; std::string &gt; properties) = 0 ObjectId id () noexcept const virtual AsyncResult&lt; void &gt; invoke_method (std::string method_name) = 0 virtual AsyncResult&lt; void &gt; mouse_action () = 0 virtual AsyncResult&lt; PropertyPtr &gt; property (std::string property_name) = 0 virtual AsyncResult&lt; Image &gt; take_snapshot () = 0 virtual meta::TypeId type_id () const = 0 virtual AsyncResult&lt; void &gt; write_property (std::string property_name, entt::meta_any value) = 0 virtual ~RemoteObject ()"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-grpcremoteobject","title":"function GrpcRemoteObject","text":"<pre><code>explicit quite::client::GrpcRemoteObject::GrpcRemoteObject (\n    ObjectReference reference,\n    std::shared_ptr&lt; proto::ProbeClient &gt; client\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-fetch_properties","title":"function fetch_properties","text":"<pre><code>virtual AsyncResult&lt; std::unordered_map&lt; std::string, PropertyPtr &gt; &gt; quite::client::GrpcRemoteObject::fetch_properties (\n    std::vector&lt; std::string &gt; properties\n) override\n</code></pre> <p>Implements quite::client::RemoteObject::fetch_properties</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-fetch_property","title":"function fetch_property","text":"<pre><code>AsyncResult&lt; entt::meta_any &gt; quite::client::GrpcRemoteObject::fetch_property (\n    std::string property_name\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::GrpcRemoteObject::invoke_method (\n    std::string method_name\n) override\n</code></pre> <p>Implements quite::client::RemoteObject::invoke_method</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-mouse_action","title":"function mouse_action","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::GrpcRemoteObject::mouse_action () override\n</code></pre> <p>Implements quite::client::RemoteObject::mouse_action</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-property","title":"function property","text":"<pre><code>virtual AsyncResult&lt; PropertyPtr &gt; quite::client::GrpcRemoteObject::property (\n    std::string property_name\n) override\n</code></pre> <p>Implements quite::client::RemoteObject::property</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; Image &gt; quite::client::GrpcRemoteObject::take_snapshot () override\n</code></pre> <p>Implements quite::client::RemoteObject::take_snapshot</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-type_id","title":"function type_id","text":"<pre><code>virtual meta::TypeId quite::client::GrpcRemoteObject::type_id () override const\n</code></pre> <p>Implements quite::client::RemoteObject::type_id</p>"},{"location":"quite/classquite_1_1client_1_1GrpcRemoteObject/#function-write_property","title":"function write_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::GrpcRemoteObject::write_property (\n    std::string property_name,\n    entt::meta_any value\n) override\n</code></pre> <p>Implements quite::client::RemoteObject::write_property</p> <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_remote_object.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/","title":"Class quite::client::GrpcValueConverter","text":"<p>ClassList &gt; quite &gt; client &gt; GrpcValueConverter</p> <p>Inherits the following classes: quite::proto::IValueConverter</p>"},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/#public-functions","title":"Public Functions","text":"Type Name virtual entt::meta_any from (ObjectReference ref) override const void set_client (std::shared_ptr&lt; proto::ProbeClient &gt; client)"},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/#public-functions-inherited-from-quiteprotoivalueconverter","title":"Public Functions inherited from quite::proto::IValueConverter","text":"<p>See quite::proto::IValueConverter</p> Type Name virtual entt::meta_any from (ObjectReference ref) const = 0 virtual ~IValueConverter () = default"},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/#function-from","title":"function from","text":"<pre><code>virtual entt::meta_any quite::client::GrpcValueConverter::from (\n    ObjectReference ref\n) override const\n</code></pre> <p>Implements quite::proto::IValueConverter::from</p>"},{"location":"quite/classquite_1_1client_1_1GrpcValueConverter/#function-set_client","title":"function set_client","text":"<pre><code>void quite::client::GrpcValueConverter::set_client (\n    std::shared_ptr&lt; proto::ProbeClient &gt; client\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_value.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1Probe/","title":"Class quite::client::Probe","text":"<p>ClassList &gt; quite &gt; client &gt; Probe</p> <p>Inherited by the following classes: quite::client::BasicProbe</p>"},{"location":"quite/classquite_1_1client_1_1Probe/#public-functions","title":"Public Functions","text":"Type Name Probe () = default QUITE_DISABLE_COPY_MOVE (Probe)  virtual AsyncResult&lt; void &gt; exit () = 0 virtual AsyncResult&lt; RemoteObjectPtr &gt; find_object (ObjectQuery query) = 0 virtual AsyncResult&lt; std::vector&lt; RemoteObjectPtr &gt; &gt; get_views () = 0 virtual meta::MetaRegistry &amp; meta_registry () = 0 virtual AsyncResult&lt; void &gt; wait_for_started (std::chrono::seconds timeout) = 0 virtual ~Probe () = default"},{"location":"quite/classquite_1_1client_1_1Probe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1Probe/#function-probe","title":"function Probe","text":"<pre><code>quite::client::Probe::Probe () = default\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::client::Probe::QUITE_DISABLE_COPY_MOVE (\n    Probe\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-exit","title":"function exit","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::Probe::exit () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; RemoteObjectPtr &gt; quite::client::Probe::find_object (\n    ObjectQuery query\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-get_views","title":"function get_views","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; RemoteObjectPtr &gt; &gt; quite::client::Probe::get_views () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-meta_registry","title":"function meta_registry","text":"<pre><code>virtual meta::MetaRegistry &amp; quite::client::Probe::meta_registry () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-wait_for_started","title":"function wait_for_started","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::Probe::wait_for_started (\n    std::chrono::seconds timeout\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Probe/#function-probe_1","title":"function ~Probe","text":"<pre><code>virtual quite::client::Probe::~Probe () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1ProbeHandle/","title":"Class quite::client::ProbeHandle","text":"<p>ClassList &gt; quite &gt; client &gt; ProbeHandle</p>"},{"location":"quite/classquite_1_1client_1_1ProbeHandle/#public-functions","title":"Public Functions","text":"Type Name ProbeHandle (std::shared_ptr&lt; Probe &gt; probe)  Probe * operator-&gt; ()"},{"location":"quite/classquite_1_1client_1_1ProbeHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1ProbeHandle/#function-probehandle","title":"function ProbeHandle","text":"<pre><code>explicit quite::client::ProbeHandle::ProbeHandle (\n    std::shared_ptr&lt; Probe &gt; probe\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeHandle/#function-operator-","title":"function operator-&gt;","text":"<pre><code>Probe * quite::client::ProbeHandle::operator-&gt; () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe_handle.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/","title":"Class quite::client::ProbeManager","text":"<p>ClassList &gt; quite &gt; client &gt; ProbeManager</p>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#classes","title":"Classes","text":"Type Name struct Impl"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#public-functions","title":"Public Functions","text":"Type Name ProbeManager ()  ProbeManager (ProbeManager &amp;&amp;) noexcept QUITE_DISABLE_COPY (ProbeManager)  ProbeHandle connect (manager::ProcessHandle handle, const std::string &amp; connection_url)  ProbeManager &amp; operator= (ProbeManager &amp;&amp;) noexcept ~ProbeManager ()"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-probemanager-12","title":"function ProbeManager [1/2]","text":"<pre><code>quite::client::ProbeManager::ProbeManager () \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-probemanager-22","title":"function ProbeManager [2/2]","text":"<pre><code>quite::client::ProbeManager::ProbeManager (\n    ProbeManager &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::client::ProbeManager::QUITE_DISABLE_COPY (\n    ProbeManager\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-connect","title":"function connect","text":"<pre><code>ProbeHandle quite::client::ProbeManager::connect (\n    manager::ProcessHandle handle,\n    const std::string &amp; connection_url\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-operator","title":"function operator=","text":"<pre><code>ProbeManager &amp; quite::client::ProbeManager::operator= (\n    ProbeManager &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1ProbeManager/#function-probemanager","title":"function ~ProbeManager","text":"<pre><code>quite::client::ProbeManager::~ProbeManager () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe_manager.hpp</code></p>"},{"location":"quite/structquite_1_1client_1_1ProbeManager_1_1Impl/","title":"Struct quite::client::ProbeManager::Impl","text":"<p>ClassList &gt; quite &gt; client &gt; ProbeManager &gt; Impl</p> <p>The documentation for this class was generated from the following file <code>libs/client/src/probe_manager.cpp</code></p>"},{"location":"quite/classquite_1_1client_1_1Property/","title":"Class quite::client::Property","text":"<p>ClassList &gt; quite &gt; client &gt; Property</p> <p>Inherited by the following classes: quite::client::GrpcProperty</p>"},{"location":"quite/classquite_1_1client_1_1Property/#public-functions","title":"Public Functions","text":"Type Name Property () = default QUITE_DISABLE_COPY_MOVE (Property)  virtual const std::string &amp; name () const = 0 virtual AsyncResult&lt; entt::meta_any &gt; read () = 0 virtual meta::TypeId type_id () const = 0 virtual const Result&lt; entt::meta_any &gt; &amp; value () const = 0 virtual AsyncResult&lt; void &gt; write (entt::meta_any value) = 0 virtual ~Property ()"},{"location":"quite/classquite_1_1client_1_1Property/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1Property/#function-property","title":"function Property","text":"<pre><code>quite::client::Property::Property () = default\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::client::Property::QUITE_DISABLE_COPY_MOVE (\n    Property\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-name","title":"function name","text":"<pre><code>virtual const std::string &amp; quite::client::Property::name () const = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-read","title":"function read","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::client::Property::read () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-type_id","title":"function type_id","text":"<pre><code>virtual meta::TypeId quite::client::Property::type_id () const = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-value","title":"function value","text":"<pre><code>virtual const Result&lt; entt::meta_any &gt; &amp; quite::client::Property::value () const = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-write","title":"function write","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::Property::write (\n    entt::meta_any value\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1Property/#function-property_1","title":"function ~Property","text":"<pre><code>virtual quite::client::Property::~Property () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/property.hpp</code></p>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/","title":"Class quite::client::RemoteObject","text":"<p>ClassList &gt; quite &gt; client &gt; RemoteObject</p> <p>Inherited by the following classes: quite::client::GrpcRemoteObject</p>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#public-functions","title":"Public Functions","text":"Type Name RemoteObject (ObjectId id)  virtual AsyncResult&lt; std::unordered_map&lt; std::string, PropertyPtr &gt; &gt; fetch_properties (std::vector&lt; std::string &gt; properties) = 0 ObjectId id () noexcept const virtual AsyncResult&lt; void &gt; invoke_method (std::string method_name) = 0 virtual AsyncResult&lt; void &gt; mouse_action () = 0 virtual AsyncResult&lt; PropertyPtr &gt; property (std::string property_name) = 0 virtual AsyncResult&lt; Image &gt; take_snapshot () = 0 virtual meta::TypeId type_id () const = 0 virtual AsyncResult&lt; void &gt; write_property (std::string property_name, entt::meta_any value) = 0 virtual ~RemoteObject ()"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-remoteobject","title":"function RemoteObject","text":"<pre><code>explicit quite::client::RemoteObject::RemoteObject (\n    ObjectId id\n) \n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-fetch_properties","title":"function fetch_properties","text":"<pre><code>virtual AsyncResult&lt; std::unordered_map&lt; std::string, PropertyPtr &gt; &gt; quite::client::RemoteObject::fetch_properties (\n    std::vector&lt; std::string &gt; properties\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-id","title":"function id","text":"<pre><code>ObjectId quite::client::RemoteObject::id () noexcept const\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::RemoteObject::invoke_method (\n    std::string method_name\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-mouse_action","title":"function mouse_action","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::RemoteObject::mouse_action () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-property","title":"function property","text":"<pre><code>virtual AsyncResult&lt; PropertyPtr &gt; quite::client::RemoteObject::property (\n    std::string property_name\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; Image &gt; quite::client::RemoteObject::take_snapshot () = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-type_id","title":"function type_id","text":"<pre><code>virtual meta::TypeId quite::client::RemoteObject::type_id () const = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-write_property","title":"function write_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::client::RemoteObject::write_property (\n    std::string property_name,\n    entt::meta_any value\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1client_1_1RemoteObject/#function-remoteobject_1","title":"function ~RemoteObject","text":"<pre><code>virtual quite::client::RemoteObject::~RemoteObject () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/remote_object.hpp</code></p>"},{"location":"quite/namespacequite_1_1core/","title":"Namespace quite::core","text":"<p>Namespace List &gt; quite &gt; core</p>"},{"location":"quite/namespacequite_1_1core/#classes","title":"Classes","text":"Type Name class IMouseInjector struct MouseAction"},{"location":"quite/namespacequite_1_1core/#public-types","title":"Public Types","text":"Type Name enum KeyboardModifier enum MouseButton enum MouseTrigger"},{"location":"quite/namespacequite_1_1core/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/namespacequite_1_1core/#enum-keyboardmodifier","title":"enum KeyboardModifier","text":"<pre><code>enum quite::core::KeyboardModifier {\n    none,\n    shift,\n    control,\n    alt,\n    meta\n};\n</code></pre>"},{"location":"quite/namespacequite_1_1core/#enum-mousebutton","title":"enum MouseButton","text":"<pre><code>enum quite::core::MouseButton {\n    none,\n    left,\n    right,\n    middle,\n    forward,\n    back\n};\n</code></pre>"},{"location":"quite/namespacequite_1_1core/#enum-mousetrigger","title":"enum MouseTrigger","text":"<pre><code>enum quite::core::MouseTrigger {\n    none,\n    click,\n    double_click,\n    press,\n    release,\n    move\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/keys.hpp</code></p>"},{"location":"quite/classquite_1_1core_1_1IMouseInjector/","title":"Class quite::core::IMouseInjector","text":"<p>ClassList &gt; quite &gt; core &gt; IMouseInjector</p> <p>Inherited by the following classes: quite::probe::MouseInjector,  quite::proto::MouseInjectorImpl</p>"},{"location":"quite/classquite_1_1core_1_1IMouseInjector/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; void &gt; single_action (ObjectId target_id, MouseAction action) = 0 virtual ~IMouseInjector () = default"},{"location":"quite/classquite_1_1core_1_1IMouseInjector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1core_1_1IMouseInjector/#function-single_action","title":"function single_action","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::core::IMouseInjector::single_action (\n    ObjectId target_id,\n    MouseAction action\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1core_1_1IMouseInjector/#function-imouseinjector","title":"function ~IMouseInjector","text":"<pre><code>virtual quite::core::IMouseInjector::~IMouseInjector () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/mouse_injector.hpp</code></p>"},{"location":"quite/structquite_1_1core_1_1MouseAction/","title":"Struct quite::core::MouseAction","text":"<p>ClassList &gt; quite &gt; core &gt; MouseAction</p>"},{"location":"quite/structquite_1_1core_1_1MouseAction/#public-attributes","title":"Public Attributes","text":"Type Name MouseButton button KeyboardModifier modifier Vector2 position MouseTrigger trigger"},{"location":"quite/structquite_1_1core_1_1MouseAction/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1core_1_1MouseAction/#variable-button","title":"variable button","text":"<pre><code>MouseButton quite::core::MouseAction::button;\n</code></pre>"},{"location":"quite/structquite_1_1core_1_1MouseAction/#variable-modifier","title":"variable modifier","text":"<pre><code>KeyboardModifier quite::core::MouseAction::modifier;\n</code></pre>"},{"location":"quite/structquite_1_1core_1_1MouseAction/#variable-position","title":"variable position","text":"<pre><code>Vector2 quite::core::MouseAction::position;\n</code></pre>"},{"location":"quite/structquite_1_1core_1_1MouseAction/#variable-trigger","title":"variable trigger","text":"<pre><code>MouseTrigger quite::core::MouseAction::trigger;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/mouse_injector.hpp</code></p>"},{"location":"quite/namespacequite_1_1manager/","title":"Namespace quite::manager","text":"<p>Namespace List &gt; quite &gt; manager</p>"},{"location":"quite/namespacequite_1_1manager/#classes","title":"Classes","text":"Type Name class BasicProcessManager class NoopProcess class Process class ProcessHandle struct ProcessId class ProcessImpl class ProcessManager class ProcessManagerClient class RemoteProcessManager class Server <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/basic_process_manager.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/","title":"Class quite::manager::BasicProcessManager","text":"<p>ClassList &gt; quite &gt; manager &gt; BasicProcessManager</p> <p>Inherited by the following classes: quite::manager::ProcessManager,  quite::manager::RemoteProcessManager</p>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-types","title":"Public Types","text":"Type Name typedef std::unordered_map&lt; std::string, std::string &gt; Environment"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) = 0Tries to lookup the application with the given id. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) = 0Tries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) = 0Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. virtual ~BasicProcessManager ()"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-static-functions","title":"Public Static Functions","text":"Type Name ProcessHandle noop_process () Creates a process handle with does nothing, always finished with exit code 0."},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#typedef-environment","title":"typedef Environment","text":"<pre><code>using quite::manager::BasicProcessManager::Environment =  std::unordered_map&lt;std::string, std::string&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#function-application","title":"function application","text":"<p>Tries to lookup the application with the given id. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::BasicProcessManager::application (\n    ProcessId name\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> the id of the application (which was used to launch or attach a application) </li> </ul> <p>Returns:</p> <p>Result&lt;ProcessHandle&gt; An instance of an application or a not found error otherwise </p>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#function-find_executable","title":"function find_executable","text":"<p>Tries to find the given executable in the PATH equivalent environment entry. </p> <pre><code>virtual AsyncResult&lt; std::filesystem::path &gt; quite::manager::BasicProcessManager::find_executable (\n    std::filesystem::path exe_name,\n    Environment environment\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>exe_name</code> the application name </li> <li><code>environment</code> the environment to search in </li> </ul> <p>Returns:</p> <p>Result&lt;std::filesystem::path&gt; either an error or the absolute path to the executable </p>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#function-launch_application","title":"function launch_application","text":"<p>Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::BasicProcessManager::launch_application (\n    ProcessId id,\n    std::string path_to_application,\n    std::vector&lt; std::string &gt; args,\n    Environment environment\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> a user defined id (name) to retrieve a handle later on </li> <li><code>path_to_application</code> </li> <li><code>args</code> </li> <li><code>environment</code> </li> </ul> <p>Returns:</p> <p>ProcessHandle </p>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#function-basicprocessmanager","title":"function ~BasicProcessManager","text":"<pre><code>virtual quite::manager::BasicProcessManager::~BasicProcessManager () \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1BasicProcessManager/#function-noop_process","title":"function noop_process","text":"<p>Creates a process handle with does nothing, always finished with exit code 0. </p> <pre><code>static ProcessHandle quite::manager::BasicProcessManager::noop_process () \n</code></pre> <p>Returns:</p> <p>ProcessHandle </p> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/basic_process_manager.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/","title":"Class quite::manager::NoopProcess","text":"<p>ClassList &gt; quite &gt; manager &gt; NoopProcess</p> <p>Inherits the following classes: quite::manager::Process</p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; int &gt; async_wait_exit () override virtual int exit_code () override virtual bool is_running () override virtual Result&lt; void &gt; request_exit () override virtual Result&lt; void &gt; terminate () override"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#public-functions-inherited-from-quitemanagerprocess","title":"Public Functions inherited from quite::manager::Process","text":"<p>See quite::manager::Process</p> Type Name virtual AsyncResult&lt; int &gt; async_wait_exit () = 0 virtual int exit_code () = 0 virtual bool is_running () = 0 virtual Result&lt; void &gt; request_exit () = 0 virtual Result&lt; void &gt; terminate () = 0 virtual ~Process () = default"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#function-async_wait_exit","title":"function async_wait_exit","text":"<pre><code>virtual AsyncResult&lt; int &gt; quite::manager::NoopProcess::async_wait_exit () override\n</code></pre> <p>Implements quite::manager::Process::async_wait_exit</p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#function-exit_code","title":"function exit_code","text":"<pre><code>virtual int quite::manager::NoopProcess::exit_code () override\n</code></pre> <p>Implements quite::manager::Process::exit_code</p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#function-is_running","title":"function is_running","text":"<pre><code>virtual bool quite::manager::NoopProcess::is_running () override\n</code></pre> <p>Implements quite::manager::Process::is_running</p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#function-request_exit","title":"function request_exit","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::NoopProcess::request_exit () override\n</code></pre> <p>Implements quite::manager::Process::request_exit</p>"},{"location":"quite/classquite_1_1manager_1_1NoopProcess/#function-terminate","title":"function terminate","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::NoopProcess::terminate () override\n</code></pre> <p>Implements quite::manager::Process::terminate</p> <p>The documentation for this class was generated from the following file <code>libs/manager/src/noop_process.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1Process/","title":"Class quite::manager::Process","text":"<p>ClassList &gt; quite &gt; manager &gt; Process</p> <p>Inherited by the following classes: quite::manager::NoopProcess,  quite::manager::ProcessImpl</p>"},{"location":"quite/classquite_1_1manager_1_1Process/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; int &gt; async_wait_exit () = 0 virtual int exit_code () = 0 virtual bool is_running () = 0 virtual Result&lt; void &gt; request_exit () = 0 virtual Result&lt; void &gt; terminate () = 0 virtual ~Process () = default"},{"location":"quite/classquite_1_1manager_1_1Process/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1Process/#function-async_wait_exit","title":"function async_wait_exit","text":"<pre><code>virtual AsyncResult&lt; int &gt; quite::manager::Process::async_wait_exit () = 0\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Process/#function-exit_code","title":"function exit_code","text":"<pre><code>virtual int quite::manager::Process::exit_code () = 0\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Process/#function-is_running","title":"function is_running","text":"<pre><code>virtual bool quite::manager::Process::is_running () = 0\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Process/#function-request_exit","title":"function request_exit","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::Process::request_exit () = 0\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Process/#function-terminate","title":"function terminate","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::Process::terminate () = 0\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Process/#function-process","title":"function ~Process","text":"<pre><code>virtual quite::manager::Process::~Process () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/","title":"Class quite::manager::ProcessHandle","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessHandle</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/#public-functions","title":"Public Functions","text":"Type Name ProcessHandle (std::shared_ptr&lt; Process &gt; process)  Process &amp; instance ()  Process * operator-&gt; ()"},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/#function-processhandle","title":"function ProcessHandle","text":"<pre><code>explicit quite::manager::ProcessHandle::ProcessHandle (\n    std::shared_ptr&lt; Process &gt; process\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/#function-instance","title":"function instance","text":"<pre><code>Process &amp; quite::manager::ProcessHandle::instance () \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessHandle/#function-operator-","title":"function operator-&gt;","text":"<pre><code>Process * quite::manager::ProcessHandle::operator-&gt; () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process_handle.hpp</code></p>"},{"location":"quite/structquite_1_1manager_1_1ProcessId/","title":"Struct quite::manager::ProcessId","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessId</p>"},{"location":"quite/structquite_1_1manager_1_1ProcessId/#public-attributes","title":"Public Attributes","text":"Type Name std::string name"},{"location":"quite/structquite_1_1manager_1_1ProcessId/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1manager_1_1ProcessId/#variable-name","title":"variable name","text":"<pre><code>std::string quite::manager::ProcessId::name;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/basic_process_manager.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/","title":"Class quite::manager::ProcessImpl","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessImpl</p> <p>Inherits the following classes: quite::manager::Process</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#public-functions","title":"Public Functions","text":"Type Name ProcessImpl (boost::process::v2::process &amp;&amp; process)  virtual AsyncResult&lt; int &gt; async_wait_exit () override virtual int exit_code () override virtual bool is_running () override virtual Result&lt; void &gt; request_exit () override virtual Result&lt; void &gt; terminate () override"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#public-functions-inherited-from-quitemanagerprocess","title":"Public Functions inherited from quite::manager::Process","text":"<p>See quite::manager::Process</p> Type Name virtual AsyncResult&lt; int &gt; async_wait_exit () = 0 virtual int exit_code () = 0 virtual bool is_running () = 0 virtual Result&lt; void &gt; request_exit () = 0 virtual Result&lt; void &gt; terminate () = 0 virtual ~Process () = default"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-processimpl","title":"function ProcessImpl","text":"<pre><code>explicit quite::manager::ProcessImpl::ProcessImpl (\n    boost::process::v2::process &amp;&amp; process\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-async_wait_exit","title":"function async_wait_exit","text":"<pre><code>virtual AsyncResult&lt; int &gt; quite::manager::ProcessImpl::async_wait_exit () override\n</code></pre> <p>Implements quite::manager::Process::async_wait_exit</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-exit_code","title":"function exit_code","text":"<pre><code>virtual int quite::manager::ProcessImpl::exit_code () override\n</code></pre> <p>Implements quite::manager::Process::exit_code</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-is_running","title":"function is_running","text":"<pre><code>virtual bool quite::manager::ProcessImpl::is_running () override\n</code></pre> <p>Implements quite::manager::Process::is_running</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-request_exit","title":"function request_exit","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::ProcessImpl::request_exit () override\n</code></pre> <p>Implements quite::manager::Process::request_exit</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessImpl/#function-terminate","title":"function terminate","text":"<pre><code>virtual Result&lt; void &gt; quite::manager::ProcessImpl::terminate () override\n</code></pre> <p>Implements quite::manager::Process::terminate</p> <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_impl.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/","title":"Class quite::manager::ProcessManager","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessManager</p> <p>Inherits the following classes: quite::manager::BasicProcessManager</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#classes","title":"Classes","text":"Type Name struct Impl"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-types-inherited-from-quitemanagerbasicprocessmanager","title":"Public Types inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name typedef std::unordered_map&lt; std::string, std::string &gt; Environment"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-functions","title":"Public Functions","text":"Type Name ProcessManager (asio_impl::thread_pool::executor_type executor)  QUITE_DEFAULT_MOVE (ProcessManager)  QUITE_DISABLE_COPY (ProcessManager)  virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId id) overrideTries to lookup the application with the given id. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment=current_environment()) overrideTries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args={}, Environment environment=current_environment()) overrideLaunches the application but does not preloads any probe. Can be used to start arbitrary installed programs. ~ProcessManager () override"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) = 0Tries to lookup the application with the given id. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) = 0Tries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) = 0Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. virtual ~BasicProcessManager ()"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-static-functions","title":"Public Static Functions","text":"Type Name Environment current_environment () Returns the current environment of the running process where the ProcessManager lives."},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-static-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Static Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name ProcessHandle noop_process () Creates a process handle with does nothing, always finished with exit code 0."},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-processmanager","title":"function ProcessManager","text":"<pre><code>explicit quite::manager::ProcessManager::ProcessManager (\n    asio_impl::thread_pool::executor_type executor\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-quite_default_move","title":"function QUITE_DEFAULT_MOVE","text":"<pre><code>quite::manager::ProcessManager::QUITE_DEFAULT_MOVE (\n    ProcessManager\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::manager::ProcessManager::QUITE_DISABLE_COPY (\n    ProcessManager\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-application","title":"function application","text":"<p>Tries to lookup the application with the given id. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::ProcessManager::application (\n    ProcessId id\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> the id of the application (which was used to launch or attach a application) </li> </ul> <p>Returns:</p> <p>Result&lt;ProcessHandle&gt; An instance of an application or a not found error otherwise </p> <p>Implements quite::manager::BasicProcessManager::application</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-find_executable","title":"function find_executable","text":"<p>Tries to find the given executable in the PATH equivalent environment entry. </p> <pre><code>virtual AsyncResult&lt; std::filesystem::path &gt; quite::manager::ProcessManager::find_executable (\n    std::filesystem::path exe_name,\n    Environment environment=current_environment ()\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>exe_name</code> the application name </li> <li><code>environment</code> the environment to search in </li> </ul> <p>Returns:</p> <p>Result&lt;std::filesystem::path&gt; either an error or the absolute path to the executable </p> <p>Implements quite::manager::BasicProcessManager::find_executable</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-launch_application","title":"function launch_application","text":"<p>Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::ProcessManager::launch_application (\n    ProcessId id,\n    std::string path_to_application,\n    std::vector&lt; std::string &gt; args={},\n    Environment environment=current_environment ()\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>id_name</code> a user defined id (name) to retrieve a handle later on </li> <li><code>path_to_application</code> </li> <li><code>args</code> </li> <li><code>environment</code> </li> </ul> <p>Returns:</p> <p>ProcessHandle </p> <p>Implements quite::manager::BasicProcessManager::launch_application</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-processmanager_1","title":"function ~ProcessManager","text":"<pre><code>quite::manager::ProcessManager::~ProcessManager () override\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1ProcessManager/#function-current_environment","title":"function current_environment","text":"<p>Returns the current environment of the running process where the ProcessManager lives.</p> <pre><code>static Environment quite::manager::ProcessManager::current_environment () \n</code></pre> <p>Returns:</p> <p>Environment </p> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process_manager.hpp</code></p>"},{"location":"quite/structquite_1_1manager_1_1ProcessManager_1_1Impl/","title":"Struct quite::manager::ProcessManager::Impl","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessManager &gt; Impl</p>"},{"location":"quite/structquite_1_1manager_1_1ProcessManager_1_1Impl/#public-attributes","title":"Public Attributes","text":"Type Name std::unordered_map&lt; std::string, std::shared_ptr&lt; Process &gt; &gt; applications_ quite::asio_impl::any_io_executor executor_"},{"location":"quite/structquite_1_1manager_1_1ProcessManager_1_1Impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1manager_1_1ProcessManager_1_1Impl/#variable-applications_","title":"variable applications_","text":"<pre><code>std::unordered_map&lt;std::string, std::shared_ptr&lt;Process&gt; &gt; quite::manager::ProcessManager::Impl::applications_;\n</code></pre>"},{"location":"quite/structquite_1_1manager_1_1ProcessManager_1_1Impl/#variable-executor_","title":"variable executor_","text":"<pre><code>quite::asio_impl::any_io_executor quite::manager::ProcessManager::Impl::executor_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_manager.cpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/","title":"Class quite::manager::ProcessManagerClient","text":"<p>ClassList &gt; quite &gt; manager &gt; ProcessManagerClient</p> <p>Inherits the following classes: quite::manager::RemoteProcessManager</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-types-inherited-from-quitemanagerbasicprocessmanager","title":"Public Types inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name typedef std::unordered_map&lt; std::string, std::string &gt; Environment"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-functions","title":"Public Functions","text":"Type Name ProcessManagerClient ()  QUITE_DEFAULT_MOVE (ProcessManagerClient)  QUITE_DISABLE_COPY (ProcessManagerClient)  Result&lt; ProcessHandle &gt; application (const ProcessId &amp; id) override AsyncResult&lt; Environment &gt; current_environment ()  virtual Result&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) overrideTries to find the given executable in the PATH equivalent environment entry. Result&lt; ProcessHandle &gt; launch_application (ProcessId id, const std::string &amp; path_to_application, const std::vector&lt; std::string &gt; &amp; args, const Environment &amp; environment) override ~ProcessManagerClient () override"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-functions-inherited-from-quitemanagerremoteprocessmanager","title":"Public Functions inherited from quite::manager::RemoteProcessManager","text":"<p>See quite::manager::RemoteProcessManager</p> Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) overrideTries to lookup the application with the given id. AsyncResult&lt; Environment &gt; current_remote_environment () Tries to fetch the remote environment from the connected process manager. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) overrideTries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) overrideLaunches the application but does not preloads any probe. Can be used to start arbitrary installed programs."},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) = 0Tries to lookup the application with the given id. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) = 0Tries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) = 0Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. virtual ~BasicProcessManager ()"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-static-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Static Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name ProcessHandle noop_process () Creates a process handle with does nothing, always finished with exit code 0."},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-processmanagerclient","title":"function ProcessManagerClient","text":"<pre><code>explicit quite::manager::ProcessManagerClient::ProcessManagerClient () \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-quite_default_move","title":"function QUITE_DEFAULT_MOVE","text":"<pre><code>quite::manager::ProcessManagerClient::QUITE_DEFAULT_MOVE (\n    ProcessManagerClient\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::manager::ProcessManagerClient::QUITE_DISABLE_COPY (\n    ProcessManagerClient\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-application","title":"function application","text":"<pre><code>Result&lt; ProcessHandle &gt; quite::manager::ProcessManagerClient::application (\n    const ProcessId &amp; id\n) override\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-current_environment","title":"function current_environment","text":"<pre><code>AsyncResult&lt; Environment &gt; quite::manager::ProcessManagerClient::current_environment () \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-find_executable","title":"function find_executable","text":"<p>Tries to find the given executable in the PATH equivalent environment entry. </p> <pre><code>virtual Result&lt; std::filesystem::path &gt; quite::manager::ProcessManagerClient::find_executable (\n    std::filesystem::path exe_name,\n    Environment environment\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>exe_name</code> the application name </li> <li><code>environment</code> the environment to search in </li> </ul> <p>Returns:</p> <p>Result&lt;std::filesystem::path&gt; either an error or the absolute path to the executable </p> <p>Implements quite::manager::BasicProcessManager::find_executable</p>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-launch_application","title":"function launch_application","text":"<pre><code>Result&lt; ProcessHandle &gt; quite::manager::ProcessManagerClient::launch_application (\n    ProcessId id,\n    const std::string &amp; path_to_application,\n    const std::vector&lt; std::string &gt; &amp; args,\n    const Environment &amp; environment\n) override\n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1ProcessManagerClient/#function-processmanagerclient_1","title":"function ~ProcessManagerClient","text":"<pre><code>quite::manager::ProcessManagerClient::~ProcessManagerClient () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_manager_client.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/","title":"Class quite::manager::RemoteProcessManager","text":"<p>ClassList &gt; quite &gt; manager &gt; RemoteProcessManager</p> <p>Inherits the following classes: quite::manager::BasicProcessManager</p> <p>Inherited by the following classes: quite::manager::ProcessManagerClient</p>"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#public-types-inherited-from-quitemanagerbasicprocessmanager","title":"Public Types inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name typedef std::unordered_map&lt; std::string, std::string &gt; Environment"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) overrideTries to lookup the application with the given id. AsyncResult&lt; Environment &gt; current_remote_environment () Tries to fetch the remote environment from the connected process manager. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) overrideTries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) overrideLaunches the application but does not preloads any probe. Can be used to start arbitrary installed programs."},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#public-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name virtual AsyncResult&lt; ProcessHandle &gt; application (ProcessId name) = 0Tries to lookup the application with the given id. virtual AsyncResult&lt; std::filesystem::path &gt; find_executable (std::filesystem::path exe_name, Environment environment) = 0Tries to find the given executable in the PATH equivalent environment entry. virtual AsyncResult&lt; ProcessHandle &gt; launch_application (ProcessId id, std::string path_to_application, std::vector&lt; std::string &gt; args, Environment environment) = 0Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. virtual ~BasicProcessManager ()"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#public-static-functions-inherited-from-quitemanagerbasicprocessmanager","title":"Public Static Functions inherited from quite::manager::BasicProcessManager","text":"<p>See quite::manager::BasicProcessManager</p> Type Name ProcessHandle noop_process () Creates a process handle with does nothing, always finished with exit code 0."},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#function-application","title":"function application","text":"<p>Tries to lookup the application with the given id. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::RemoteProcessManager::application (\n    ProcessId name\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> the id of the application (which was used to launch or attach a application) </li> </ul> <p>Returns:</p> <p>Result&lt;ProcessHandle&gt; An instance of an application or a not found error otherwise </p> <p>Implements quite::manager::BasicProcessManager::application</p>"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#function-current_remote_environment","title":"function current_remote_environment","text":"<p>Tries to fetch the remote environment from the connected process manager. </p> <pre><code>AsyncResult&lt; Environment &gt; quite::manager::RemoteProcessManager::current_remote_environment () \n</code></pre> <p>Returns:</p> <p>AsyncResult&lt;Environment&gt; </p>"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#function-find_executable","title":"function find_executable","text":"<p>Tries to find the given executable in the PATH equivalent environment entry. </p> <pre><code>virtual AsyncResult&lt; std::filesystem::path &gt; quite::manager::RemoteProcessManager::find_executable (\n    std::filesystem::path exe_name,\n    Environment environment\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>exe_name</code> the application name </li> <li><code>environment</code> the environment to search in </li> </ul> <p>Returns:</p> <p>Result&lt;std::filesystem::path&gt; either an error or the absolute path to the executable </p> <p>Implements quite::manager::BasicProcessManager::find_executable</p>"},{"location":"quite/classquite_1_1manager_1_1RemoteProcessManager/#function-launch_application","title":"function launch_application","text":"<p>Launches the application but does not preloads any probe. Can be used to start arbitrary installed programs. </p> <pre><code>virtual AsyncResult&lt; ProcessHandle &gt; quite::manager::RemoteProcessManager::launch_application (\n    ProcessId id,\n    std::string path_to_application,\n    std::vector&lt; std::string &gt; args,\n    Environment environment\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> a user defined id (name) to retrieve a handle later on </li> <li><code>path_to_application</code> </li> <li><code>args</code> </li> <li><code>environment</code> </li> </ul> <p>Returns:</p> <p>ProcessHandle </p> <p>Implements quite::manager::BasicProcessManager::launch_application</p> <p>The documentation for this class was generated from the following file <code>libs/manager/src/remote_process_manager.hpp</code></p>"},{"location":"quite/classquite_1_1manager_1_1Server/","title":"Class quite::manager::Server","text":"<p>ClassList &gt; quite &gt; manager &gt; Server</p>"},{"location":"quite/classquite_1_1manager_1_1Server/#public-functions","title":"Public Functions","text":"Type Name QUITE_DEFAULT_MOVE (Server)  QUITE_DISABLE_COPY (Server)  Server ()  ~Server ()"},{"location":"quite/classquite_1_1manager_1_1Server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1manager_1_1Server/#function-quite_default_move","title":"function QUITE_DEFAULT_MOVE","text":"<pre><code>quite::manager::Server::QUITE_DEFAULT_MOVE (\n    Server\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Server/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::manager::Server::QUITE_DISABLE_COPY (\n    Server\n) \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Server/#function-server","title":"function Server","text":"<pre><code>quite::manager::Server::Server () \n</code></pre>"},{"location":"quite/classquite_1_1manager_1_1Server/#function-server_1","title":"function ~Server","text":"<pre><code>quite::manager::Server::~Server () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/server.hpp</code></p>"},{"location":"quite/namespacequite_1_1meta/","title":"Namespace quite::meta","text":"<p>Namespace List &gt; quite &gt; meta</p>"},{"location":"quite/namespacequite_1_1meta/#classes","title":"Classes","text":"Type Name struct EnumType struct ListType struct MapType class MetaRegistry struct Method struct ObjectType struct Property"},{"location":"quite/namespacequite_1_1meta/#public-types","title":"Public Types","text":"Type Name typedef std::unique_ptr&lt; EnumType &gt; EnumTypePtr typedef std::unique_ptr&lt; ObjectType &gt; ObjectTypePtr enum PrimitiveType typedef std::variant&lt; PrimitiveType, ListType, MapType, EnumTypePtr, ObjectTypePtr &gt; Type typedef std::uint64_t TypeId"},{"location":"quite/namespacequite_1_1meta/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/namespacequite_1_1meta/#typedef-enumtypeptr","title":"typedef EnumTypePtr","text":"<pre><code>using quite::meta::EnumTypePtr = typedef std::unique_ptr&lt;EnumType&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1meta/#typedef-objecttypeptr","title":"typedef ObjectTypePtr","text":"<pre><code>using quite::meta::ObjectTypePtr = typedef std::unique_ptr&lt;ObjectType&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1meta/#enum-primitivetype","title":"enum PrimitiveType","text":"<pre><code>enum quite::meta::PrimitiveType {\n    type_unknown = 0,\n    type_void,\n    type_int,\n    type_uint,\n    type_float,\n    type_double,\n    type_bool,\n    type_string\n};\n</code></pre>"},{"location":"quite/namespacequite_1_1meta/#typedef-type","title":"typedef Type","text":"<pre><code>using quite::meta::Type = typedef std::variant&lt;PrimitiveType, ListType, MapType, EnumTypePtr, ObjectTypePtr&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1meta/#typedef-typeid","title":"typedef TypeId","text":"<pre><code>using quite::meta::TypeId = typedef std::uint64_t;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_registry.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1EnumType/","title":"Struct quite::meta::EnumType","text":"<p>ClassList &gt; quite &gt; meta &gt; EnumType</p>"},{"location":"quite/structquite_1_1meta_1_1EnumType/#public-types","title":"Public Types","text":"Type Name typedef std::string ValueName"},{"location":"quite/structquite_1_1meta_1_1EnumType/#public-attributes","title":"Public Attributes","text":"Type Name TypeId id std::string name std::unordered_map&lt; ValueName, std::int64_t &gt; values"},{"location":"quite/structquite_1_1meta_1_1EnumType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1EnumType/#typedef-valuename","title":"typedef ValueName","text":"<pre><code>using quite::meta::EnumType::ValueName =  std::string;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1EnumType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1EnumType/#variable-id","title":"variable id","text":"<pre><code>TypeId quite::meta::EnumType::id;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1EnumType/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::EnumType::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1EnumType/#variable-values","title":"variable values","text":"<pre><code>std::unordered_map&lt;ValueName, std::int64_t&gt; quite::meta::EnumType::values;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1ListType/","title":"Struct quite::meta::ListType","text":"<p>ClassList &gt; quite &gt; meta &gt; ListType</p>"},{"location":"quite/structquite_1_1meta_1_1ListType/#public-attributes","title":"Public Attributes","text":"Type Name TypeId id std::string name TypeId value_type"},{"location":"quite/structquite_1_1meta_1_1ListType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1ListType/#variable-id","title":"variable id","text":"<pre><code>TypeId quite::meta::ListType::id;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ListType/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::ListType::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ListType/#variable-value_type","title":"variable value_type","text":"<pre><code>TypeId quite::meta::ListType::value_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1MapType/","title":"Struct quite::meta::MapType","text":"<p>ClassList &gt; quite &gt; meta &gt; MapType</p>"},{"location":"quite/structquite_1_1meta_1_1MapType/#public-attributes","title":"Public Attributes","text":"Type Name TypeId id TypeId key_type std::string name TypeId value_type"},{"location":"quite/structquite_1_1meta_1_1MapType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1MapType/#variable-id","title":"variable id","text":"<pre><code>TypeId quite::meta::MapType::id;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1MapType/#variable-key_type","title":"variable key_type","text":"<pre><code>TypeId quite::meta::MapType::key_type;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1MapType/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::MapType::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1MapType/#variable-value_type","title":"variable value_type","text":"<pre><code>TypeId quite::meta::MapType::value_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/classquite_1_1meta_1_1MetaRegistry/","title":"Class quite::meta::MetaRegistry","text":"<p>ClassList &gt; quite &gt; meta &gt; MetaRegistry</p> <p>Inherited by the following classes: quite::probe::QtMetaRegistry,  quite::proto::MetaRegistryImpl</p>"},{"location":"quite/classquite_1_1meta_1_1MetaRegistry/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; meta::Type &gt; lookup_type (meta::TypeId type_id) = 0 virtual ~MetaRegistry () = default"},{"location":"quite/classquite_1_1meta_1_1MetaRegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1meta_1_1MetaRegistry/#function-lookup_type","title":"function lookup_type","text":"<pre><code>virtual AsyncResult&lt; meta::Type &gt; quite::meta::MetaRegistry::lookup_type (\n    meta::TypeId type_id\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1meta_1_1MetaRegistry/#function-metaregistry","title":"function ~MetaRegistry","text":"<pre><code>virtual quite::meta::MetaRegistry::~MetaRegistry () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_registry.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1Method/","title":"Struct quite::meta::Method","text":"<p>ClassList &gt; quite &gt; meta &gt; Method</p>"},{"location":"quite/structquite_1_1meta_1_1Method/#public-attributes","title":"Public Attributes","text":"Type Name std::string name std::vector&lt; Property &gt; parameters TypeId return_type"},{"location":"quite/structquite_1_1meta_1_1Method/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1Method/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::Method::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1Method/#variable-parameters","title":"variable parameters","text":"<pre><code>std::vector&lt;Property&gt; quite::meta::Method::parameters;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1Method/#variable-return_type","title":"variable return_type","text":"<pre><code>TypeId quite::meta::Method::return_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/","title":"Struct quite::meta::ObjectType","text":"<p>ClassList &gt; quite &gt; meta &gt; ObjectType</p>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; Method &gt; constructors TypeId id std::vector&lt; Method &gt; methods std::string name std::vector&lt; Property &gt; properties"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1ObjectType/#variable-constructors","title":"variable constructors","text":"<pre><code>std::vector&lt;Method&gt; quite::meta::ObjectType::constructors;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#variable-id","title":"variable id","text":"<pre><code>TypeId quite::meta::ObjectType::id;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#variable-methods","title":"variable methods","text":"<pre><code>std::vector&lt;Method&gt; quite::meta::ObjectType::methods;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::ObjectType::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1ObjectType/#variable-properties","title":"variable properties","text":"<pre><code>std::vector&lt;Property&gt; quite::meta::ObjectType::properties;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/structquite_1_1meta_1_1Property/","title":"Struct quite::meta::Property","text":"<p>ClassList &gt; quite &gt; meta &gt; Property</p>"},{"location":"quite/structquite_1_1meta_1_1Property/#public-attributes","title":"Public Attributes","text":"Type Name std::string name TypeId type"},{"location":"quite/structquite_1_1meta_1_1Property/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1meta_1_1Property/#variable-name","title":"variable name","text":"<pre><code>std::string quite::meta::Property::name;\n</code></pre>"},{"location":"quite/structquite_1_1meta_1_1Property/#variable-type","title":"variable type","text":"<pre><code>TypeId quite::meta::Property::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/namespacequite_1_1probe/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; quite &gt; probe</p>"},{"location":"quite/namespacequite_1_1probe/#classes","title":"Classes","text":"Type Name class MetaAdapter class MethodInvoker class MouseInjector class ObjectTracker class ProbeContext class QtMetaRegistry class QtProbeHandler"},{"location":"quite/namespacequite_1_1probe/#public-functions","title":"Public Functions","text":"Type Name constexpr QObject * from_object_id (ObjectId obj_id)  void register_converters (ValueRegistry &amp; value_registry)  AsyncResult&lt; QImage &gt; take_snapshot_of_qobject (QObject * object)  constexpr ObjectId to_object_id (const QObject * obj)  const QMetaObject * try_get_qt_meta_object (const QObject * object)  QMetaType try_get_qt_meta_type (const QMetaObject * meta_object)  QMetaType try_get_qt_meta_type (const QObject * object)"},{"location":"quite/namespacequite_1_1probe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite_1_1probe/#function-from_object_id","title":"function from_object_id","text":"<pre><code>constexpr QObject * quite::probe::from_object_id (\n    ObjectId obj_id\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-register_converters","title":"function register_converters","text":"<pre><code>void quite::probe::register_converters (\n    ValueRegistry &amp; value_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-take_snapshot_of_qobject","title":"function take_snapshot_of_qobject","text":"<pre><code>AsyncResult&lt; QImage &gt; quite::probe::take_snapshot_of_qobject (\n    QObject * object\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-to_object_id","title":"function to_object_id","text":"<pre><code>constexpr ObjectId quite::probe::to_object_id (\n    const QObject * obj\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-try_get_qt_meta_object","title":"function try_get_qt_meta_object","text":"<pre><code>const QMetaObject * quite::probe::try_get_qt_meta_object (\n    const QObject * object\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-try_get_qt_meta_type","title":"function try_get_qt_meta_type","text":"<pre><code>QMetaType quite::probe::try_get_qt_meta_type (\n    const QMetaObject * meta_object\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1probe/#function-try_get_qt_meta_type_1","title":"function try_get_qt_meta_type","text":"<pre><code>QMetaType quite::probe::try_get_qt_meta_type (\n    const QObject * object\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/mouse_injector.cpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1MetaAdapter/","title":"Class quite::probe::MetaAdapter","text":"<p>ClassList &gt; quite &gt; probe &gt; MetaAdapter</p>"},{"location":"quite/classquite_1_1probe_1_1MetaAdapter/#public-functions","title":"Public Functions","text":"Type Name AsyncResult&lt; meta::Type &gt; find_type_by_id (meta::TypeId type_id)"},{"location":"quite/classquite_1_1probe_1_1MetaAdapter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1MetaAdapter/#function-find_type_by_id","title":"function find_type_by_id","text":"<pre><code>AsyncResult&lt; meta::Type &gt; quite::probe::MetaAdapter::find_type_by_id (\n    meta::TypeId type_id\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_adapter.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1MethodInvoker/","title":"Class quite::probe::MethodInvoker","text":"<p>ClassList &gt; quite &gt; probe &gt; MethodInvoker</p>"},{"location":"quite/classquite_1_1probe_1_1MethodInvoker/#public-functions","title":"Public Functions","text":"Type Name MethodInvoker ()  Result&lt; entt::meta_any &gt; invoke_method (const entt::meta_any &amp; object, std::string_view qualified_method_signature, std::span&lt; entt::meta_any &gt; params) const"},{"location":"quite/classquite_1_1probe_1_1MethodInvoker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1MethodInvoker/#function-methodinvoker","title":"function MethodInvoker","text":"<pre><code>quite::probe::MethodInvoker::MethodInvoker () \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1MethodInvoker/#function-invoke_method","title":"function invoke_method","text":"<pre><code>Result&lt; entt::meta_any &gt; quite::probe::MethodInvoker::invoke_method (\n    const entt::meta_any &amp; object,\n    std::string_view qualified_method_signature,\n    std::span&lt; entt::meta_any &gt; params\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/method_invoker.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/","title":"Class quite::probe::MouseInjector","text":"<p>ClassList &gt; quite &gt; probe &gt; MouseInjector</p> <p>Inherits the following classes: quite::core::IMouseInjector</p>"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#public-functions","title":"Public Functions","text":"Type Name MouseInjector (const ObjectTracker &amp; object_tracker)  virtual AsyncResult&lt; void &gt; single_action (ObjectId target_id, core::MouseAction action) override ~MouseInjector () override"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#public-functions-inherited-from-quitecoreimouseinjector","title":"Public Functions inherited from quite::core::IMouseInjector","text":"<p>See quite::core::IMouseInjector</p> Type Name virtual AsyncResult&lt; void &gt; single_action (ObjectId target_id, MouseAction action) = 0 virtual ~IMouseInjector () = default"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#function-mouseinjector","title":"function MouseInjector","text":"<pre><code>explicit quite::probe::MouseInjector::MouseInjector (\n    const ObjectTracker &amp; object_tracker\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#function-single_action","title":"function single_action","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::probe::MouseInjector::single_action (\n    ObjectId target_id,\n    core::MouseAction action\n) override\n</code></pre> <p>Implements quite::core::IMouseInjector::single_action</p>"},{"location":"quite/classquite_1_1probe_1_1MouseInjector/#function-mouseinjector_1","title":"function ~MouseInjector","text":"<pre><code>quite::probe::MouseInjector::~MouseInjector () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/mouse_injector.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/","title":"Class quite::probe::ObjectTracker","text":"<p>ClassList &gt; quite &gt; probe &gt; ObjectTracker</p> <p>Inherits the following classes: QObject</p>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#public-functions","title":"Public Functions","text":"Type Name ObjectTracker ()  void add_object (QObject * obj)  Result&lt; ObjectReference &gt; find_object (const std::string &amp; object_name) const Result&lt; ObjectReference &gt; find_object_by_query (const ObjectQuery &amp; query) const Result&lt; QObject * &gt; get_object_by_id (ObjectId obj_id) const void remove_object (QObject * obj)  const std::unordered_set&lt; QObject * &gt; &amp; top_level_views () const ~ObjectTracker () override"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-objecttracker","title":"function ObjectTracker","text":"<pre><code>quite::probe::ObjectTracker::ObjectTracker () \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-add_object","title":"function add_object","text":"<pre><code>void quite::probe::ObjectTracker::add_object (\n    QObject * obj\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-find_object","title":"function find_object","text":"<pre><code>Result&lt; ObjectReference &gt; quite::probe::ObjectTracker::find_object (\n    const std::string &amp; object_name\n) const\n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-find_object_by_query","title":"function find_object_by_query","text":"<pre><code>Result&lt; ObjectReference &gt; quite::probe::ObjectTracker::find_object_by_query (\n    const ObjectQuery &amp; query\n) const\n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-get_object_by_id","title":"function get_object_by_id","text":"<pre><code>Result&lt; QObject * &gt; quite::probe::ObjectTracker::get_object_by_id (\n    ObjectId obj_id\n) const\n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-remove_object","title":"function remove_object","text":"<pre><code>void quite::probe::ObjectTracker::remove_object (\n    QObject * obj\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-top_level_views","title":"function top_level_views","text":"<pre><code>const std::unordered_set&lt; QObject * &gt; &amp; quite::probe::ObjectTracker::top_level_views () const\n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ObjectTracker/#function-objecttracker_1","title":"function ~ObjectTracker","text":"<pre><code>quite::probe::ObjectTracker::~ObjectTracker () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/object_tracker.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/","title":"Class quite::probe::ProbeContext","text":"<p>ClassList &gt; quite &gt; probe &gt; ProbeContext</p>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#public-functions","title":"Public Functions","text":"Type Name ProbeContext (std::string server_address)  QUITE_DISABLE_COPY_MOVE (ProbeContext)  void qt_hook_add_object (QObject * q)  void qt_hook_remove_object (QObject * q)  void qt_hook_startup ()  ~ProbeContext ()"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-probecontext","title":"function ProbeContext","text":"<pre><code>explicit quite::probe::ProbeContext::ProbeContext (\n    std::string server_address\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::probe::ProbeContext::QUITE_DISABLE_COPY_MOVE (\n    ProbeContext\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-qt_hook_add_object","title":"function qt_hook_add_object","text":"<pre><code>void quite::probe::ProbeContext::qt_hook_add_object (\n    QObject * q\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-qt_hook_remove_object","title":"function qt_hook_remove_object","text":"<pre><code>void quite::probe::ProbeContext::qt_hook_remove_object (\n    QObject * q\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-qt_hook_startup","title":"function qt_hook_startup","text":"<pre><code>void quite::probe::ProbeContext::qt_hook_startup () \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1ProbeContext/#function-probecontext_1","title":"function ~ProbeContext","text":"<pre><code>quite::probe::ProbeContext::~ProbeContext () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/probe_context.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1QtMetaRegistry/","title":"Class quite::probe::QtMetaRegistry","text":"<p>ClassList &gt; quite &gt; probe &gt; QtMetaRegistry</p> <p>Inherits the following classes: quite::meta::MetaRegistry</p>"},{"location":"quite/classquite_1_1probe_1_1QtMetaRegistry/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; meta::Type &gt; lookup_type (meta::TypeId type_id) override"},{"location":"quite/classquite_1_1probe_1_1QtMetaRegistry/#public-functions-inherited-from-quitemetametaregistry","title":"Public Functions inherited from quite::meta::MetaRegistry","text":"<p>See quite::meta::MetaRegistry</p> Type Name virtual AsyncResult&lt; meta::Type &gt; lookup_type (meta::TypeId type_id) = 0 virtual ~MetaRegistry () = default"},{"location":"quite/classquite_1_1probe_1_1QtMetaRegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1QtMetaRegistry/#function-lookup_type","title":"function lookup_type","text":"<pre><code>virtual AsyncResult&lt; meta::Type &gt; quite::probe::QtMetaRegistry::lookup_type (\n    meta::TypeId type_id\n) override\n</code></pre> <p>Implements quite::meta::MetaRegistry::lookup_type</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_registry.hpp</code></p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/","title":"Class quite::probe::QtProbeHandler","text":"<p>ClassList &gt; quite &gt; probe &gt; QtProbeHandler</p> <p>Inherits the following classes: quite::proto::IProbeHandler</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#public-types-inherited-from-quiteprotoiprobehandler","title":"Public Types inherited from quite::proto::IProbeHandler","text":"<p>See quite::proto::IProbeHandler</p> Type Name typedef entt::dense_map&lt; std::string, entt::meta_any &gt; PropertyMap"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#public-functions","title":"Public Functions","text":"Type Name QtProbeHandler (const ObjectTracker &amp; object_tracker)  virtual AsyncResult&lt; PropertyMap &gt; fetch_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) override virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; fetch_windows () override virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery query) override virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (entt::meta_any object, std::string qualified_method_signature, std::vector&lt; entt::meta_any &gt; params) override virtual AsyncResult&lt; entt::meta_any &gt; object_instance (ObjectId object_id) override virtual AsyncResult&lt; void &gt; set_property (ObjectId object_id, std::string property, entt::meta_any value) override virtual AsyncResult&lt; ImageData &gt; take_snapshot (ObjectId object_id) override"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#public-functions-inherited-from-quiteprotoiprobehandler","title":"Public Functions inherited from quite::proto::IProbeHandler","text":"<p>See quite::proto::IProbeHandler</p> Type Name virtual AsyncResult&lt; PropertyMap &gt; fetch_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) = 0 virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; fetch_windows () = 0 virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery query) = 0 virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (entt::meta_any object, std::string qualified_method_signature, std::vector&lt; entt::meta_any &gt; params) = 0 virtual AsyncResult&lt; entt::meta_any &gt; object_instance (ObjectId object_id) = 0 virtual AsyncResult&lt; void &gt; set_property (ObjectId object_id, std::string property, entt::meta_any value) = 0 virtual AsyncResult&lt; ImageData &gt; take_snapshot (ObjectId object_id) = 0 virtual ~IProbeHandler () = default"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-qtprobehandler","title":"function QtProbeHandler","text":"<pre><code>explicit quite::probe::QtProbeHandler::QtProbeHandler (\n    const ObjectTracker &amp; object_tracker\n) \n</code></pre>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-fetch_properties","title":"function fetch_properties","text":"<pre><code>virtual AsyncResult&lt; PropertyMap &gt; quite::probe::QtProbeHandler::fetch_properties (\n    ObjectId object_id,\n    std::vector&lt; std::string &gt; properties\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::fetch_properties</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-fetch_windows","title":"function fetch_windows","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; quite::probe::QtProbeHandler::fetch_windows () override\n</code></pre> <p>Implements quite::proto::IProbeHandler::fetch_windows</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; ObjectReference &gt; quite::probe::QtProbeHandler::find_object (\n    ObjectQuery query\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::find_object</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::probe::QtProbeHandler::invoke_method (\n    entt::meta_any object,\n    std::string qualified_method_signature,\n    std::vector&lt; entt::meta_any &gt; params\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::invoke_method</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-object_instance","title":"function object_instance","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::probe::QtProbeHandler::object_instance (\n    ObjectId object_id\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::object_instance</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-set_property","title":"function set_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::probe::QtProbeHandler::set_property (\n    ObjectId object_id,\n    std::string property,\n    entt::meta_any value\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::set_property</p>"},{"location":"quite/classquite_1_1probe_1_1QtProbeHandler/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; ImageData &gt; quite::probe::QtProbeHandler::take_snapshot (\n    ObjectId object_id\n) override\n</code></pre> <p>Implements quite::proto::IProbeHandler::take_snapshot</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_probe_handler.hpp</code></p>"},{"location":"quite/namespacequite_1_1proto/","title":"Namespace quite::proto","text":"<p>Namespace List &gt; quite &gt; proto</p>"},{"location":"quite/namespacequite_1_1proto/#classes","title":"Classes","text":"Type Name class Client struct FindObjectRpcHandler struct GetMetaObjectRpcHandler struct GetObjectPropertiesRpcHandler struct GetViewsRpcHandler class GrpcManager class IProbeHandler class IProbeService class IValueConverter struct InvokeMethodRpcHandler class MetaRegistryImpl struct MouseActionRpcHandler class MouseInjectorImpl class ProbeClient class ProbeClientImpl class ProbeServiceImpl class ProbeValueConverter struct ProtocolVisitor class Server struct SetObjectPropertyRpcHandler struct SnapshotRpcHandler"},{"location":"quite/namespacequite_1_1proto/#public-types","title":"Public Types","text":"Type Name typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestFindObject &gt; FindObjectRPC typedef agrpc::ServerRPC&lt;&amp;quite::proto::MetaService::AsyncService::RequestFindType &gt; FindTypeRPC typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetObjectProperties &gt; GetObjectPropertiesRPC typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetViews &gt; GetViewsRPC typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestInvokeMethod &gt; InvokeMethodRPC typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestMouseAction &gt; MouseActionRPC typedef ServiceHandle&lt; IProbeHandler &gt; ProbeHandlerHandle typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestCreateScreenshot &gt; RpcSnapshot typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestSetObjectProperty &gt; SetObjectPropertyRPC"},{"location":"quite/namespacequite_1_1proto/#public-functions","title":"Public Functions","text":"Type Name void configure_client_context (grpc::ClientContext &amp; client_context)  entt::meta_any convert_value (const ValueRegistry &amp; value_registry, const IValueConverter &amp; converter, const Value &amp; value)  Value create_value (const ValueRegistry &amp; value_registry, const entt::meta_any &amp; any)  meta::PrimitiveType from_protocol (const MetaPrimitiveType &amp; type)  meta::ListType from_protocol (const MetaListType &amp; type)  meta::MapType from_protocol (const MetaMapType &amp; type)  meta::ObjectTypePtr from_protocol (const MetaObjectType &amp; type)  meta::EnumTypePtr from_protocol (const MetaEnumType &amp; type)  Error grpc_status2result (const grpc::Status &amp; error)  agrpc::detail::RPCHandlerSender&lt; GetObjectPropertiesRPC, GetObjectPropertiesRpcHandler &gt; make_rpc_fetch_object_properties (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler, ServiceHandle&lt; ValueRegistry &gt; value_registry)  agrpc::detail::RPCHandlerSender&lt; GetViewsRPC, GetViewsRpcHandler &gt; make_rpc_fetch_windows (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler)  agrpc::detail::RPCHandlerSender&lt; FindObjectRPC, FindObjectRpcHandler &gt; make_rpc_find_object (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler, ServiceHandle&lt; ValueRegistry &gt; value_registry)  agrpc::detail::RPCHandlerSender&lt; InvokeMethodRPC, InvokeMethodRpcHandler &gt; make_rpc_invoke_method (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler, ServiceHandle&lt; ValueRegistry &gt; value_registry)  agrpc::detail::RPCHandlerSender&lt; FindTypeRPC, GetMetaObjectRpcHandler &gt; make_rpc_meta_find_type (agrpc::GrpcContext &amp; grpc_context, quite::proto::MetaService::AsyncService &amp; service, ServiceHandle&lt; meta::MetaRegistry &gt; meta_registry)  agrpc::detail::RPCHandlerSender&lt; MouseActionRPC, MouseActionRpcHandler &gt; make_rpc_mouse_injection (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ServiceHandle&lt; core::IMouseInjector &gt; mouse_injector)  agrpc::detail::RPCHandlerSender&lt; SetObjectPropertyRPC, SetObjectPropertyRpcHandler &gt; make_rpc_set_object_property (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler, ServiceHandle&lt; ValueRegistry &gt; value_registry)  agrpc::detail::RPCHandlerSender&lt; RpcSnapshot, SnapshotRpcHandler &gt; make_rpc_snapshot (agrpc::GrpcContext &amp; grpc_context, quite::proto::ProbeService::AsyncService &amp; service, ProbeHandlerHandle probe_handler)  grpc::Status result2grpc_status (const Error &amp; error)  void to_protocol (const meta::Type &amp; type, MetaType &amp; proto)"},{"location":"quite/namespacequite_1_1proto/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/namespacequite_1_1proto/#typedef-findobjectrpc","title":"typedef FindObjectRPC","text":"<pre><code>using quite::proto::FindObjectRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestFindObject&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-findtyperpc","title":"typedef FindTypeRPC","text":"<pre><code>using quite::proto::FindTypeRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::MetaService::AsyncService::RequestFindType&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-getobjectpropertiesrpc","title":"typedef GetObjectPropertiesRPC","text":"<pre><code>using quite::proto::GetObjectPropertiesRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetObjectProperties&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-getviewsrpc","title":"typedef GetViewsRPC","text":"<pre><code>using quite::proto::GetViewsRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetViews&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-invokemethodrpc","title":"typedef InvokeMethodRPC","text":"<pre><code>using quite::proto::InvokeMethodRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestInvokeMethod&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-mouseactionrpc","title":"typedef MouseActionRPC","text":"<pre><code>using quite::proto::MouseActionRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestMouseAction&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-probehandlerhandle","title":"typedef ProbeHandlerHandle","text":"<pre><code>using quite::proto::ProbeHandlerHandle = typedef ServiceHandle&lt;IProbeHandler&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-rpcsnapshot","title":"typedef RpcSnapshot","text":"<pre><code>using quite::proto::RpcSnapshot = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestCreateScreenshot&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#typedef-setobjectpropertyrpc","title":"typedef SetObjectPropertyRPC","text":"<pre><code>using quite::proto::SetObjectPropertyRPC = typedef agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestSetObjectProperty&gt;;\n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite_1_1proto/#function-configure_client_context","title":"function configure_client_context","text":"<pre><code>void quite::proto::configure_client_context (\n    grpc::ClientContext &amp; client_context\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-convert_value","title":"function convert_value","text":"<pre><code>entt::meta_any quite::proto::convert_value (\n    const ValueRegistry &amp; value_registry,\n    const IValueConverter &amp; converter,\n    const Value &amp; value\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-create_value","title":"function create_value","text":"<pre><code>Value quite::proto::create_value (\n    const ValueRegistry &amp; value_registry,\n    const entt::meta_any &amp; any\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-from_protocol","title":"function from_protocol","text":"<pre><code>meta::PrimitiveType quite::proto::from_protocol (\n    const MetaPrimitiveType &amp; type\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-from_protocol_1","title":"function from_protocol","text":"<pre><code>meta::ListType quite::proto::from_protocol (\n    const MetaListType &amp; type\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-from_protocol_2","title":"function from_protocol","text":"<pre><code>meta::MapType quite::proto::from_protocol (\n    const MetaMapType &amp; type\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-from_protocol_3","title":"function from_protocol","text":"<pre><code>meta::ObjectTypePtr quite::proto::from_protocol (\n    const MetaObjectType &amp; type\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-from_protocol_4","title":"function from_protocol","text":"<pre><code>meta::EnumTypePtr quite::proto::from_protocol (\n    const MetaEnumType &amp; type\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-grpc_status2result","title":"function grpc_status2result","text":"<pre><code>Error quite::proto::grpc_status2result (\n    const grpc::Status &amp; error\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_fetch_object_properties","title":"function make_rpc_fetch_object_properties","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; GetObjectPropertiesRPC, GetObjectPropertiesRpcHandler &gt; quite::proto::make_rpc_fetch_object_properties (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_fetch_windows","title":"function make_rpc_fetch_windows","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; GetViewsRPC, GetViewsRpcHandler &gt; quite::proto::make_rpc_fetch_windows (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_find_object","title":"function make_rpc_find_object","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; FindObjectRPC, FindObjectRpcHandler &gt; quite::proto::make_rpc_find_object (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_invoke_method","title":"function make_rpc_invoke_method","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; InvokeMethodRPC, InvokeMethodRpcHandler &gt; quite::proto::make_rpc_invoke_method (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_meta_find_type","title":"function make_rpc_meta_find_type","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; FindTypeRPC, GetMetaObjectRpcHandler &gt; quite::proto::make_rpc_meta_find_type (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::MetaService::AsyncService &amp; service,\n    ServiceHandle &lt; meta::MetaRegistry &gt; meta_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_mouse_injection","title":"function make_rpc_mouse_injection","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; MouseActionRPC, MouseActionRpcHandler &gt; quite::proto::make_rpc_mouse_injection (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ServiceHandle &lt; core::IMouseInjector &gt; mouse_injector\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_set_object_property","title":"function make_rpc_set_object_property","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; SetObjectPropertyRPC, SetObjectPropertyRpcHandler &gt; quite::proto::make_rpc_set_object_property (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-make_rpc_snapshot","title":"function make_rpc_snapshot","text":"<pre><code>agrpc::detail::RPCHandlerSender&lt; RpcSnapshot, SnapshotRpcHandler &gt; quite::proto::make_rpc_snapshot (\n    agrpc::GrpcContext &amp; grpc_context,\n    quite::proto::ProbeService::AsyncService &amp; service,\n    ProbeHandlerHandle probe_handler\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-result2grpc_status","title":"function result2grpc_status","text":"<pre><code>grpc::Status quite::proto::result2grpc_status (\n    const Error &amp; error\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1proto/#function-to_protocol","title":"function to_protocol","text":"<pre><code>void quite::proto::to_protocol (\n    const meta::Type &amp; type,\n    MetaType &amp; proto\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/client.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1Client/","title":"Class quite::proto::Client","text":"<p>ClassList &gt; quite &gt; proto &gt; Client</p>"},{"location":"quite/classquite_1_1proto_1_1Client/#classes","title":"Classes","text":"Type Name struct Impl"},{"location":"quite/classquite_1_1proto_1_1Client/#public-functions","title":"Public Functions","text":"Type Name Client (entt::locator&lt; ValueRegistry &gt;::node_type value_registry)  QUITE_DISABLE_COPY_MOVE (Client)  std::shared_ptr&lt; ProbeClient &gt; create_probe_client (std::shared_ptr&lt; IValueConverter &gt; value_converter, std::string connection_url)  ~Client ()"},{"location":"quite/classquite_1_1proto_1_1Client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1Client/#function-client","title":"function Client","text":"<pre><code>explicit quite::proto::Client::Client (\n    entt::locator&lt; ValueRegistry &gt;::node_type value_registry\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Client/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::proto::Client::QUITE_DISABLE_COPY_MOVE (\n    Client\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Client/#function-create_probe_client","title":"function create_probe_client","text":"<pre><code>std::shared_ptr&lt; ProbeClient &gt; quite::proto::Client::create_probe_client (\n    std::shared_ptr&lt; IValueConverter &gt; value_converter,\n    std::string connection_url\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Client/#function-client_1","title":"function ~Client","text":"<pre><code>quite::proto::Client::~Client () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/client.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1Client_1_1Impl/","title":"Struct quite::proto::Client::Impl","text":"<p>ClassList &gt; quite &gt; proto &gt; Client &gt; Impl</p>"},{"location":"quite/structquite_1_1proto_1_1Client_1_1Impl/#public-attributes","title":"Public Attributes","text":"Type Name GrpcManager grpc_"},{"location":"quite/structquite_1_1proto_1_1Client_1_1Impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1Client_1_1Impl/#variable-grpc_","title":"variable grpc_","text":"<pre><code>GrpcManager quite::proto::Client::Impl::grpc_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/client.cpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/","title":"Struct quite::proto::FindObjectRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; FindObjectRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler ServiceHandle&lt; ValueRegistry &gt; value_registry"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (FindObjectRPC &amp; rpc, const FindObjectRPC::Request &amp; request)"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::FindObjectRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#variable-value_registry","title":"variable value_registry","text":"<pre><code>ServiceHandle&lt;ValueRegistry&gt; quite::proto::FindObjectRpcHandler::value_registry;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1FindObjectRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::FindObjectRpcHandler::operator() (\n    FindObjectRPC &amp; rpc,\n    const FindObjectRPC::Request &amp; request\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_find_object.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/","title":"Struct quite::proto::GetMetaObjectRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; GetMetaObjectRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ServiceHandle&lt; meta::MetaRegistry &gt; meta_registry"},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (FindTypeRPC &amp; rpc, const FindTypeRPC::Request &amp; request)"},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#variable-meta_registry","title":"variable meta_registry","text":"<pre><code>ServiceHandle&lt;meta::MetaRegistry&gt; quite::proto::GetMetaObjectRpcHandler::meta_registry;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetMetaObjectRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::GetMetaObjectRpcHandler::operator() (\n    FindTypeRPC &amp; rpc,\n    const FindTypeRPC::Request &amp; request\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_meta_find_type.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/","title":"Struct quite::proto::GetObjectPropertiesRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; GetObjectPropertiesRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler ServiceHandle&lt; ValueRegistry &gt; value_registry"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (GetObjectPropertiesRPC &amp; rpc, const GetObjectPropertiesRPC::Request &amp; request)"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::GetObjectPropertiesRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#variable-value_registry","title":"variable value_registry","text":"<pre><code>ServiceHandle&lt;ValueRegistry&gt; quite::proto::GetObjectPropertiesRpcHandler::value_registry;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetObjectPropertiesRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::GetObjectPropertiesRpcHandler::operator() (\n    GetObjectPropertiesRPC &amp; rpc,\n    const GetObjectPropertiesRPC::Request &amp; request\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_object_properties.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/","title":"Struct quite::proto::GetViewsRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; GetViewsRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler"},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (GetViewsRPC &amp; rpc, const GetViewsRPC::Request &amp; request) const"},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::GetViewsRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1GetViewsRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::GetViewsRpcHandler::operator() (\n    GetViewsRPC &amp; rpc,\n    const GetViewsRPC::Request &amp; request\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_fetch_windows.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/","title":"Class quite::proto::GrpcManager","text":"<p>ClassList &gt; quite &gt; proto &gt; GrpcManager</p>"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#public-functions","title":"Public Functions","text":"Type Name GrpcManager ()  QUITE_DISABLE_COPY_MOVE (GrpcManager)  std::shared_ptr&lt; agrpc::GrpcContext &gt; context ()  ~GrpcManager ()"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#function-grpcmanager","title":"function GrpcManager","text":"<pre><code>quite::proto::GrpcManager::GrpcManager () \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::proto::GrpcManager::QUITE_DISABLE_COPY_MOVE (\n    GrpcManager\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#function-context","title":"function context","text":"<pre><code>std::shared_ptr&lt; agrpc::GrpcContext &gt; quite::proto::GrpcManager::context () \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1GrpcManager/#function-grpcmanager_1","title":"function ~GrpcManager","text":"<pre><code>quite::proto::GrpcManager::~GrpcManager () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/grpc_manager.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/","title":"Class quite::proto::IProbeHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; IProbeHandler</p> <p>Inherited by the following classes: quite::probe::QtProbeHandler</p>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#classes","title":"Classes","text":"Type Name struct ImageData"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#public-types","title":"Public Types","text":"Type Name typedef entt::dense_map&lt; std::string, entt::meta_any &gt; PropertyMap"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; PropertyMap &gt; fetch_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) = 0 virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; fetch_windows () = 0 virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery query) = 0 virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (entt::meta_any object, std::string qualified_method_signature, std::vector&lt; entt::meta_any &gt; params) = 0 virtual AsyncResult&lt; entt::meta_any &gt; object_instance (ObjectId object_id) = 0 virtual AsyncResult&lt; void &gt; set_property (ObjectId object_id, std::string property, entt::meta_any value) = 0 virtual AsyncResult&lt; ImageData &gt; take_snapshot (ObjectId object_id) = 0 virtual ~IProbeHandler () = default"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#typedef-propertymap","title":"typedef PropertyMap","text":"<pre><code>using quite::proto::IProbeHandler::PropertyMap =  entt::dense_map&lt;std::string, entt::meta_any&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-fetch_properties","title":"function fetch_properties","text":"<pre><code>virtual AsyncResult&lt; PropertyMap &gt; quite::proto::IProbeHandler::fetch_properties (\n    ObjectId object_id,\n    std::vector&lt; std::string &gt; properties\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-fetch_windows","title":"function fetch_windows","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; quite::proto::IProbeHandler::fetch_windows () = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; ObjectReference &gt; quite::proto::IProbeHandler::find_object (\n    ObjectQuery query\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::proto::IProbeHandler::invoke_method (\n    entt::meta_any object,\n    std::string qualified_method_signature,\n    std::vector&lt; entt::meta_any &gt; params\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-object_instance","title":"function object_instance","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::proto::IProbeHandler::object_instance (\n    ObjectId object_id\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-set_property","title":"function set_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::IProbeHandler::set_property (\n    ObjectId object_id,\n    std::string property,\n    entt::meta_any value\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; ImageData &gt; quite::proto::IProbeHandler::take_snapshot (\n    ObjectId object_id\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeHandler/#function-iprobehandler","title":"function ~IProbeHandler","text":"<pre><code>virtual quite::proto::IProbeHandler::~IProbeHandler () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/probe_handler.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/","title":"Struct quite::proto::IProbeHandler::ImageData","text":"<p>ClassList &gt; quite &gt; proto &gt; IProbeHandler &gt; ImageData</p>"},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/#public-attributes","title":"Public Attributes","text":"Type Name std::uint32_t height std::vector&lt; std::uint8_t &gt; image_data std::uint32_t width"},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/#variable-height","title":"variable height","text":"<pre><code>std::uint32_t quite::proto::IProbeHandler::ImageData::height;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/#variable-image_data","title":"variable image_data","text":"<pre><code>std::vector&lt;std::uint8_t&gt; quite::proto::IProbeHandler::ImageData::image_data;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1IProbeHandler_1_1ImageData/#variable-width","title":"variable width","text":"<pre><code>std::uint32_t quite::proto::IProbeHandler::ImageData::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/probe_handler.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/","title":"Class quite::proto::IProbeService","text":"<p>ClassList &gt; quite &gt; proto &gt; IProbeService</p> <p>Inherited by the following classes: quite::proto::ProbeServiceImpl</p>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#public-functions","title":"Public Functions","text":"Type Name virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery serach_query) = 0 virtual AsyncResult&lt; std::unordered_map&lt; std::string, entt::meta_any &gt; &gt; get_object_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) = 0 virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (ObjectId id, std::string method_name, std::vector&lt; entt::meta_any &gt; parameters) = 0 virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; query_top_level_views () = 0 virtual AsyncResult&lt; void &gt; set_object_property (ObjectId object_id, std::string property, entt::meta_any value) = 0 virtual AsyncResult&lt; Image &gt; take_snapshot (ObjectId id) = 0 virtual ~IProbeService () = default"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; ObjectReference &gt; quite::proto::IProbeService::find_object (\n    ObjectQuery serach_query\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-get_object_properties","title":"function get_object_properties","text":"<pre><code>virtual AsyncResult&lt; std::unordered_map&lt; std::string, entt::meta_any &gt; &gt; quite::proto::IProbeService::get_object_properties (\n    ObjectId object_id,\n    std::vector&lt; std::string &gt; properties\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::proto::IProbeService::invoke_method (\n    ObjectId id,\n    std::string method_name,\n    std::vector&lt; entt::meta_any &gt; parameters\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-query_top_level_views","title":"function query_top_level_views","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; quite::proto::IProbeService::query_top_level_views () = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-set_object_property","title":"function set_object_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::IProbeService::set_object_property (\n    ObjectId object_id,\n    std::string property,\n    entt::meta_any value\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; Image &gt; quite::proto::IProbeService::take_snapshot (\n    ObjectId id\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IProbeService/#function-iprobeservice","title":"function ~IProbeService","text":"<pre><code>virtual quite::proto::IProbeService::~IProbeService () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/probe_service.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1IValueConverter/","title":"Class quite::proto::IValueConverter","text":"<p>ClassList &gt; quite &gt; proto &gt; IValueConverter</p> <p>Inherited by the following classes: quite::client::GrpcValueConverter,  quite::proto::ProbeValueConverter</p>"},{"location":"quite/classquite_1_1proto_1_1IValueConverter/#public-functions","title":"Public Functions","text":"Type Name virtual entt::meta_any from (ObjectReference ref) const = 0 virtual ~IValueConverter () = default"},{"location":"quite/classquite_1_1proto_1_1IValueConverter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1IValueConverter/#function-from","title":"function from","text":"<pre><code>virtual entt::meta_any quite::proto::IValueConverter::from (\n    ObjectReference ref\n) const = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1IValueConverter/#function-ivalueconverter","title":"function ~IValueConverter","text":"<pre><code>virtual quite::proto::IValueConverter::~IValueConverter () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/value_converter.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/","title":"Struct quite::proto::InvokeMethodRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; InvokeMethodRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler ServiceHandle&lt; ValueRegistry &gt; value_registry"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (InvokeMethodRPC &amp; rpc, const InvokeMethodRPC::Request &amp; request) const"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::InvokeMethodRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#variable-value_registry","title":"variable value_registry","text":"<pre><code>ServiceHandle&lt;ValueRegistry&gt; quite::proto::InvokeMethodRpcHandler::value_registry;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1InvokeMethodRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::InvokeMethodRpcHandler::operator() (\n    InvokeMethodRPC &amp; rpc,\n    const InvokeMethodRPC::Request &amp; request\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_invoke_method.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/","title":"Class quite::proto::MetaRegistryImpl","text":"<p>ClassList &gt; quite &gt; proto &gt; MetaRegistryImpl</p> <p>Inherits the following classes: quite::meta::MetaRegistry</p>"},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/#public-functions","title":"Public Functions","text":"Type Name MetaRegistryImpl (std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context, MetaService::Stub &amp; meta_service_stub)  virtual AsyncResult&lt; meta::Type &gt; lookup_type (meta::TypeId type_id) override"},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/#public-functions-inherited-from-quitemetametaregistry","title":"Public Functions inherited from quite::meta::MetaRegistry","text":"<p>See quite::meta::MetaRegistry</p> Type Name virtual AsyncResult&lt; meta::Type &gt; lookup_type (meta::TypeId type_id) = 0 virtual ~MetaRegistry () = default"},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/#function-metaregistryimpl","title":"function MetaRegistryImpl","text":"<pre><code>explicit quite::proto::MetaRegistryImpl::MetaRegistryImpl (\n    std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context,\n    MetaService::Stub &amp; meta_service_stub\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1MetaRegistryImpl/#function-lookup_type","title":"function lookup_type","text":"<pre><code>virtual AsyncResult&lt; meta::Type &gt; quite::proto::MetaRegistryImpl::lookup_type (\n    meta::TypeId type_id\n) override\n</code></pre> <p>Implements quite::meta::MetaRegistry::lookup_type</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/meta_registry_impl.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/","title":"Struct quite::proto::MouseActionRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; MouseActionRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ServiceHandle&lt; core::IMouseInjector &gt; mouse_injector"},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (MouseActionRPC &amp; rpc, const MouseActionRPC::Request &amp; request) const"},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#variable-mouse_injector","title":"variable mouse_injector","text":"<pre><code>ServiceHandle&lt;core::IMouseInjector&gt; quite::proto::MouseActionRpcHandler::mouse_injector;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1MouseActionRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::MouseActionRpcHandler::operator() (\n    MouseActionRPC &amp; rpc,\n    const MouseActionRPC::Request &amp; request\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_mouse_injection.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/","title":"Class quite::proto::MouseInjectorImpl","text":"<p>ClassList &gt; quite &gt; proto &gt; MouseInjectorImpl</p> <p>Inherits the following classes: quite::core::IMouseInjector</p>"},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/#public-functions","title":"Public Functions","text":"Type Name MouseInjectorImpl (std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context, ProbeService::Stub &amp; probe_service_stub)  virtual AsyncResult&lt; void &gt; single_action (ObjectId target_id, core::MouseAction action) override"},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/#public-functions-inherited-from-quitecoreimouseinjector","title":"Public Functions inherited from quite::core::IMouseInjector","text":"<p>See quite::core::IMouseInjector</p> Type Name virtual AsyncResult&lt; void &gt; single_action (ObjectId target_id, MouseAction action) = 0 virtual ~IMouseInjector () = default"},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/#function-mouseinjectorimpl","title":"function MouseInjectorImpl","text":"<pre><code>explicit quite::proto::MouseInjectorImpl::MouseInjectorImpl (\n    std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context,\n    ProbeService::Stub &amp; probe_service_stub\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1MouseInjectorImpl/#function-single_action","title":"function single_action","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::MouseInjectorImpl::single_action (\n    ObjectId target_id,\n    core::MouseAction action\n) override\n</code></pre> <p>Implements quite::core::IMouseInjector::single_action</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/mouse_injector_impl.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/","title":"Class quite::proto::ProbeClient","text":"<p>ClassList &gt; quite &gt; proto &gt; ProbeClient</p> <p>Inherited by the following classes: quite::proto::ProbeClientImpl</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#public-functions","title":"Public Functions","text":"Type Name ProbeClient ()  QUITE_DISABLE_COPY_MOVE (ProbeClient)  virtual meta::MetaRegistry &amp; meta_registry () = 0 virtual core::IMouseInjector &amp; mouse_injector () = 0 virtual IProbeService &amp; probe_service () = 0 virtual AsyncResult&lt; void &gt; wait_for_connected (std::chrono::seconds timeout) = 0 virtual ~ProbeClient ()"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-probeclient","title":"function ProbeClient","text":"<pre><code>quite::proto::ProbeClient::ProbeClient () \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-quite_disable_copy_move","title":"function QUITE_DISABLE_COPY_MOVE","text":"<pre><code>quite::proto::ProbeClient::QUITE_DISABLE_COPY_MOVE (\n    ProbeClient\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-meta_registry","title":"function meta_registry","text":"<pre><code>virtual meta::MetaRegistry &amp; quite::proto::ProbeClient::meta_registry () = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-mouse_injector","title":"function mouse_injector","text":"<pre><code>virtual core::IMouseInjector &amp; quite::proto::ProbeClient::mouse_injector () = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-probe_service","title":"function probe_service","text":"<pre><code>virtual IProbeService &amp; quite::proto::ProbeClient::probe_service () = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-wait_for_connected","title":"function wait_for_connected","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::ProbeClient::wait_for_connected (\n    std::chrono::seconds timeout\n) = 0\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClient/#function-probeclient_1","title":"function ~ProbeClient","text":"<pre><code>virtual quite::proto::ProbeClient::~ProbeClient () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/probe_client.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/","title":"Class quite::proto::ProbeClientImpl","text":"<p>ClassList &gt; quite &gt; proto &gt; ProbeClientImpl</p> <p>Inherits the following classes: quite::proto::ProbeClient</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#public-functions","title":"Public Functions","text":"Type Name ProbeClientImpl (GrpcManager &amp; grpc_manager, std::string connection_url, std::shared_ptr&lt; IValueConverter &gt; value_converter)  virtual meta::MetaRegistry &amp; meta_registry () override virtual core::IMouseInjector &amp; mouse_injector () override virtual IProbeService &amp; probe_service () override virtual AsyncResult&lt; void &gt; wait_for_connected (std::chrono::seconds timeout) override"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#public-functions-inherited-from-quiteprotoprobeclient","title":"Public Functions inherited from quite::proto::ProbeClient","text":"<p>See quite::proto::ProbeClient</p> Type Name ProbeClient ()  QUITE_DISABLE_COPY_MOVE (ProbeClient)  virtual meta::MetaRegistry &amp; meta_registry () = 0 virtual core::IMouseInjector &amp; mouse_injector () = 0 virtual IProbeService &amp; probe_service () = 0 virtual AsyncResult&lt; void &gt; wait_for_connected (std::chrono::seconds timeout) = 0 virtual ~ProbeClient ()"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#function-probeclientimpl","title":"function ProbeClientImpl","text":"<pre><code>quite::proto::ProbeClientImpl::ProbeClientImpl (\n    GrpcManager &amp; grpc_manager,\n    std::string connection_url,\n    std::shared_ptr&lt; IValueConverter &gt; value_converter\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#function-meta_registry","title":"function meta_registry","text":"<pre><code>virtual meta::MetaRegistry &amp; quite::proto::ProbeClientImpl::meta_registry () override\n</code></pre> <p>Implements quite::proto::ProbeClient::meta_registry</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#function-mouse_injector","title":"function mouse_injector","text":"<pre><code>virtual core::IMouseInjector &amp; quite::proto::ProbeClientImpl::mouse_injector () override\n</code></pre> <p>Implements quite::proto::ProbeClient::mouse_injector</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#function-probe_service","title":"function probe_service","text":"<pre><code>virtual IProbeService &amp; quite::proto::ProbeClientImpl::probe_service () override\n</code></pre> <p>Implements quite::proto::ProbeClient::probe_service</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeClientImpl/#function-wait_for_connected","title":"function wait_for_connected","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::ProbeClientImpl::wait_for_connected (\n    std::chrono::seconds timeout\n) override\n</code></pre> <p>Implements quite::proto::ProbeClient::wait_for_connected</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_client_impl.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/","title":"Class quite::proto::ProbeServiceImpl","text":"<p>ClassList &gt; quite &gt; proto &gt; ProbeServiceImpl</p> <p>Inherits the following classes: quite::proto::IProbeService</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#public-functions","title":"Public Functions","text":"Type Name ProbeServiceImpl (std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context, ProbeService::Stub &amp; probe_service_stub, std::shared_ptr&lt; IValueConverter &gt; value_converter)  virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery serach_query) override virtual AsyncResult&lt; std::unordered_map&lt; std::string, entt::meta_any &gt; &gt; get_object_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) override virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (ObjectId id, std::string method_name, std::vector&lt; entt::meta_any &gt; parameters) override virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; query_top_level_views () override virtual AsyncResult&lt; void &gt; set_object_property (ObjectId object_id, std::string property, entt::meta_any value) override virtual AsyncResult&lt; Image &gt; take_snapshot (ObjectId id) override"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#public-functions-inherited-from-quiteprotoiprobeservice","title":"Public Functions inherited from quite::proto::IProbeService","text":"<p>See quite::proto::IProbeService</p> Type Name virtual AsyncResult&lt; ObjectReference &gt; find_object (ObjectQuery serach_query) = 0 virtual AsyncResult&lt; std::unordered_map&lt; std::string, entt::meta_any &gt; &gt; get_object_properties (ObjectId object_id, std::vector&lt; std::string &gt; properties) = 0 virtual AsyncResult&lt; entt::meta_any &gt; invoke_method (ObjectId id, std::string method_name, std::vector&lt; entt::meta_any &gt; parameters) = 0 virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; query_top_level_views () = 0 virtual AsyncResult&lt; void &gt; set_object_property (ObjectId object_id, std::string property, entt::meta_any value) = 0 virtual AsyncResult&lt; Image &gt; take_snapshot (ObjectId id) = 0 virtual ~IProbeService () = default"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-probeserviceimpl","title":"function ProbeServiceImpl","text":"<pre><code>explicit quite::proto::ProbeServiceImpl::ProbeServiceImpl (\n    std::shared_ptr&lt; agrpc::GrpcContext &gt; grpc_context,\n    ProbeService::Stub &amp; probe_service_stub,\n    std::shared_ptr&lt; IValueConverter &gt; value_converter\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-find_object","title":"function find_object","text":"<pre><code>virtual AsyncResult&lt; ObjectReference &gt; quite::proto::ProbeServiceImpl::find_object (\n    ObjectQuery serach_query\n) override\n</code></pre> <p>Implements quite::proto::IProbeService::find_object</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-get_object_properties","title":"function get_object_properties","text":"<pre><code>virtual AsyncResult&lt; std::unordered_map&lt; std::string, entt::meta_any &gt; &gt; quite::proto::ProbeServiceImpl::get_object_properties (\n    ObjectId object_id,\n    std::vector&lt; std::string &gt; properties\n) override\n</code></pre> <p>Implements quite::proto::IProbeService::get_object_properties</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-invoke_method","title":"function invoke_method","text":"<pre><code>virtual AsyncResult&lt; entt::meta_any &gt; quite::proto::ProbeServiceImpl::invoke_method (\n    ObjectId id,\n    std::string method_name,\n    std::vector&lt; entt::meta_any &gt; parameters\n) override\n</code></pre> <p>Implements quite::proto::IProbeService::invoke_method</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-query_top_level_views","title":"function query_top_level_views","text":"<pre><code>virtual AsyncResult&lt; std::vector&lt; ObjectReference &gt; &gt; quite::proto::ProbeServiceImpl::query_top_level_views () override\n</code></pre> <p>Implements quite::proto::IProbeService::query_top_level_views</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-set_object_property","title":"function set_object_property","text":"<pre><code>virtual AsyncResult&lt; void &gt; quite::proto::ProbeServiceImpl::set_object_property (\n    ObjectId object_id,\n    std::string property,\n    entt::meta_any value\n) override\n</code></pre> <p>Implements quite::proto::IProbeService::set_object_property</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeServiceImpl/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>virtual AsyncResult&lt; Image &gt; quite::proto::ProbeServiceImpl::take_snapshot (\n    ObjectId id\n) override\n</code></pre> <p>Implements quite::proto::IProbeService::take_snapshot</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_service_impl.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1ProbeValueConverter/","title":"Class quite::proto::ProbeValueConverter","text":"<p>ClassList &gt; quite &gt; proto &gt; ProbeValueConverter</p> <p>Inherits the following classes: quite::proto::IValueConverter</p>"},{"location":"quite/classquite_1_1proto_1_1ProbeValueConverter/#public-functions-inherited-from-quiteprotoivalueconverter","title":"Public Functions inherited from quite::proto::IValueConverter","text":"<p>See quite::proto::IValueConverter</p> Type Name virtual entt::meta_any from (ObjectReference ref) const = 0 virtual ~IValueConverter () = default <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/probe_value_converter.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/","title":"Struct quite::proto::ProtocolVisitor","text":"<p>ClassList &gt; quite &gt; proto &gt; ProtocolVisitor</p>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#public-attributes","title":"Public Attributes","text":"Type Name MetaType &amp; proto"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#public-functions","title":"Public Functions","text":"Type Name void operator() (const meta::PrimitiveType &amp; meta)  void operator() (const meta::ListType &amp; meta)  void operator() (const meta::MapType &amp; meta)  void operator() (const meta::EnumTypePtr &amp; meta)  void operator() (const meta::ObjectTypePtr &amp; meta)"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#variable-proto","title":"variable proto","text":"<pre><code>MetaType&amp; quite::proto::ProtocolVisitor::proto;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#function-operator-15","title":"function operator() [1/5]","text":"<pre><code>inline void quite::proto::ProtocolVisitor::operator() (\n    const meta::PrimitiveType &amp; meta\n) \n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#function-operator-25","title":"function operator() [2/5]","text":"<pre><code>inline void quite::proto::ProtocolVisitor::operator() (\n    const meta::ListType &amp; meta\n) \n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#function-operator-35","title":"function operator() [3/5]","text":"<pre><code>inline void quite::proto::ProtocolVisitor::operator() (\n    const meta::MapType &amp; meta\n) \n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#function-operator-45","title":"function operator() [4/5]","text":"<pre><code>inline void quite::proto::ProtocolVisitor::operator() (\n    const meta::EnumTypePtr &amp; meta\n) \n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1ProtocolVisitor/#function-operator-55","title":"function operator() [5/5]","text":"<pre><code>inline void quite::proto::ProtocolVisitor::operator() (\n    const meta::ObjectTypePtr &amp; meta\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/meta_converters.cpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1Server/","title":"Class quite::proto::Server","text":"<p>ClassList &gt; quite &gt; proto &gt; Server</p>"},{"location":"quite/classquite_1_1proto_1_1Server/#classes","title":"Classes","text":"Type Name class Impl"},{"location":"quite/classquite_1_1proto_1_1Server/#public-functions","title":"Public Functions","text":"Type Name QUITE_DISABLE_COPY (Server)  Server (std::string server_address, ServiceHandle&lt; IProbeHandler &gt; probe_handler, ServiceHandle&lt; core::IMouseInjector &gt; mouse_injector, ServiceHandle&lt; meta::MetaRegistry &gt; meta_registry, ServiceHandle&lt; ValueRegistry &gt; value_registry)  Server (Server &amp;&amp; server) noexcept Server &amp; operator= (Server &amp;&amp; server) noexcept ~Server ()"},{"location":"quite/classquite_1_1proto_1_1Server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1Server/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::proto::Server::QUITE_DISABLE_COPY (\n    Server\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Server/#function-server-12","title":"function Server [1/2]","text":"<pre><code>quite::proto::Server::Server (\n    std::string server_address,\n    ServiceHandle &lt; IProbeHandler &gt; probe_handler,\n    ServiceHandle &lt; core::IMouseInjector &gt; mouse_injector,\n    ServiceHandle &lt; meta::MetaRegistry &gt; meta_registry,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Server/#function-server-22","title":"function Server [2/2]","text":"<pre><code>quite::proto::Server::Server (\n    Server &amp;&amp; server\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Server/#function-operator","title":"function operator=","text":"<pre><code>Server &amp; quite::proto::Server::operator= (\n    Server &amp;&amp; server\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Server/#function-server","title":"function ~Server","text":"<pre><code>quite::proto::Server::~Server () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/server.hpp</code></p>"},{"location":"quite/classquite_1_1proto_1_1Server_1_1Impl/","title":"Class quite::proto::Server::Impl","text":"<p>ClassList &gt; quite &gt; proto &gt; Server &gt; Impl</p>"},{"location":"quite/classquite_1_1proto_1_1Server_1_1Impl/#public-functions","title":"Public Functions","text":"Type Name Impl (std::string server_address, ServiceHandle&lt; IProbeHandler &gt; probe_handler, ServiceHandle&lt; core::IMouseInjector &gt; mouse_injector, ServiceHandle&lt; meta::MetaRegistry &gt; meta_registry, ServiceHandle&lt; ValueRegistry &gt; value_registry)  ~Impl ()"},{"location":"quite/classquite_1_1proto_1_1Server_1_1Impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1proto_1_1Server_1_1Impl/#function-impl","title":"function Impl","text":"<pre><code>inline quite::proto::Server::Impl::Impl (\n    std::string server_address,\n    ServiceHandle &lt; IProbeHandler &gt; probe_handler,\n    ServiceHandle &lt; core::IMouseInjector &gt; mouse_injector,\n    ServiceHandle &lt; meta::MetaRegistry &gt; meta_registry,\n    ServiceHandle &lt; ValueRegistry &gt; value_registry\n) \n</code></pre>"},{"location":"quite/classquite_1_1proto_1_1Server_1_1Impl/#function-impl_1","title":"function ~Impl","text":"<pre><code>inline quite::proto::Server::Impl::~Impl () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/server.cpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/","title":"Struct quite::proto::SetObjectPropertyRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; SetObjectPropertyRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler ServiceHandle&lt; ValueRegistry &gt; value_registry"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (SetObjectPropertyRPC &amp; rpc, const SetObjectPropertyRPC::Request &amp; request)"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::SetObjectPropertyRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#variable-value_registry","title":"variable value_registry","text":"<pre><code>ServiceHandle&lt;ValueRegistry&gt; quite::proto::SetObjectPropertyRpcHandler::value_registry;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1SetObjectPropertyRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::SetObjectPropertyRpcHandler::operator() (\n    SetObjectPropertyRPC &amp; rpc,\n    const SetObjectPropertyRPC::Request &amp; request\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_set_object_property.hpp</code></p>"},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/","title":"Struct quite::proto::SnapshotRpcHandler","text":"<p>ClassList &gt; quite &gt; proto &gt; SnapshotRpcHandler</p>"},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#public-attributes","title":"Public Attributes","text":"Type Name ProbeHandlerHandle probe_handler"},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#public-functions","title":"Public Functions","text":"Type Name exec::task&lt; void &gt; operator() (RpcSnapshot &amp; rpc, const RpcSnapshot::Request &amp; request) const"},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#variable-probe_handler","title":"variable probe_handler","text":"<pre><code>ProbeHandlerHandle quite::proto::SnapshotRpcHandler::probe_handler;\n</code></pre>"},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1proto_1_1SnapshotRpcHandler/#function-operator","title":"function operator()","text":"<pre><code>exec::task&lt; void &gt; quite::proto::SnapshotRpcHandler::operator() (\n    RpcSnapshot &amp; rpc,\n    const RpcSnapshot::Request &amp; request\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_snapshot.hpp</code></p>"},{"location":"quite/namespacequite_1_1test/","title":"Namespace quite::test","text":"<p>Namespace List &gt; quite &gt; test</p>"},{"location":"quite/namespacequite_1_1test/#classes","title":"Classes","text":"Type Name struct IExpectBuilder class Probe class ProbeManager class Property class RemoteException class RemoteObject class RemoteObjectExpect"},{"location":"quite/namespacequite_1_1test/#public-functions","title":"Public Functions","text":"Type Name void create_screenshot_expect (RemoteObject obj, const std::string &amp; name)  QUITE_TEST_EXPORT std::unique_ptr&lt; IExpectBuilder &gt; expect (RemoteObject remote_object)  bool has_screenshot_expect (const std::string &amp; name)  constexpr void throw_unexpected (const Result&lt; T &gt; &amp; result)  bool verify_screenshot_expect (RemoteObject obj, const std::string &amp; name)"},{"location":"quite/namespacequite_1_1test/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite_1_1test/#function-create_screenshot_expect","title":"function create_screenshot_expect","text":"<pre><code>void quite::test::create_screenshot_expect (\n    RemoteObject obj,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1test/#function-expect","title":"function expect","text":"<pre><code>QUITE_TEST_EXPORT std::unique_ptr&lt; IExpectBuilder &gt; quite::test::expect (\n    RemoteObject remote_object\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1test/#function-has_screenshot_expect","title":"function has_screenshot_expect","text":"<pre><code>bool quite::test::has_screenshot_expect (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1test/#function-throw_unexpected","title":"function throw_unexpected","text":"<pre><code>template&lt;typename T&gt;\nconstexpr void quite::test::throw_unexpected (\n    const Result&lt; T &gt; &amp; result\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1test/#function-verify_screenshot_expect","title":"function verify_screenshot_expect","text":"<pre><code>bool quite::test::verify_screenshot_expect (\n    RemoteObject obj,\n    const std::string &amp; name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/exceptions.hpp</code></p>"},{"location":"quite/structquite_1_1test_1_1IExpectBuilder/","title":"Struct quite::test::IExpectBuilder","text":"<p>ClassList &gt; quite &gt; test &gt; IExpectBuilder</p> <p>Inherited by the following classes: quite::test::RemoteObjectExpect</p>"},{"location":"quite/structquite_1_1test_1_1IExpectBuilder/#public-functions","title":"Public Functions","text":"Type Name virtual bool to_have_screenshot (const std::string &amp; name) = 0 virtual ~IExpectBuilder () = default"},{"location":"quite/structquite_1_1test_1_1IExpectBuilder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1test_1_1IExpectBuilder/#function-to_have_screenshot","title":"function to_have_screenshot","text":"<pre><code>virtual bool quite::test::IExpectBuilder::to_have_screenshot (\n    const std::string &amp; name\n) = 0\n</code></pre>"},{"location":"quite/structquite_1_1test_1_1IExpectBuilder/#function-iexpectbuilder","title":"function ~IExpectBuilder","text":"<pre><code>virtual quite::test::IExpectBuilder::~IExpectBuilder () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/expect.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1Probe/","title":"Class quite::test::Probe","text":"<p>ClassList &gt; quite &gt; test &gt; Probe</p>"},{"location":"quite/classquite_1_1test_1_1Probe/#public-functions","title":"Public Functions","text":"Type Name Probe (Probe &amp;&amp;) noexcept QUITE_DISABLE_COPY (Probe)  void exit ()  RemoteObject find_object (ObjectQuery query)  Probe &amp; operator= (Probe &amp;&amp;) noexcept RemoteObject try_find_object (ObjectQuery query, std::chrono::milliseconds timeout)  void wait_for_connected (std::chrono::seconds timeout)  ~Probe ()"},{"location":"quite/classquite_1_1test_1_1Probe/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1Probe/#function-probe-12","title":"function Probe [1/2]","text":"<pre><code>quite::test::Probe::Probe (\n    Probe &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::test::Probe::QUITE_DISABLE_COPY (\n    Probe\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-exit","title":"function exit","text":"<pre><code>void quite::test::Probe::exit () \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-find_object","title":"function find_object","text":"<pre><code>RemoteObject quite::test::Probe::find_object (\n    ObjectQuery query\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-operator","title":"function operator=","text":"<pre><code>Probe &amp; quite::test::Probe::operator= (\n    Probe &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-try_find_object","title":"function try_find_object","text":"<pre><code>RemoteObject quite::test::Probe::try_find_object (\n    ObjectQuery query,\n    std::chrono::milliseconds timeout\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-wait_for_connected","title":"function wait_for_connected","text":"<pre><code>void quite::test::Probe::wait_for_connected (\n    std::chrono::seconds timeout\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Probe/#function-probe","title":"function ~Probe","text":"<pre><code>quite::test::Probe::~Probe () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/probe.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/","title":"Class quite::test::ProbeManager","text":"<p>ClassList &gt; quite &gt; test &gt; ProbeManager</p>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#public-functions","title":"Public Functions","text":"Type Name ProbeManager ()  ProbeManager (ProbeManager &amp;&amp;) noexcept QUITE_DISABLE_COPY (ProbeManager)  quite::test::Probe connect_to_probe (std::string name)  quite::test::Probe launch_probe_application (std::string name, const std::string &amp; path_to_application, const std::vector&lt; std::string &gt; &amp; args={})  ProbeManager &amp; operator= (ProbeManager &amp;&amp;) noexcept ~ProbeManager ()"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-probemanager-12","title":"function ProbeManager [1/2]","text":"<pre><code>quite::test::ProbeManager::ProbeManager () \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-probemanager-22","title":"function ProbeManager [2/2]","text":"<pre><code>quite::test::ProbeManager::ProbeManager (\n    ProbeManager &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-quite_disable_copy","title":"function QUITE_DISABLE_COPY","text":"<pre><code>quite::test::ProbeManager::QUITE_DISABLE_COPY (\n    ProbeManager\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-connect_to_probe","title":"function connect_to_probe","text":"<pre><code>quite::test::Probe quite::test::ProbeManager::connect_to_probe (\n    std::string name\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-launch_probe_application","title":"function launch_probe_application","text":"<pre><code>quite::test::Probe quite::test::ProbeManager::launch_probe_application (\n    std::string name,\n    const std::string &amp; path_to_application,\n    const std::vector&lt; std::string &gt; &amp; args={}\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-operator","title":"function operator=","text":"<pre><code>ProbeManager &amp; quite::test::ProbeManager::operator= (\n    ProbeManager &amp;&amp;\n) noexcept\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1ProbeManager/#function-probemanager","title":"function ~ProbeManager","text":"<pre><code>quite::test::ProbeManager::~ProbeManager () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/probe_manager.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1Property/","title":"Class quite::test::Property","text":"<p>ClassList &gt; quite &gt; test &gt; Property</p>"},{"location":"quite/classquite_1_1test_1_1Property/#public-types","title":"Public Types","text":"Type Name typedef std::variant&lt; bool, std::uint64_t, std::int64_t, double, std::string, RemoteObject &gt; Value"},{"location":"quite/classquite_1_1test_1_1Property/#public-functions","title":"Public Functions","text":"Type Name Property (std::shared_ptr&lt; client::Property &gt; property)  Property::Value fetch ()  Property::Value value () const Property::Value wait_for_value (Property::Value target_value, std::chrono::milliseconds timeout) Waits until the given target value has been reached or the time has been passed. Returns either the target value or the last fetched value after a timeout. void write (Property::Value value)"},{"location":"quite/classquite_1_1test_1_1Property/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/classquite_1_1test_1_1Property/#typedef-value","title":"typedef Value","text":"<pre><code>using quite::test::Property::Value =  std::variant&lt;bool, std::uint64_t, std::int64_t, double, std::string, RemoteObject&gt;;\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Property/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1Property/#function-property","title":"function Property","text":"<pre><code>explicit quite::test::Property::Property (\n    std::shared_ptr&lt; client::Property &gt; property\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Property/#function-fetch","title":"function fetch","text":"<pre><code>Property::Value quite::test::Property::fetch () \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Property/#function-value","title":"function value","text":"<pre><code>Property::Value quite::test::Property::value () const\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1Property/#function-wait_for_value","title":"function wait_for_value","text":"<p>Waits until the given target value has been reached or the time has been passed. Returns either the target value or the last fetched value after a timeout. </p> <pre><code>Property::Value quite::test::Property::wait_for_value (\n    Property::Value target_value,\n    std::chrono::milliseconds timeout\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>target_value</code> the desired value </li> <li><code>timeout</code> max time to wait </li> </ul> <p>Returns:</p> <p>Property::Value either the target value or the last fetched value after a timeout </p>"},{"location":"quite/classquite_1_1test_1_1Property/#function-write","title":"function write","text":"<pre><code>void quite::test::Property::write (\n    Property::Value value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/property.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1RemoteException/","title":"Class quite::test::RemoteException","text":"<p>ClassList &gt; quite &gt; test &gt; RemoteException</p> <p>Inherits the following classes: std::runtime_error</p>"},{"location":"quite/classquite_1_1test_1_1RemoteException/#public-functions","title":"Public Functions","text":"Type Name RemoteException (const Error &amp; error)"},{"location":"quite/classquite_1_1test_1_1RemoteException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1RemoteException/#function-remoteexception","title":"function RemoteException","text":"<pre><code>explicit quite::test::RemoteException::RemoteException (\n    const Error &amp; error\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/exceptions.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/","title":"Class quite::test::RemoteObject","text":"<p>ClassList &gt; quite &gt; test &gt; RemoteObject</p>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#public-functions","title":"Public Functions","text":"Type Name RemoteObject (std::shared_ptr&lt; client::RemoteObject &gt; object)  void invoke_method (std::string method_name)  void mouse_action ()  bool operator== (const RemoteObject &amp; rhs) const Property property (std::string name)  Image take_snapshot ()  std::shared_ptr&lt; client::RemoteObject &gt; underlying_object ()"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-remoteobject","title":"function RemoteObject","text":"<pre><code>explicit quite::test::RemoteObject::RemoteObject (\n    std::shared_ptr&lt; client::RemoteObject &gt; object\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-invoke_method","title":"function invoke_method","text":"<pre><code>void quite::test::RemoteObject::invoke_method (\n    std::string method_name\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-mouse_action","title":"function mouse_action","text":"<pre><code>void quite::test::RemoteObject::mouse_action () \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-operator","title":"function operator==","text":"<pre><code>bool quite::test::RemoteObject::operator== (\n    const RemoteObject &amp; rhs\n) const\n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-property","title":"function property","text":"<pre><code>Property quite::test::RemoteObject::property (\n    std::string name\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-take_snapshot","title":"function take_snapshot","text":"<pre><code>Image quite::test::RemoteObject::take_snapshot () \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObject/#function-underlying_object","title":"function underlying_object","text":"<pre><code>std::shared_ptr&lt; client::RemoteObject &gt; quite::test::RemoteObject::underlying_object () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/remote_object.hpp</code></p>"},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/","title":"Class quite::test::RemoteObjectExpect","text":"<p>ClassList &gt; quite &gt; test &gt; RemoteObjectExpect</p> <p>Inherits the following classes: quite::test::IExpectBuilder</p>"},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/#public-functions","title":"Public Functions","text":"Type Name RemoteObjectExpect (RemoteObject remote_object)  virtual bool to_have_screenshot (const std::string &amp; name) override"},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/#public-functions-inherited-from-quitetestiexpectbuilder","title":"Public Functions inherited from quite::test::IExpectBuilder","text":"<p>See quite::test::IExpectBuilder</p> Type Name virtual bool to_have_screenshot (const std::string &amp; name) = 0 virtual ~IExpectBuilder () = default"},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/#function-remoteobjectexpect","title":"function RemoteObjectExpect","text":"<pre><code>inline quite::test::RemoteObjectExpect::RemoteObjectExpect (\n    RemoteObject remote_object\n) \n</code></pre>"},{"location":"quite/classquite_1_1test_1_1RemoteObjectExpect/#function-to_have_screenshot","title":"function to_have_screenshot","text":"<pre><code>inline virtual bool quite::test::RemoteObjectExpect::to_have_screenshot (\n    const std::string &amp; name\n) override\n</code></pre> <p>Implements quite::test::IExpectBuilder::to_have_screenshot</p> <p>The documentation for this class was generated from the following file <code>libs/testing/src/expect.cpp</code></p>"},{"location":"quite/namespacequite_1_1testing/","title":"Namespace quite::testing","text":"<p>Namespace List &gt; quite &gt; testing</p>"},{"location":"quite/namespacequite_1_1testing/#public-functions","title":"Public Functions","text":"Type Name QUITE_CLIENT_EXPORT AsyncResult&lt; void &gt; create_verification_point (client::RemoteObjectPtr object, const std::string &amp; name)  QUITE_CLIENT_EXPORT bool has_verification_point (const std::string &amp; name)  QUITE_CLIENT_EXPORT AsyncResult&lt; bool &gt; verify_verification_point (client::RemoteObjectPtr object, const std::string &amp; name)"},{"location":"quite/namespacequite_1_1testing/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/namespacequite_1_1testing/#function-create_verification_point","title":"function create_verification_point","text":"<pre><code>QUITE_CLIENT_EXPORT AsyncResult&lt; void &gt; quite::testing::create_verification_point (\n    client::RemoteObjectPtr object,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1testing/#function-has_verification_point","title":"function has_verification_point","text":"<pre><code>QUITE_CLIENT_EXPORT bool quite::testing::has_verification_point (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"quite/namespacequite_1_1testing/#function-verify_verification_point","title":"function verify_verification_point","text":"<pre><code>QUITE_CLIENT_EXPORT AsyncResult&lt; bool &gt; quite::testing::verify_verification_point (\n    client::RemoteObjectPtr object,\n    const std::string &amp; name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/testing/verification_point.hpp</code></p>"},{"location":"quite/namespacequite_1_1_0d52/","title":"Namespace quite","text":"<p>Namespace List &gt; quite</p> <p>The documentation for this class was generated from the following file <code>libs/core/src/image_utils.cpp</code></p>"},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/","title":"Struct quite::QObjectOperationState::StopCallback","text":"<p>ClassList &gt; StopCallback</p>"},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#public-attributes","title":"Public Attributes","text":"Type Name QObjectOperationState * self"},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#public-functions","title":"Public Functions","text":"Type Name void operator() () noexcept const"},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#variable-self","title":"variable self","text":"<pre><code>QObjectOperationState* quite::QObjectOperationState&lt; Recv, QObj, Ret, Args &gt;::StopCallback::self;\n</code></pre>"},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1QObjectOperationState_1_1StopCallback/#function-operator","title":"function operator()","text":"<pre><code>inline void StopCallback::operator() () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/","title":"Struct quite::QObjectSender::DefaultEnv","text":"<p>ClassList &gt; DefaultEnv</p>"},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#public-attributes","title":"Public Attributes","text":"Type Name QThread * thread"},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#public-functions","title":"Public Functions","text":"Type Name auto query (stdexec::get_completion_scheduler_t&lt; CPO &gt;) noexcept const"},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#variable-thread","title":"variable thread","text":"<pre><code>QThread* quite::QObjectSender&lt; QObj, Ret, Args &gt;::DefaultEnv::thread;\n</code></pre>"},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/structquite_1_1QObjectSender_1_1DefaultEnv/#function-query","title":"function query","text":"<pre><code>template&lt;typename CPO&gt;\ninline auto DefaultEnv::query (\n    stdexec::get_completion_scheduler_t&lt; CPO &gt;\n) noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/namespacequite_1_1client_1_1_0d26/","title":"Namespace quite::client","text":"<p>Namespace List &gt; client</p> <p>The documentation for this class was generated from the following file <code>libs/client/src/utils/dump_properties.cpp</code></p>"},{"location":"quite/namespacequite_1_1probe_1_1_0d112/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; probe</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/value_converters.cpp</code></p>"},{"location":"quite/namespacequite_1_1probe_1_1_0d89/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; probe</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/method_invoker.cpp</code></p>"},{"location":"quite/namespacequite_1_1probe_1_1_0d91/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; probe</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/object_tracker.cpp</code></p>"},{"location":"quite/namespacequite_1_1probe_1_1_0d93/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; probe</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/probe_context.cpp</code></p>"},{"location":"quite/namespacequite_1_1probe_1_1_0d97/","title":"Namespace quite::probe","text":"<p>Namespace List &gt; probe</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_registry.cpp</code></p>"},{"location":"quite/namespacequite_1_1proto_1_1_0d132/","title":"Namespace quite::proto","text":"<p>Namespace List &gt; proto</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_service_impl.cpp</code></p>"},{"location":"quite/namespacequite_1_1proto_1_1_0d136/","title":"Namespace quite::proto","text":"<p>Namespace List &gt; proto</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/meta_converters.cpp</code></p>"},{"location":"quite/namespacequite_1_1proto_1_1_0d142/","title":"Namespace quite::proto","text":"<p>Namespace List &gt; proto</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_find_object.cpp</code></p>"},{"location":"quite/namespacequite_1_1proto_1_1_0d157/","title":"Namespace quite::proto","text":"<p>Namespace List &gt; proto</p> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/value.cpp</code></p>"},{"location":"quite/namespacequite_1_1test_1_1_0d173/","title":"Namespace quite::test","text":"<p>Namespace List &gt; test</p> <p>The documentation for this class was generated from the following file <code>libs/testing/src/property.cpp</code></p>"},{"location":"quite/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"quite/namespacestd_1_1literals_1_1string__view__literals/","title":"Namespace std::literals::string_view_literals","text":"<p>Namespace List &gt; string_view_literals</p> <p>The documentation for this class was generated from the following file <code>libs/core/test/test_error.cpp</code></p>"},{"location":"quite/dir_6719ab1f1f7655efc2fa43f7eb574fd1/","title":"Dir libs","text":"<p>FileList &gt; libs</p>"},{"location":"quite/dir_6719ab1f1f7655efc2fa43f7eb574fd1/#directories","title":"Directories","text":"Type Name dir client dir core dir manager dir probe dir probeqt dir protocol dir testing <p>The documentation for this class was generated from the following file <code>libs/</code></p>"},{"location":"quite/dir_66fcfc6cbdc0959ca004c79e577b2983/","title":"Dir libs/client","text":"<p>FileList &gt; client</p>"},{"location":"quite/dir_66fcfc6cbdc0959ca004c79e577b2983/#directories","title":"Directories","text":"Type Name dir include dir src dir test <p>The documentation for this class was generated from the following file <code>libs/client/</code></p>"},{"location":"quite/dir_69eac062172cc3dd38536daddef8f6c7/","title":"Dir libs/client/include","text":"<p>FileList &gt; client &gt; include</p>"},{"location":"quite/dir_69eac062172cc3dd38536daddef8f6c7/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/client/include/</code></p>"},{"location":"quite/dir_4b2f86ac1ca33b50681e1a9febdc0774/","title":"Dir libs/client/include/quite","text":"<p>FileList &gt; client &gt; include &gt; quite</p>"},{"location":"quite/dir_4b2f86ac1ca33b50681e1a9febdc0774/#directories","title":"Directories","text":"Type Name dir client <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/</code></p>"},{"location":"quite/dir_7d6276c65eb2c4014d2f0c2cacdec3f0/","title":"Dir libs/client/include/quite/client","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client</p>"},{"location":"quite/dir_7d6276c65eb2c4014d2f0c2cacdec3f0/#files","title":"Files","text":"Type Name file probe.hpp file probe_handle.hpp file probe_manager.hpp file property.hpp file quite.hpp file remote_object.hpp"},{"location":"quite/dir_7d6276c65eb2c4014d2f0c2cacdec3f0/#directories","title":"Directories","text":"Type Name dir testing dir utils <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/</code></p>"},{"location":"quite/dir_c6e9347de3fb4db939a0e8cd4d8d8ee5/","title":"Dir libs/client/include/quite/client/testing","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; testing</p>"},{"location":"quite/dir_c6e9347de3fb4db939a0e8cd4d8d8ee5/#files","title":"Files","text":"Type Name file verification_point.hpp <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/testing/</code></p>"},{"location":"quite/verification__point_8hpp/","title":"File verification_point.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; testing &gt; verification_point.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/async_result.hpp\"</code></li> <li><code>#include \"quite/client/remote_object.hpp\"</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/verification__point_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace testing <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/testing/verification_point.hpp</code></p>"},{"location":"quite/verification__point_8hpp_source/","title":"File verification_point.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; testing &gt; verification_point.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"quite/async_result.hpp\"\n#include \"quite/client/remote_object.hpp\"\n#include \"quite/quite_client_export.hpp\"\n\nnamespace quite::testing\n{\n\n[[nodiscard]] QUITE_CLIENT_EXPORT bool has_verification_point(const std::string &amp;name);\nQUITE_CLIENT_EXPORT AsyncResult&lt;void&gt; create_verification_point(client::RemoteObjectPtr object,\n                                                                const std::string &amp;name);\nQUITE_CLIENT_EXPORT AsyncResult&lt;bool&gt; verify_verification_point(client::RemoteObjectPtr object,\n                                                                const std::string &amp;name);\n\n} // namespace quite::testing\n</code></pre>"},{"location":"quite/dir_40c584c53b41f36667c6f7a7f0c7366b/","title":"Dir libs/client/include/quite/client/utils","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; utils</p>"},{"location":"quite/dir_40c584c53b41f36667c6f7a7f0c7366b/#files","title":"Files","text":"Type Name file dump_properties.hpp <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/utils/</code></p>"},{"location":"quite/dump__properties_8hpp/","title":"File dump_properties.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; utils &gt; dump_properties.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;nlohmann/json_fwd.hpp&gt;</code></li> <li><code>#include \"quite/client/remote_object.hpp\"</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/dump__properties_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/utils/dump_properties.hpp</code></p>"},{"location":"quite/dump__properties_8hpp_source/","title":"File dump_properties.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; utils &gt; dump_properties.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;nlohmann/json_fwd.hpp&gt;\n#include \"quite/client/remote_object.hpp\"\n#include \"quite/quite_client_export.hpp\"\nnamespace quite::client\n{\nAsyncResult&lt;nlohmann::json&gt; QUITE_CLIENT_EXPORT dump_properties(RemoteObjectPtr remote_object,\n                                                                std::vector&lt;std::string&gt; properties);\n}\n</code></pre>"},{"location":"quite/client_2include_2quite_2client_2probe_8hpp/","title":"File probe.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; probe.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> <li><code>#include \"remote_object.hpp\"</code></li> </ul>"},{"location":"quite/client_2include_2quite_2client_2probe_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/client_2include_2quite_2client_2probe_8hpp/#classes","title":"Classes","text":"Type Name class Probe <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe.hpp</code></p>"},{"location":"quite/client_2include_2quite_2client_2probe_8hpp_source/","title":"File probe.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; probe.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/error.hpp&gt;\n#include &lt;quite/meta/meta_registry.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"quite/quite_client_export.hpp\"\n#include \"remote_object.hpp\"\nnamespace quite::client\n{\nclass QUITE_CLIENT_EXPORT Probe\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(Probe);\n    Probe() = default;\n    virtual ~Probe() = default;\n    virtual AsyncResult&lt;RemoteObjectPtr&gt; find_object(ObjectQuery query) = 0;\n    virtual AsyncResult&lt;std::vector&lt;RemoteObjectPtr&gt;&gt; get_views() = 0;\n    virtual AsyncResult&lt;void&gt; wait_for_started(std::chrono::seconds timeout) = 0;\n    virtual AsyncResult&lt;void&gt; exit() = 0;\n    virtual meta::MetaRegistry &amp;meta_registry() = 0;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/probe__handle_8hpp/","title":"File probe_handle.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; probe_handle.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/probe__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/probe__handle_8hpp/#classes","title":"Classes","text":"Type Name class ProbeHandle <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe_handle.hpp</code></p>"},{"location":"quite/probe__handle_8hpp_source/","title":"File probe_handle.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; probe_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include \"quite/quite_client_export.hpp\"\nnamespace quite::client\n{\nclass Probe;\nclass QUITE_CLIENT_EXPORT ProbeHandle\n{\n  public:\n    explicit ProbeHandle(std::shared_ptr&lt;Probe&gt; probe);\n    Probe *operator-&gt;();\n\n  private:\n    std::shared_ptr&lt;Probe&gt; probe_;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2include_2quite_2client_2probe__manager_8hpp/","title":"File probe_manager.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; probe_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/manager/process_manager.hpp&gt;</code></li> <li><code>#include \"probe_handle.hpp\"</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/client_2include_2quite_2client_2probe__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/client_2include_2quite_2client_2probe__manager_8hpp/#classes","title":"Classes","text":"Type Name class ProbeManager <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/probe_manager.hpp</code></p>"},{"location":"quite/client_2include_2quite_2client_2probe__manager_8hpp_source/","title":"File probe_manager.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; probe_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/manager/process_manager.hpp&gt;\n#include \"probe_handle.hpp\"\n#include \"quite/quite_client_export.hpp\"\n\nnamespace quite::client\n{\nclass QUITE_CLIENT_EXPORT ProbeManager\n{\n  public:\n    QUITE_DISABLE_COPY(ProbeManager);\n    ProbeManager();\n    ~ProbeManager();\n    ProbeManager(ProbeManager &amp;&amp;) noexcept = default;\n    ProbeManager &amp;operator=(ProbeManager &amp;&amp;) noexcept = default;\n\n    ProbeHandle connect(manager::ProcessHandle handle, const std::string &amp;connection_url);\n\n  private:\n    struct Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2include_2quite_2client_2property_8hpp/","title":"File property.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_type_id.hpp&gt;</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/client_2include_2quite_2client_2property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/client_2include_2quite_2client_2property_8hpp/#classes","title":"Classes","text":"Type Name class Property <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/property.hpp</code></p>"},{"location":"quite/client_2include_2quite_2client_2property_8hpp_source/","title":"File property.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;fmt/core.h&gt;\n#include &lt;quite/async_result.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/meta/meta_type_id.hpp&gt;\n#include \"quite/quite_client_export.hpp\"\n\nnamespace quite::client\n{\nclass QUITE_CLIENT_EXPORT Property\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(Property);\n    Property() = default;\n    virtual ~Property();\n    virtual const std::string &amp;name() const = 0;\n    virtual meta::TypeId type_id() const = 0;\n    virtual const Result&lt;entt::meta_any&gt; &amp;value() const = 0;\n    virtual AsyncResult&lt;entt::meta_any&gt; read() = 0;\n    virtual AsyncResult&lt;void&gt; write(entt::meta_any value) = 0;\n};\n\nusing PropertyPtr = std::shared_ptr&lt;Property&gt;;\n} // namespace quite::client\n</code></pre>"},{"location":"quite/quite_8hpp/","title":"File quite.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; quite.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/any_io_executor.hpp&gt;</code></li> <li><code>#include &lt;execpools/asio/asio_thread_pool.hpp&gt;</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/quite_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/quite.hpp</code></p>"},{"location":"quite/quite_8hpp_source/","title":"File quite.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; quite.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;boost/asio/any_io_executor.hpp&gt;\n#include &lt;execpools/asio/asio_thread_pool.hpp&gt;\n#include \"quite/quite_client_export.hpp\"\n\nnamespace quite::client\n{\nQUITE_CLIENT_EXPORT execpools::asio_thread_pool &amp;asio_context();\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2include_2quite_2client_2remote__object_8hpp/","title":"File remote_object.hpp","text":"<p>FileList &gt; client &gt; include &gt; quite &gt; client &gt; remote_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include \"property.hpp\"</code></li> <li><code>#include \"quite/image.hpp\"</code></li> <li><code>#include \"quite/quite_client_export.hpp\"</code></li> </ul>"},{"location":"quite/client_2include_2quite_2client_2remote__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/client_2include_2quite_2client_2remote__object_8hpp/#classes","title":"Classes","text":"Type Name class RemoteObject <p>The documentation for this class was generated from the following file <code>libs/client/include/quite/client/remote_object.hpp</code></p>"},{"location":"quite/client_2include_2quite_2client_2remote__object_8hpp_source/","title":"File remote_object.hpp","text":"<p>File List &gt; client &gt; include &gt; quite &gt; client &gt; remote_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/async_result.hpp&gt;\n#include \"property.hpp\"\n#include \"quite/image.hpp\"\n#include \"quite/quite_client_export.hpp\"\nnamespace quite::client\n{\n\nusing ObjectId = std::uint64_t;\n\nclass QUITE_CLIENT_EXPORT RemoteObject\n{\n  public:\n    explicit RemoteObject(ObjectId id);\n    virtual ~RemoteObject();\n\n    ObjectId id() const noexcept;\n\n    virtual meta::TypeId type_id() const = 0;\n\n    virtual AsyncResult&lt;std::unordered_map&lt;std::string, PropertyPtr&gt;&gt; fetch_properties(\n        std::vector&lt;std::string&gt; properties) = 0;\n\n    virtual AsyncResult&lt;PropertyPtr&gt; property(std::string property_name) = 0;\n\n    virtual AsyncResult&lt;void&gt; write_property(std::string property_name, entt::meta_any value) = 0;\n\n    virtual AsyncResult&lt;void&gt; mouse_action() = 0;\n\n    virtual AsyncResult&lt;Image&gt; take_snapshot() = 0;\n\n    virtual AsyncResult&lt;void&gt; invoke_method(std::string method_name) = 0;\n\n  private:\n    const ObjectId id_;\n};\nusing RemoteObjectPtr = std::shared_ptr&lt;RemoteObject&gt;;\n} // namespace quite::client\n</code></pre>"},{"location":"quite/dir_e2c39676c5a8632601778e1e1ba34ff3/","title":"Dir libs/client/src","text":"<p>FileList &gt; client &gt; src</p>"},{"location":"quite/dir_e2c39676c5a8632601778e1e1ba34ff3/#files","title":"Files","text":"Type Name file basic_probe.cpp file basic_probe.hpp file context.cpp file context.hpp file probe_handle.cpp file probe_manager.cpp file property.cpp file quite.cpp file remote_object.cpp"},{"location":"quite/dir_e2c39676c5a8632601778e1e1ba34ff3/#directories","title":"Directories","text":"Type Name dir grpc_impl dir testing dir utils <p>The documentation for this class was generated from the following file <code>libs/client/src/</code></p>"},{"location":"quite/basic__probe_8cpp/","title":"File basic_probe.cpp","text":"<p>FileList &gt; client &gt; src &gt; basic_probe.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"basic_probe.hpp\"</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;asioexec/use_sender.hpp&gt;</code></li> <li><code>#include &lt;exec/when_any.hpp&gt;</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/manager/process.hpp&gt;</code></li> </ul>"},{"location":"quite/basic__probe_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/basic_probe.cpp</code></p>"},{"location":"quite/basic__probe_8cpp_source/","title":"File basic_probe.cpp","text":"<p>File List &gt; client &gt; src &gt; basic_probe.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"basic_probe.hpp\"\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;asioexec/use_sender.hpp&gt;\n#include &lt;exec/when_any.hpp&gt;\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/manager/process.hpp&gt;\n\nDEFINE_LOGGER(basic_probe)\nnamespace quite::client\n{\nBasicProbe::BasicProbe(manager::ProcessHandle process)\n    : process_{std::move(process)}\n{}\n\nAsyncResult&lt;void&gt; BasicProbe::exit()\n{\n    if (not process_.instance().is_running())\n    {\n        co_return {};\n    }\n    LOG_DEBUG(basic_probe(), \"Process still running. Trying to gracefully stop it.\");\n    boost::asio::steady_timer timer{get_executor(), std::chrono::seconds(3)};\n    boost::system::error_code ec;\n    std::ignore = process_.instance().request_exit();\n\n    auto exit_result = co_await (\n        exec::when_any(process_.instance().async_wait_exit(),\n                       timer.async_wait(asioexec::use_sender) | stdexec::then([this](auto &amp;&amp;...) -&gt; Result&lt;int&gt; {\n                           LOG_WARNING(basic_probe(),\n                                       \"Could not stop process gracefully. Going to terminate the process.\");\n                           return process_.instance().terminate().transform([]() -&gt; int { return EXIT_FAILURE; });\n                       })) |\n        stdexec::upon_error([]([[maybe_unused]] std::exception_ptr &amp;&amp;ec) -&gt; Result&lt;int&gt; {\n            LOG_ERROR(basic_probe(), \"Could not wait for timer.\");\n            return EXIT_FAILURE;\n        }));\n\n    if (exit_result.has_value())\n    {\n        LOG_INFO(basic_probe(), \"Process stopped successfully with exit code {}\", exit_result.value());\n    }\n    else\n    {\n        LOG_ERROR(basic_probe(), \"Could not wait for process. Error: {}\", fmt::format(\"{}\", exit_result.error()));\n    }\n    co_return exit_result.transform([](int /* exit_code */) {});\n}\n\nmanager::Process &amp;BasicProbe::process()\n{\n    return process_.instance();\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/basic__probe_8hpp/","title":"File basic_probe.hpp","text":"<p>FileList &gt; client &gt; src &gt; basic_probe.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/manager/process_handle.hpp&gt;</code></li> <li><code>#include \"quite/client/probe.hpp\"</code></li> </ul>"},{"location":"quite/basic__probe_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/basic__probe_8hpp/#classes","title":"Classes","text":"Type Name class BasicProbe <p>The documentation for this class was generated from the following file <code>libs/client/src/basic_probe.hpp</code></p>"},{"location":"quite/basic__probe_8hpp_source/","title":"File basic_probe.hpp","text":"<p>File List &gt; client &gt; src &gt; basic_probe.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/manager/process_handle.hpp&gt;\n#include \"quite/client/probe.hpp\"\nnamespace quite::client\n{\nclass BasicProbe : public Probe\n{\n  public:\n    explicit BasicProbe(manager::ProcessHandle process);\n    manager::Process &amp;process();\n\n    AsyncResult&lt;void&gt; exit() override;\n\n  private:\n    manager::ProcessHandle process_;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/context_8cpp/","title":"File context.cpp","text":"<p>FileList &gt; client &gt; src &gt; context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"context.hpp\"</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> </ul>"},{"location":"quite/context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/client/src/context.cpp</code></p>"},{"location":"quite/context_8cpp_source/","title":"File context.cpp","text":"<p>File List &gt; client &gt; src &gt; context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"context.hpp\"\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n\nnamespace quite\n{\n\nContext::Context()\n{\n    entt::locator&lt;ValueRegistry&gt;::emplace();\n    client_ = std::make_unique&lt;proto::Client&gt;(entt::locator&lt;ValueRegistry&gt;::handle());\n}\n\nContext::~Context()\n{\n    get_executor().context().stop();\n}\n\nproto::Client &amp;Context::backend_client()\n{\n    return *client_;\n}\n\nexecpools::asio_thread_pool &amp;Context::asio_context()\n{\n    return thread_pool();\n}\n\nContext &amp;Context::Instance()\n{\n    static Context context;\n    return context;\n}\n} // namespace quite\n</code></pre>"},{"location":"quite/context_8hpp/","title":"File context.hpp","text":"<p>FileList &gt; client &gt; src &gt; context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio/io_context.hpp&gt;</code></li> <li><code>#include &lt;execpools/asio/asio_thread_pool.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/client/client.hpp&gt;</code></li> </ul>"},{"location":"quite/context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/context_8hpp/#classes","title":"Classes","text":"Type Name class Context <p>The documentation for this class was generated from the following file <code>libs/client/src/context.hpp</code></p>"},{"location":"quite/context_8hpp_source/","title":"File context.hpp","text":"<p>File List &gt; client &gt; src &gt; context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;execpools/asio/asio_thread_pool.hpp&gt;\n#include &lt;quite/proto/client/client.hpp&gt;\n\nnamespace quite\n{\nclass Context final\n{\n  public:\n    ~Context();\n    execpools::asio_thread_pool &amp;asio_context();\n    proto::Client &amp;backend_client();\n\n  public:\n    static Context &amp;Instance();\n\n  private:\n    Context();\n\n  private:\n    std::unique_ptr&lt;proto::Client&gt; client_;\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_61027e8bdb8101310df75c312f0d65c4/","title":"Dir libs/client/src/grpc_impl","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl</p>"},{"location":"quite/dir_61027e8bdb8101310df75c312f0d65c4/#files","title":"Files","text":"Type Name file grpc_probe.cpp file grpc_probe.hpp file grpc_property.cpp file grpc_property.hpp file grpc_remote_object.cpp file grpc_remote_object.hpp file grpc_value.cpp file grpc_value.hpp <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/</code></p>"},{"location":"quite/grpc__probe_8cpp/","title":"File grpc_probe.cpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_probe.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grpc_probe.hpp\"</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;exec/repeat_effect_until.hpp&gt;</code></li> <li><code>#include &lt;exec/when_any.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"grpc_remote_object.hpp\"</code></li> <li><code>#include &lt;fmt/base.h&gt;</code></li> </ul>"},{"location":"quite/grpc__probe_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_probe.cpp</code></p>"},{"location":"quite/grpc__probe_8cpp_source/","title":"File grpc_probe.cpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_probe.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grpc_probe.hpp\"\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;exec/repeat_effect_until.hpp&gt;\n#include &lt;exec/when_any.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"grpc_remote_object.hpp\"\n\n#include &lt;fmt/base.h&gt;\n\nDEFINE_LOGGER(grpc_app_logger)\n\nnamespace quite::client\n{\nGrpcProbe::GrpcProbe(manager::ProcessHandle process, proto::Client &amp;client, std::string connection_uri)\n    : BasicProbe{std::move(process)}\n    , client_{client.create_probe_client(value_converter_, std::move(connection_uri))}\n{\n    value_converter_-&gt;set_client(client_);\n}\n\nAsyncResult&lt;void&gt; GrpcProbe::wait_for_started(std::chrono::seconds timeout)\n{\n    co_return co_await client_-&gt;wait_for_connected(timeout);\n}\n\nAsyncResult&lt;std::shared_ptr&lt;RemoteObject&gt;&gt; GrpcProbe::find_object(ObjectQuery query)\n{\n    LOG_DEBUG(grpc_app_logger(), \"Starting request with object_name={}\", fmt::format(\"{}\", query));\n    const auto object_result = co_await client_-&gt;probe_service().find_object(std::move(query));\n    co_return object_result.and_then([this](ObjectReference object_ref) -&gt; Result&lt;std::shared_ptr&lt;RemoteObject&gt;&gt; {\n        return std::make_shared&lt;GrpcRemoteObject&gt;(object_ref, client_);\n    });\n}\n\nAsyncResult&lt;std::vector&lt;std::shared_ptr&lt;RemoteObject&gt;&gt;&gt; GrpcProbe::get_views()\n{\n    LOG_TRACE_L1(grpc_app_logger(), \"Requesting top level views from {}\", \"[TODO:APPNAME]\");\n    auto response = co_await client_-&gt;probe_service().query_top_level_views();\n    co_return response.and_then(\n        [this](const std::vector&lt;ObjectReference&gt; &amp;refs) -&gt; Result&lt;std::vector&lt;std::shared_ptr&lt;RemoteObject&gt;&gt;&gt; {\n            std::vector&lt;std::shared_ptr&lt;RemoteObject&gt;&gt; views;\n            views.reserve(refs.size());\n            for (auto &amp;&amp;obj : refs)\n            {\n                views.emplace_back(std::make_shared&lt;GrpcRemoteObject&gt;(obj, client_));\n            }\n            return views;\n        });\n}\n\nmeta::MetaRegistry &amp;GrpcProbe::meta_registry()\n{\n    return client_-&gt;meta_registry();\n}\n\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__probe_8hpp/","title":"File grpc_probe.hpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_probe.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/client/client.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/client/probe_client.hpp&gt;</code></li> <li><code>#include \"basic_probe.hpp\"</code></li> <li><code>#include \"grpc_value.hpp\"</code></li> <li><code>#include \"quite/client/remote_object.hpp\"</code></li> </ul>"},{"location":"quite/grpc__probe_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/grpc__probe_8hpp/#classes","title":"Classes","text":"Type Name class GrpcProbe <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_probe.hpp</code></p>"},{"location":"quite/grpc__probe_8hpp_source/","title":"File grpc_probe.hpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_probe.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/async_result.hpp&gt;\n#include &lt;quite/proto/client/client.hpp&gt;\n#include &lt;quite/proto/client/probe_client.hpp&gt;\n#include \"basic_probe.hpp\"\n#include \"grpc_value.hpp\"\n#include \"quite/client/remote_object.hpp\"\nnamespace quite::client\n{\nclass GrpcProbe : public BasicProbe\n{\n  public:\n    explicit GrpcProbe(manager::ProcessHandle process, proto::Client &amp;client, std::string connection_uri);\n    AsyncResult&lt;std::shared_ptr&lt;RemoteObject&gt;&gt; find_object(ObjectQuery query) override;\n    AsyncResult&lt;std::vector&lt;std::shared_ptr&lt;RemoteObject&gt;&gt;&gt; get_views() override;\n    meta::MetaRegistry &amp;meta_registry() override;\n    AsyncResult&lt;void&gt; wait_for_started(std::chrono::seconds timeout) override;\n\n  private:\n    std::shared_ptr&lt;GrpcValueConverter&gt; value_converter_{std::make_shared&lt;GrpcValueConverter&gt;()};\n    std::shared_ptr&lt;proto::ProbeClient&gt; client_;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__property_8cpp/","title":"File grpc_property.cpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_property.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grpc_property.hpp\"</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> </ul>"},{"location":"quite/grpc__property_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_property.cpp</code></p>"},{"location":"quite/grpc__property_8cpp_source/","title":"File grpc_property.cpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_property.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grpc_property.hpp\"\n#include &lt;quite/logger.hpp&gt;\n\nDEFINE_LOGGER(grpc_property_logger)\n\nnamespace quite::client\n{\nGrpcProperty::GrpcProperty(std::shared_ptr&lt;GrpcRemoteObject&gt; parent, std::string name, entt::meta_any initial_value)\n    : parent_{std::move(parent)}\n    , name_{std::move(name)}\n    , last_value_{std::move(initial_value)}\n    , type_id_{0} // TODO\n{}\n\nGrpcProperty::~GrpcProperty() = default;\n\nconst std::string &amp;GrpcProperty::name() const\n{\n    return name_;\n}\n\nmeta::TypeId GrpcProperty::type_id() const\n{\n    return type_id_;\n}\n\nconst Result&lt;entt::meta_any&gt; &amp;GrpcProperty::value() const\n{\n    return last_value_;\n}\n\nAsyncResult&lt;entt::meta_any&gt; GrpcProperty::read()\n{\n    LOG_DEBUG(grpc_property_logger(), \"get property[{}] for object={}\", name_, parent_-&gt;id());\n    last_value_ = co_await parent_-&gt;fetch_property({name_});\n    co_return last_value_;\n}\n\nAsyncResult&lt;void&gt; GrpcProperty::write(entt::meta_any value)\n{\n    LOG_DEBUG(grpc_property_logger(), \"set property[{}] for object={}\", name_, parent_-&gt;id());\n    co_return co_await parent_-&gt;write_property(name_, std::move(value));\n}\n\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__property_8hpp/","title":"File grpc_property.hpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_type_id.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_types.hpp&gt;</code></li> <li><code>#include \"grpc_remote_object.hpp\"</code></li> <li><code>#include \"quite/client/property.hpp\"</code></li> </ul>"},{"location":"quite/grpc__property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/grpc__property_8hpp/#classes","title":"Classes","text":"Type Name class GrpcProperty <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_property.hpp</code></p>"},{"location":"quite/grpc__property_8hpp_source/","title":"File grpc_property.hpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/meta/meta_type_id.hpp&gt;\n#include &lt;quite/meta/meta_types.hpp&gt;\n#include \"grpc_remote_object.hpp\"\n#include \"quite/client/property.hpp\"\n\nnamespace quite::client\n{\nclass GrpcProperty final : public Property\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(GrpcProperty);\n    explicit GrpcProperty(std::shared_ptr&lt;GrpcRemoteObject&gt; parent, std::string name, entt::meta_any initial_value);\n    ~GrpcProperty() override;\n    const std::string &amp;name() const override;\n    meta::TypeId type_id() const override;\n    const Result&lt;entt::meta_any&gt; &amp;value() const override;\n    AsyncResult&lt;entt::meta_any&gt; read() override;\n    AsyncResult&lt;void&gt; write(entt::meta_any value) override;\n\n  private:\n    std::shared_ptr&lt;GrpcRemoteObject&gt; parent_;\n    std::string name_;\n    meta::TypeId type_id_;\n    Result&lt;entt::meta_any&gt; last_value_;\n};\n\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__remote__object_8cpp/","title":"File grpc_remote_object.cpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_remote_object.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grpc_remote_object.hpp\"</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"grpc_property.hpp\"</code></li> </ul>"},{"location":"quite/grpc__remote__object_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/grpc__remote__object_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOGGER (grpc_remote_object_logger)"},{"location":"quite/grpc__remote__object_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/grpc__remote__object_8cpp/#function-define_logger","title":"function DEFINE_LOGGER","text":"<pre><code>DEFINE_LOGGER (\n    grpc_remote_object_logger\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_remote_object.cpp</code></p>"},{"location":"quite/grpc__remote__object_8cpp_source/","title":"File grpc_remote_object.cpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_remote_object.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grpc_remote_object.hpp\"\n#include &lt;fmt/ranges.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"grpc_property.hpp\"\n\nDEFINE_LOGGER(grpc_remote_object_logger);\nnamespace quite::client\n{\nGrpcRemoteObject::GrpcRemoteObject(ObjectReference reference, std::shared_ptr&lt;proto::ProbeClient&gt; client)\n    : RemoteObject{reference.object_id}\n    , client_{std::move(client)}\n    , type_id_{reference.type_id}\n{}\n\nmeta::TypeId GrpcRemoteObject::type_id() const\n{\n    return type_id_;\n}\n\nAsyncResult&lt;std::unordered_map&lt;std::string, std::shared_ptr&lt;Property&gt;&gt;&gt; GrpcRemoteObject::fetch_properties(\n    std::vector&lt;std::string&gt; properties)\n{\n    using RetVal = std::unordered_map&lt;std::string, std::shared_ptr&lt;Property&gt;&gt;;\n    LOG_DEBUG(grpc_remote_object_logger(),\n              \"get properties[{}] for object={}\",\n              fmt::format(\"{}\", fmt::join(properties, \",\")),\n              id());\n    const auto result = co_await client_-&gt;probe_service().get_object_properties(id(), std::move(properties));\n    co_return result.transform([this](auto &amp;&amp;properties) -&gt; RetVal {\n        RetVal values;\n        for (auto &amp;&amp;[key, value] : properties)\n        {\n            values.emplace(key, std::make_shared&lt;GrpcProperty&gt;(shared_from_this(), key, value));\n        }\n        return values;\n    });\n}\n\nAsyncResult&lt;std::shared_ptr&lt;Property&gt;&gt; GrpcRemoteObject::property(std::string property_name)\n{\n    LOG_DEBUG(grpc_remote_object_logger(), \"get property[{}] for object={}\", property_name, id());\n\n    auto response = co_await fetch_property(property_name);\n    co_return response.and_then([this, &amp;property_name](auto &amp;&amp;value) -&gt; Result&lt;std::shared_ptr&lt;Property&gt;&gt; {\n        return std::make_shared&lt;GrpcProperty&gt;(\n            shared_from_this(), std::move(property_name), std::forward&lt;decltype(value)&gt;(value));\n    });\n}\n\nAsyncResult&lt;void&gt; GrpcRemoteObject::write_property(std::string property_name, entt::meta_any value)\n{\n    auto response =\n        co_await client_-&gt;probe_service().set_object_property(id(), std::move(property_name), std::move(value));\n    co_return response;\n}\n\nAsyncResult&lt;entt::meta_any&gt; GrpcRemoteObject::fetch_property(std::string property_name)\n{\n    std::vector&lt;std::string&gt; gcc13_workaround{property_name}; // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=115660\n    auto response = co_await client_-&gt;probe_service().get_object_properties(id(), std::move(gcc13_workaround));\n    co_return response.and_then([this, &amp;property_name](auto &amp;&amp;properties) -&gt; Result&lt;entt::meta_any&gt; {\n        auto it = properties.find(property_name);\n        if (it == properties.end())\n        {\n            return make_error_result(ErrorCode::not_found, \"Server did not return the expected property.\");\n        }\n        return it-&gt;second;\n    });\n}\n\nAsyncResult&lt;void&gt; GrpcRemoteObject::mouse_action()\n{\n    LOG_DEBUG(grpc_remote_object_logger(), \"mouse_action for object={}\", id());\n    co_return co_await client_-&gt;mouse_injector().single_action(\n        id(), core::MouseAction{.button = core::MouseButton::left, .trigger = core::MouseTrigger::click});\n}\n\nAsyncResult&lt;Image&gt; GrpcRemoteObject::take_snapshot()\n{\n    co_return co_await client_-&gt;probe_service().take_snapshot(id());\n}\n\nAsyncResult&lt;void&gt; GrpcRemoteObject::invoke_method(std::string method_name)\n{\n    LOG_DEBUG(grpc_remote_object_logger(), \"invoke method: {}\", method_name);\n    auto response = co_await client_-&gt;probe_service().invoke_method(id(), std::move(method_name), {});\n\n    if (response.has_value())\n    {\n        if (*response)\n        {\n            LOG_DEBUG(grpc_remote_object_logger(), \"Has return value: {}\", response-&gt;type().info().name());\n        }\n        co_return {};\n    }\n    co_return std::unexpected{std::move(response.error())};\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__remote__object_8hpp/","title":"File grpc_remote_object.hpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_remote_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/client/remote_object.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include \"quite/proto/client/probe_client.hpp\"</code></li> </ul>"},{"location":"quite/grpc__remote__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/grpc__remote__object_8hpp/#classes","title":"Classes","text":"Type Name class GrpcRemoteObject <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_remote_object.hpp</code></p>"},{"location":"quite/grpc__remote__object_8hpp_source/","title":"File grpc_remote_object.hpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_remote_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/client/remote_object.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include \"quite/proto/client/probe_client.hpp\"\n\nnamespace quite::client\n{\nclass GrpcRemoteObject final : public std::enable_shared_from_this&lt;GrpcRemoteObject&gt;, public RemoteObject\n{\n  public:\n    explicit GrpcRemoteObject(ObjectReference reference, std::shared_ptr&lt;proto::ProbeClient&gt; client);\n\n    meta::TypeId type_id() const override;\n\n    AsyncResult&lt;std::unordered_map&lt;std::string, PropertyPtr&gt;&gt; fetch_properties(\n        std::vector&lt;std::string&gt; properties) override;\n\n    AsyncResult&lt;PropertyPtr&gt; property(std::string property_name) override;\n    AsyncResult&lt;void&gt; write_property(std::string property_name, entt::meta_any value) override;\n    AsyncResult&lt;entt::meta_any&gt; fetch_property(std::string property_name);\n\n    AsyncResult&lt;void&gt; mouse_action() override;\n\n    AsyncResult&lt;Image&gt; take_snapshot() override;\n\n    AsyncResult&lt;void&gt; invoke_method(std::string method_name) override;\n\n  private:\n    std::shared_ptr&lt;proto::ProbeClient&gt; client_;\n    meta::TypeId type_id_;\n};\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__value_8cpp/","title":"File grpc_value.cpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_value.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grpc_value.hpp\"</code></li> <li><code>#include \"grpc_impl/grpc_remote_object.hpp\"</code></li> </ul>"},{"location":"quite/grpc__value_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_value.cpp</code></p>"},{"location":"quite/grpc__value_8cpp_source/","title":"File grpc_value.cpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_value.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grpc_value.hpp\"\n#include \"grpc_impl/grpc_remote_object.hpp\"\n\nnamespace quite::client\n{\nvoid GrpcValueConverter::set_client(std::shared_ptr&lt;proto::ProbeClient&gt; client)\n{\n    client_ = std::move(client);\n}\n\nentt::meta_any GrpcValueConverter::from(ObjectReference ref) const\n{\n    if (auto client = client_.lock(); client != nullptr)\n    {\n        return entt::forward_as_meta(std::make_shared&lt;GrpcRemoteObject&gt;(std::move(ref), client));\n    }\n    return {};\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/grpc__value_8hpp/","title":"File grpc_value.hpp","text":"<p>FileList &gt; client &gt; src &gt; grpc_impl &gt; grpc_value.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/proto/client/probe_client.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/client/value_converter.hpp&gt;</code></li> </ul>"},{"location":"quite/grpc__value_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/grpc__value_8hpp/#classes","title":"Classes","text":"Type Name class GrpcValueConverter <p>The documentation for this class was generated from the following file <code>libs/client/src/grpc_impl/grpc_value.hpp</code></p>"},{"location":"quite/grpc__value_8hpp_source/","title":"File grpc_value.hpp","text":"<p>File List &gt; client &gt; src &gt; grpc_impl &gt; grpc_value.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/proto/client/probe_client.hpp&gt;\n#include &lt;quite/proto/client/value_converter.hpp&gt;\nnamespace quite::client\n{\nclass GrpcValueConverter final : public proto::IValueConverter\n{\n  public:\n    void set_client(std::shared_ptr&lt;proto::ProbeClient&gt; client);\n    entt::meta_any from(ObjectReference ref) const override;\n\n  private:\n    std::weak_ptr&lt;proto::ProbeClient&gt; client_;\n};\n// quite::Result&lt;quite::Value&gt; convert(const entt::meta_any &amp;value, std::shared_ptr&lt;proto::ProbeClient&gt; client);\n} // namespace quite::client\n</code></pre>"},{"location":"quite/dir_68d39c0361b86bfea899754328b9cdd2/","title":"Dir libs/client/src/testing","text":"<p>FileList &gt; client &gt; src &gt; testing</p>"},{"location":"quite/dir_68d39c0361b86bfea899754328b9cdd2/#files","title":"Files","text":"Type Name file verification_point.cpp <p>The documentation for this class was generated from the following file <code>libs/client/src/testing/</code></p>"},{"location":"quite/verification__point_8cpp/","title":"File verification_point.cpp","text":"<p>FileList &gt; client &gt; src &gt; testing &gt; verification_point.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/testing/verification_point.hpp\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;quite/image_utils.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"quite/client/utils/dump_properties.hpp\"</code></li> </ul>"},{"location":"quite/verification__point_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace testing <p>The documentation for this class was generated from the following file <code>libs/client/src/testing/verification_point.cpp</code></p>"},{"location":"quite/verification__point_8cpp_source/","title":"File verification_point.cpp","text":"<p>File List &gt; client &gt; src &gt; testing &gt; verification_point.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/testing/verification_point.hpp\"\n#include &lt;fstream&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;quite/image_utils.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"quite/client/utils/dump_properties.hpp\"\n\nDEFINE_LOGGER(vp_logger)\nnamespace fstd = std::filesystem;\nnamespace quite::testing\n{\n\nbool has_verification_point(const std::string &amp;name)\n{\n    return fstd::exists(fstd::path(name).replace_extension(\".png\")) and\n           fstd::exists(fstd::path(name).replace_extension(\".json\"));\n}\n\nAsyncResult&lt;void&gt; create_verification_point(client::RemoteObjectPtr object, const std::string &amp;name)\n{\n    const auto snapshot = co_await object-&gt;take_snapshot();\n    if (not snapshot.has_value())\n    {\n        co_return std::unexpected(snapshot.error());\n    }\n    const auto props = co_await dump_properties(object, {\"objectName\", \"width\", \"height\", \"children\", \"visible\"});\n    if (not props.has_value())\n    {\n        co_return std::unexpected(props.error());\n    }\n\n    snapshot-&gt;save_to(fstd::path(name).replace_extension(\".png\"));\n\n    std::ofstream o{fstd::path(name).replace_extension(\".json\")};\n    o &lt;&lt; std::setw(4) &lt;&lt; *props &lt;&lt; std::endl;\n    co_return {};\n}\n\nAsyncResult&lt;bool&gt; verify_verification_point(client::RemoteObjectPtr object, const std::string &amp;name)\n{\n    bool verified = true;\n    const auto snapshot = co_await object-&gt;take_snapshot();\n    if (not snapshot.has_value())\n    {\n        LOG_ERROR(vp_logger(), \"Error while creating the snapshot: {}\", snapshot.error().message);\n        co_return std::unexpected(snapshot.error());\n    }\n\n    const auto props = co_await dump_properties(object, {\"objectName\", \"width\", \"height\", \"children\", \"visible\"});\n    if (not props.has_value())\n    {\n        LOG_ERROR(vp_logger(), \"Error while fetching the properties: {}\", props.error().message);\n        co_return std::unexpected(props.error());\n    }\n\n    if (not has_verification_point(name))\n    {\n        co_return make_error_result(ErrorCode::failed_precondition, fmt::format(\"Could not locate {}.png|.json\", name));\n    }\n\n    const Image expected_snapshot{fstd::path(name).replace_extension(\".png\")};\n    std::ifstream json_prop_file(fstd::path(name).replace_extension(\".json\"));\n    const nlohmann::json expected_props = nlohmann::json::parse(json_prop_file);\n\n    verified = (*props == expected_props);\n    if (not verified)\n    {\n        LOG_INFO(vp_logger(), \"Properties do not match.\");\n        std::ofstream o{fmt::format(\"{}_current.json\", name)};\n        o &lt;&lt; std::setw(4) &lt;&lt; *props &lt;&lt; std::endl;\n    }\n\n    const auto cmp_result = pixel_match(expected_snapshot.data(), snapshot-&gt;data(), PixelCompareOptions{});\n    if (not cmp_result.has_value())\n    {\n        LOG_ERROR(vp_logger(), \"Error while comparing the images: {}\", cmp_result.error().message);\n        co_return std::unexpected(cmp_result.error());\n    }\n\n    verified = (verified &amp;&amp; cmp_result-&gt;diff == 0);\n    if (not verified)\n    {\n        LOG_INFO(vp_logger(), \"Images does not match. Failed with compare {}\", cmp_result-&gt;diff);\n        cmp_result-&gt;diff_image.save_to(fmt::format(\"{}_diff.png\", name));\n        snapshot-&gt;save_to(fmt::format(\"{}_current.png\", name));\n    }\n\n    co_return verified;\n}\n} // namespace quite::testing\n</code></pre>"},{"location":"quite/dir_5d73f1c58d7ce353e6ce404cafa32f0a/","title":"Dir libs/client/src/utils","text":"<p>FileList &gt; client &gt; src &gt; utils</p>"},{"location":"quite/dir_5d73f1c58d7ce353e6ce404cafa32f0a/#files","title":"Files","text":"Type Name file dump_properties.cpp <p>The documentation for this class was generated from the following file <code>libs/client/src/utils/</code></p>"},{"location":"quite/dump__properties_8cpp/","title":"File dump_properties.cpp","text":"<p>FileList &gt; client &gt; src &gt; utils &gt; dump_properties.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/utils/dump_properties.hpp\"</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> <li><code>#include &lt;quite/meta_any_formatter.hpp&gt;</code></li> </ul>"},{"location":"quite/dump__properties_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace entt namespace quite namespace client"},{"location":"quite/dump__properties_8cpp/#public-types","title":"Public Types","text":"Type Name typedef nlohmann::json json"},{"location":"quite/dump__properties_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"quite/dump__properties_8cpp/#typedef-json","title":"typedef json","text":"<pre><code>using json =  nlohmann::json;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/src/utils/dump_properties.cpp</code></p>"},{"location":"quite/dump__properties_8cpp_source/","title":"File dump_properties.cpp","text":"<p>File List &gt; client &gt; src &gt; utils &gt; dump_properties.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/utils/dump_properties.hpp\"\n#include &lt;unordered_set&gt;\n#include &lt;nlohmann/json.hpp&gt;\n#include &lt;quite/meta_any_formatter.hpp&gt;\n\nusing json = nlohmann::json;\n\nnamespace quite\n{\nvoid to_json(json &amp;j, const GenericClass &amp;v);\n}\n\nnamespace entt\n{\nvoid to_json(json &amp;j, const entt::meta_any &amp;v)\n{\n    const auto type = v.type();\n\n    if (type.info() == entt::type_id&lt;quite::GenericClass&gt;())\n    {\n        j = v.cast&lt;quite::GenericClass&gt;();\n    }\n    else\n    {\n        j = json{{\"unkown_value_type\", type.info().name()}};\n    }\n}\n} // namespace entt\nnamespace quite\n{\nvoid to_json(json &amp;j, const GenericClass &amp;v)\n{\n    j = json{v.properties};\n}\nnamespace client\n{\nnamespace\n{\n\nAsyncResult&lt;nlohmann::json&gt; dump_properties(std::unordered_set&lt;ObjectId&gt; &amp;visited_objects,\n                                            RemoteObjectPtr remote_object,\n                                            std::vector&lt;std::string&gt; properties);\n\nAsyncResult&lt;nlohmann::json&gt; dump_properties(std::unordered_set&lt;ObjectId&gt; &amp;visited_objects,\n                                            RemoteObjectPtr remote_object,\n                                            std::vector&lt;std::string&gt; properties)\n{\n    if (visited_objects.contains(remote_object-&gt;id()))\n    {\n        co_return nlohmann::json{};\n    }\n    visited_objects.emplace(remote_object-&gt;id());\n\n    nlohmann::json out = nlohmann::json::object();\n    auto props = co_await remote_object-&gt;fetch_properties(properties);\n    if (not props.has_value())\n    {\n        co_return std::unexpected(props.error());\n    }\n\n    for (auto &amp;&amp;prop : *props)\n    {\n        if (prop.second-&gt;value().has_value())\n        {\n            auto any_json = prop.second-&gt;value();\n            if (any_json)\n            {\n                out[prop.first] = any_json.value();\n            }\n            else\n            {\n                co_return make_error_result(ErrorCode::invalid_argument,\n                                            fmt::format(\"Could not create json from {}\", *prop.second-&gt;value()));\n            }\n        }\n        else\n        {\n            out[prop.first] = nlohmann::json{};\n        }\n    }\n\n    co_return out;\n}\n\n} // namespace\nAsyncResult&lt;nlohmann::json&gt; dump_properties(RemoteObjectPtr remote_object, std::vector&lt;std::string&gt; properties)\n{\n    std::unordered_set&lt;ObjectId&gt; objects;\n    co_return co_await dump_properties(objects, std::move(remote_object), std::move(properties));\n}\n} // namespace client\n} // namespace quite\n</code></pre>"},{"location":"quite/probe__handle_8cpp/","title":"File probe_handle.cpp","text":"<p>FileList &gt; client &gt; src &gt; probe_handle.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/probe_handle.hpp\"</code></li> </ul>"},{"location":"quite/probe__handle_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/probe_handle.cpp</code></p>"},{"location":"quite/probe__handle_8cpp_source/","title":"File probe_handle.cpp","text":"<p>File List &gt; client &gt; src &gt; probe_handle.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/probe_handle.hpp\"\n\nnamespace quite::client\n{\nProbeHandle::ProbeHandle(std::shared_ptr&lt;Probe&gt; probe)\n    : probe_{std::move(probe)}\n{}\n\nProbe *ProbeHandle::operator-&gt;()\n{\n    return probe_.get();\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2src_2probe__manager_8cpp/","title":"File probe_manager.cpp","text":"<p>FileList &gt; client &gt; src &gt; probe_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/probe_manager.hpp\"</code></li> <li><code>#include \"context.hpp\"</code></li> <li><code>#include \"grpc_impl/grpc_probe.hpp\"</code></li> </ul>"},{"location":"quite/client_2src_2probe__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client"},{"location":"quite/client_2src_2probe__manager_8cpp/#classes","title":"Classes","text":"Type Name struct Impl <p>The documentation for this class was generated from the following file <code>libs/client/src/probe_manager.cpp</code></p>"},{"location":"quite/client_2src_2probe__manager_8cpp_source/","title":"File probe_manager.cpp","text":"<p>File List &gt; client &gt; src &gt; probe_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/probe_manager.hpp\"\n#include \"context.hpp\"\n#include \"grpc_impl/grpc_probe.hpp\"\n\nnamespace quite::client\n{\nstruct ProbeManager::Impl\n{};\n\nProbeManager::ProbeManager()\n    : impl_{std::make_unique&lt;Impl&gt;()}\n{}\n\nProbeManager::~ProbeManager()\n{}\n\nProbeHandle ProbeManager::connect(manager::ProcessHandle handle, const std::string &amp;connection_url)\n{\n    return ProbeHandle{std::make_shared&lt;GrpcProbe&gt;(\n        std::move(handle), quite::Context::Instance().backend_client(), std::move(connection_url))};\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2src_2property_8cpp/","title":"File property.cpp","text":"<p>FileList &gt; client &gt; src &gt; property.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/property.hpp\"</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> </ul>"},{"location":"quite/client_2src_2property_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/property.cpp</code></p>"},{"location":"quite/client_2src_2property_8cpp_source/","title":"File property.cpp","text":"<p>File List &gt; client &gt; src &gt; property.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/property.hpp\"\n#include &lt;fmt/format.h&gt;\n\nnamespace quite::client\n{\n\nProperty::~Property() = default;\n\n} // namespace quite::client\n</code></pre>"},{"location":"quite/quite_8cpp/","title":"File quite.cpp","text":"<p>FileList &gt; client &gt; src &gt; quite.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/client/quite.hpp\"</code></li> <li><code>#include \"context.hpp\"</code></li> </ul>"},{"location":"quite/quite_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/quite.cpp</code></p>"},{"location":"quite/quite_8cpp_source/","title":"File quite.cpp","text":"<p>File List &gt; client &gt; src &gt; quite.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/client/quite.hpp\"\n#include \"context.hpp\"\n\nnamespace quite::client\n{\nexecpools::asio_thread_pool &amp;asio_context()\n{\n    return Context::Instance().asio_context();\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/client_2src_2remote__object_8cpp/","title":"File remote_object.cpp","text":"<p>FileList &gt; client &gt; src &gt; remote_object.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/client/remote_object.hpp&gt;</code></li> </ul>"},{"location":"quite/client_2src_2remote__object_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client <p>The documentation for this class was generated from the following file <code>libs/client/src/remote_object.cpp</code></p>"},{"location":"quite/client_2src_2remote__object_8cpp_source/","title":"File remote_object.cpp","text":"<p>File List &gt; client &gt; src &gt; remote_object.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;quite/client/remote_object.hpp&gt;\nnamespace quite::client\n{\nRemoteObject::RemoteObject(ObjectId id)\n    : id_{id}\n{}\n\nRemoteObject::~RemoteObject() = default;\n\nObjectId RemoteObject::id() const noexcept\n{\n    return id_;\n}\n} // namespace quite::client\n</code></pre>"},{"location":"quite/dir_90b6548612c197e0640182542cb94ea9/","title":"Dir libs/client/test","text":"<p>FileList &gt; client &gt; test</p>"},{"location":"quite/dir_90b6548612c197e0640182542cb94ea9/#files","title":"Files","text":"Type Name file main.cpp <p>The documentation for this class was generated from the following file <code>libs/client/test/</code></p>"},{"location":"quite/client_2test_2main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; client &gt; test &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> </ul>"},{"location":"quite/client_2test_2main_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace ut"},{"location":"quite/client_2test_2main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, const char ** argv)"},{"location":"quite/client_2test_2main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/client_2test_2main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char ** argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/client/test/main.cpp</code></p>"},{"location":"quite/client_2test_2main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; client &gt; test &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/ut.hpp&gt;\nusing namespace boost::ut;\nint main(int argc, const char **argv)\n{\n    boost::ut::detail::cfg::parse_arg_with_fallback(argc, argv);\n}\n</code></pre>"},{"location":"quite/dir_6f77a39b07c019ccd7492ea87272f732/","title":"Dir libs/core","text":"<p>FileList &gt; core</p>"},{"location":"quite/dir_6f77a39b07c019ccd7492ea87272f732/#files","title":"Files","text":"Type Name file asio_config.hpp.in file version.hpp.in"},{"location":"quite/dir_6f77a39b07c019ccd7492ea87272f732/#directories","title":"Directories","text":"Type Name dir include dir src dir test <p>The documentation for this class was generated from the following file <code>libs/core/</code></p>"},{"location":"quite/asio__config_8hpp_8in/","title":"File asio_config.hpp.in","text":"<p>FileList &gt; core &gt; asio_config.hpp.in</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/core/asio_config.hpp.in</code></p>"},{"location":"quite/asio__config_8hpp_8in_source/","title":"File asio_config.hpp.in","text":"<p>File List &gt; core &gt; asio_config.hpp.in</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#cmakedefine01 QUITE_USES_BOOST\n\n#if QUITE_USES_BOOST\n#  include &lt;boost/asio.hpp&gt;\n#  include &lt;boost/system/errc.hpp&gt;\n#  include &lt;boost/system/error_code.hpp&gt;\n#  include &lt;boost/system/system_error.hpp&gt;\n#  define QUITE_ASIO_NAMESPACE boost::asio\n#else\n#  include &lt;system_error&gt;\n#  include &lt;asio.hpp&gt;\n#  define QUITE_ASIO_NAMESPACE asio\n#endif\n\nnamespace quite {\n#if QUITE_USES_BOOST\n  namespace asio_impl = ::boost::asio;\n  using error_code = ::boost::system::error_code;\n  using error_condition = ::boost::system::error_condition;\n  namespace errc = ::boost::system::errc;\n  using system_error = ::boost::system::system_error;\n#else\n  namespace asio_impl = ::asio;\n  using error_code = std::error_code;\n  using error_condition = std::error_condition;\n  using errc = std::errc;\n  using system_error = std::system_error;\n#endif\n}\n</code></pre>"},{"location":"quite/dir_25de89a49d1da2858ac6330785c12b40/","title":"Dir libs/core/include","text":"<p>FileList &gt; core &gt; include</p>"},{"location":"quite/dir_25de89a49d1da2858ac6330785c12b40/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/core/include/</code></p>"},{"location":"quite/dir_6f50b8774c4552618988001c2022dcf6/","title":"Dir libs/core/include/quite","text":"<p>FileList &gt; core &gt; include &gt; quite</p>"},{"location":"quite/dir_6f50b8774c4552618988001c2022dcf6/#files","title":"Files","text":"Type Name file asio_context.hpp file async_result.hpp file disable_copy_move.hpp file error.hpp file geometry.hpp file image.hpp file image_utils.hpp file logger.hpp file meta_any_formatter.hpp file result.hpp file service_handle.hpp file setup_logger.hpp"},{"location":"quite/dir_6f50b8774c4552618988001c2022dcf6/#directories","title":"Directories","text":"Type Name dir injectors dir meta dir value <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/</code></p>"},{"location":"quite/asio__context_8hpp/","title":"File asio_context.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; asio_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;execpools/asio/asio_thread_pool.hpp&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/asio__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/asio_context.hpp</code></p>"},{"location":"quite/asio__context_8hpp_source/","title":"File asio_context.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; asio_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;execpools/asio/asio_thread_pool.hpp&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\n\nQUITE_CORE_EXPORT execpools::asio_thread_pool &amp;thread_pool();\n\nQUITE_CORE_EXPORT auto get_executor() -&gt; decltype(thread_pool().get_executor());\n\n} // namespace quite\n</code></pre>"},{"location":"quite/async__result_8hpp/","title":"File async_result.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; async_result.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include \"result.hpp\"</code></li> </ul>"},{"location":"quite/async__result_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/async_result.hpp</code></p>"},{"location":"quite/async__result_8hpp_source/","title":"File async_result.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; async_result.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;exec/task.hpp&gt;\n#include \"result.hpp\"\n\nnamespace quite\n{\ntemplate &lt;typename T&gt;\nusing AsyncResult = exec::task&lt;Result&lt;T&gt;&gt;;\n}\n</code></pre>"},{"location":"quite/disable__copy__move_8hpp/","title":"File disable_copy_move.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; disable_copy_move.hpp</p> <p>Go to the source code of this file</p>"},{"location":"quite/disable__copy__move_8hpp/#macros","title":"Macros","text":"Type Name define QUITE_DEFAULT_MOVE (ClassName) <code>/* multi line expression */</code> define QUITE_DISABLE_COPY (ClassName) <code>/* multi line expression */</code> define QUITE_DISABLE_COPY_MOVE (ClassName) <code>/* multi line expression */</code>"},{"location":"quite/disable__copy__move_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/disable__copy__move_8hpp/#define-quite_default_move","title":"define QUITE_DEFAULT_MOVE","text":"<pre><code>#define QUITE_DEFAULT_MOVE (\n    ClassName\n) `/* multi line expression */`\n</code></pre>"},{"location":"quite/disable__copy__move_8hpp/#define-quite_disable_copy","title":"define QUITE_DISABLE_COPY","text":"<pre><code>#define QUITE_DISABLE_COPY (\n    ClassName\n) `/* multi line expression */`\n</code></pre>"},{"location":"quite/disable__copy__move_8hpp/#define-quite_disable_copy_move","title":"define QUITE_DISABLE_COPY_MOVE","text":"<pre><code>#define QUITE_DISABLE_COPY_MOVE (\n    ClassName\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/disable_copy_move.hpp</code></p>"},{"location":"quite/disable__copy__move_8hpp_source/","title":"File disable_copy_move.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; disable_copy_move.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define QUITE_DISABLE_COPY(ClassName)                                                                                  \\\n    ClassName(const ClassName &amp;) = delete;                                                                             \\\n    ClassName &amp;operator=(const ClassName &amp;) = delete;\n\n#define QUITE_DISABLE_COPY_MOVE(ClassName)                                                                             \\\n    QUITE_DISABLE_COPY(ClassName)                                                                                      \\\n    ClassName(ClassName &amp;&amp;) = delete;                                                                                  \\\n    ClassName &amp;operator=(ClassName &amp;&amp;) = delete;\n\n#define QUITE_DEFAULT_MOVE(ClassName)                                                                                  \\\n    ClassName(ClassName &amp;&amp;) noexcept = default;                                                                        \\\n    ClassName &amp;operator=(ClassName &amp;&amp;) noexcept = default;\n</code></pre>"},{"location":"quite/error_8hpp/","title":"File error.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; error.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/error_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/error_8hpp/#classes","title":"Classes","text":"Type Name struct fmt &lt;&gt; struct Error <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/error.hpp</code></p>"},{"location":"quite/error_8hpp_source/","title":"File error.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; error.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;fmt/core.h&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\n\nenum class ErrorCode\n{\n    unknown,          \n    cancelled,        \n    invalid_argument, \n    deadline_exceeded,   \n    not_found,           \n    failed_precondition, \n    aborted,       \n    unimplemented, \n    unavailable,   \n};\n\nstruct Error\n{\n    ErrorCode code;\n    std::string message;\n};\n} // namespace quite\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::ErrorCode&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(quite::ErrorCode error_code, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::Error&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::Error &amp;error, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n</code></pre>"},{"location":"quite/geometry_8hpp/","title":"File geometry.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; geometry.hpp</p> <p>Go to the source code of this file</p>"},{"location":"quite/geometry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/geometry_8hpp/#classes","title":"Classes","text":"Type Name struct Vector2 <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/geometry.hpp</code></p>"},{"location":"quite/geometry_8hpp_source/","title":"File geometry.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; geometry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace quite\n{\nstruct Vector2\n{\n    double x;\n    double y;\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/image_8hpp/","title":"File image.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; image.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/image_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/image_8hpp/#classes","title":"Classes","text":"Type Name class Image struct ImageView <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image.hpp</code></p>"},{"location":"quite/image_8hpp_source/","title":"File image.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; image.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;filesystem&gt;\n#include &lt;span&gt;\n#include &lt;vector&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\nusing PixelData = std::span&lt;std::byte&gt;;\nstruct ImageView\n{\n    std::uint32_t width;\n    std::uint32_t height;\n    int channels;\n    PixelData data;\n};\nclass QUITE_CORE_EXPORT Image\n{\n  public:\n    Image();\n    explicit Image(std::vector&lt;std::byte&gt; image_data, std::uint32_t width, std::uint32_t height, int channels);\n    explicit Image(const std::filesystem::path &amp;filename);\n    Image(Image &amp;&amp;) noexcept;\n    Image &amp;operator=(Image &amp;&amp;other) noexcept;\n    Image(const Image &amp;);\n    Image &amp;operator=(const Image &amp;other);\n    virtual ~Image();\n\n    void save_to(const std::filesystem::path &amp;destination) const;\n    ImageView data() const;\n\n  private:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/image__utils_8hpp/","title":"File image_utils.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; image_utils.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include \"quite/image.hpp\"</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> <li><code>#include \"quite/result.hpp\"</code></li> </ul>"},{"location":"quite/image__utils_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/image__utils_8hpp/#classes","title":"Classes","text":"Type Name struct ImageCompareResult struct PixelCompareOptions <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/image_utils.hpp</code></p>"},{"location":"quite/image__utils_8hpp_source/","title":"File image_utils.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; image_utils.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;optional&gt;\n#include \"quite/image.hpp\"\n#include \"quite/quite_core_export.hpp\"\n#include \"quite/result.hpp\"\n\nnamespace quite\n{\nstruct PixelCompareOptions\n{\n    float threshold{0.1};                                   // matching threshold (0 to 1); smaller is more sensitive\n    bool skip_anti_aliasing{false};                         // whether to skip anti-aliasing detection\n    float alpha{0.1};                                       // opacity of original image in diff output\n    std::array&lt;uint8_t, 3&gt; anti_aliased_color{255, 255, 0}; // color of anti-aliased pixels in diff output\n    std::array&lt;uint8_t, 3&gt; diff_color{255, 0, 0};           // color of different pixels in diff output\n    std::optional&lt;std::array&lt;uint8_t, 3&gt;&gt;\n        diff_color_alt;    // whether to detect dark on light differences between img1 and img2 and set an alternative\n                           // color to differentiate between the two\n    bool diff_mask{false}; // draw the diff over a transparent background (a mask)\n};\n\nstruct ImageCompareResult\n{\n    int diff{};\n    Image diff_image;\n};\n\nQUITE_CORE_EXPORT Result&lt;ImageCompareResult&gt; pixel_match(const ImageView &amp;expected_img,\n                                                         const ImageView &amp;actual_img,\n                                                         const PixelCompareOptions &amp;options = {});\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_3608ef6849ab2123a7cae9eea604e8ae/","title":"Dir libs/core/include/quite/injectors","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; injectors</p>"},{"location":"quite/dir_3608ef6849ab2123a7cae9eea604e8ae/#files","title":"Files","text":"Type Name file keys.hpp file mouse_injector.hpp <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/</code></p>"},{"location":"quite/keys_8hpp/","title":"File keys.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; injectors &gt; keys.hpp</p> <p>Go to the source code of this file</p>"},{"location":"quite/keys_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace core <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/keys.hpp</code></p>"},{"location":"quite/keys_8hpp_source/","title":"File keys.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; injectors &gt; keys.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace quite::core\n{\nenum class MouseTrigger\n{\n    none,\n    click,\n    double_click,\n    press,\n    release,\n    move\n};\n\nenum class MouseButton\n{\n    none,\n    left,\n    right,\n    middle,\n    forward,\n    back,\n};\n\nenum class KeyboardModifier\n{\n    none,\n    shift,\n    control,\n    alt,\n    meta,\n};\n} // namespace quite::core\n</code></pre>"},{"location":"quite/core_2include_2quite_2injectors_2mouse__injector_8hpp/","title":"File mouse_injector.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; injectors &gt; mouse_injector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"keys.hpp\"</code></li> <li><code>#include \"quite/async_result.hpp\"</code></li> <li><code>#include \"quite/geometry.hpp\"</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> <li><code>#include \"quite/value/object_id.hpp\"</code></li> </ul>"},{"location":"quite/core_2include_2quite_2injectors_2mouse__injector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace core"},{"location":"quite/core_2include_2quite_2injectors_2mouse__injector_8hpp/#classes","title":"Classes","text":"Type Name class IMouseInjector struct MouseAction <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/injectors/mouse_injector.hpp</code></p>"},{"location":"quite/core_2include_2quite_2injectors_2mouse__injector_8hpp_source/","title":"File mouse_injector.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; injectors &gt; mouse_injector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"keys.hpp\"\n#include \"quite/async_result.hpp\"\n#include \"quite/geometry.hpp\"\n#include \"quite/quite_core_export.hpp\"\n#include \"quite/value/object_id.hpp\"\n\nnamespace quite::core\n{\n\nstruct MouseAction\n{\n    Vector2 position;\n    MouseButton button;\n    MouseTrigger trigger;\n    KeyboardModifier modifier;\n};\n\nclass QUITE_CORE_EXPORT IMouseInjector\n{\n  public:\n    virtual ~IMouseInjector() = default;\n    virtual AsyncResult&lt;void&gt; single_action(ObjectId target_id, MouseAction action) = 0;\n};\n} // namespace quite::core\n</code></pre>"},{"location":"quite/dir_18a9029093157c789cf17586512ae04d/","title":"Dir libs/core/include/quite/meta","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; meta</p>"},{"location":"quite/dir_18a9029093157c789cf17586512ae04d/#files","title":"Files","text":"Type Name file meta_registry.hpp file meta_type_id.hpp file meta_types.hpp <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/</code></p>"},{"location":"quite/meta__registry_8hpp/","title":"File meta_registry.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; meta &gt; meta_registry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include \"meta_types.hpp\"</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/meta__registry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace meta"},{"location":"quite/meta__registry_8hpp/#classes","title":"Classes","text":"Type Name class MetaRegistry <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_registry.hpp</code></p>"},{"location":"quite/meta__registry_8hpp_source/","title":"File meta_registry.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; meta &gt; meta_registry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/async_result.hpp&gt;\n#include \"meta_types.hpp\"\n#include \"quite/quite_core_export.hpp\"\nnamespace quite::meta\n{\nclass QUITE_CORE_EXPORT MetaRegistry\n{\n  public:\n    virtual ~MetaRegistry() = default;\n    virtual AsyncResult&lt;meta::Type&gt; lookup_type(meta::TypeId type_id) = 0;\n};\n} // namespace quite::meta\n</code></pre>"},{"location":"quite/meta__type__id_8hpp/","title":"File meta_type_id.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; meta &gt; meta_type_id.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"quite/meta__type__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace meta <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_type_id.hpp</code></p>"},{"location":"quite/meta__type__id_8hpp_source/","title":"File meta_type_id.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; meta &gt; meta_type_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\nnamespace quite::meta\n{\nusing TypeId = std::uint64_t;\n}\n</code></pre>"},{"location":"quite/meta__types_8hpp/","title":"File meta_types.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; meta &gt; meta_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include \"meta_type_id.hpp\"</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/meta__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace meta"},{"location":"quite/meta__types_8hpp/#classes","title":"Classes","text":"Type Name struct fmt &lt;&gt; struct EnumType struct ListType struct MapType struct Method struct ObjectType struct Property <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta/meta_types.hpp</code></p>"},{"location":"quite/meta__types_8hpp_source/","title":"File meta_types.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; meta &gt; meta_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n#include &lt;fmt/core.h&gt;\n#include \"meta_type_id.hpp\"\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite::meta\n{\nstruct Property\n{\n    std::string name;\n    TypeId type;\n};\n\nstruct Method\n{\n    std::string name;\n    TypeId return_type;\n    std::vector&lt;Property&gt; parameters;\n};\n\nstruct ObjectType\n{\n    TypeId id;\n    std::string name;\n    std::vector&lt;Property&gt; properties;\n    std::vector&lt;Method&gt; constructors;\n    std::vector&lt;Method&gt; methods;\n};\nusing ObjectTypePtr = std::unique_ptr&lt;ObjectType&gt;;\n\nstruct MapType\n{\n    TypeId id;\n    std::string name;\n    TypeId key_type;\n    TypeId value_type;\n};\n\nstruct ListType\n{\n    TypeId id;\n    std::string name;\n    TypeId value_type;\n};\n\nstruct EnumType\n{\n    using ValueName = std::string;\n\n    TypeId id;\n    std::string name;\n    std::unordered_map&lt;ValueName, std::int64_t&gt; values;\n};\nusing EnumTypePtr = std::unique_ptr&lt;EnumType&gt;;\n\nenum class PrimitiveType\n{\n    type_unknown = 0,\n    type_void,\n    type_int,\n    type_uint,\n    type_float,\n    type_double,\n    type_bool,\n    type_string\n};\n\nusing Type = std::variant&lt;PrimitiveType, ListType, MapType, EnumTypePtr, ObjectTypePtr&gt;;\n} // namespace quite::meta\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::Property&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::Property &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::Method&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::Method &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::ObjectType&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::ObjectType &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::MapType&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::MapType &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::ListType&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::ListType &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::EnumType&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::EnumType &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::PrimitiveType&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::PrimitiveType &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::meta::Type&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::meta::Type &amp;type, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n</code></pre>"},{"location":"quite/dir_649c775d6fa8febbabfb9f60e7970e98/","title":"Dir libs/core/include/quite/value","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; value</p>"},{"location":"quite/dir_649c775d6fa8febbabfb9f60e7970e98/#files","title":"Files","text":"Type Name file generic_value_class.hpp file object_id.hpp file object_query.hpp file value_registry.hpp <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/</code></p>"},{"location":"quite/generic__value__class_8hpp/","title":"File generic_value_class.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; value &gt; generic_value_class.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/generic__value__class_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/generic__value__class_8hpp/#classes","title":"Classes","text":"Type Name struct GenericClass <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/generic_value_class.hpp</code></p>"},{"location":"quite/generic__value__class_8hpp_source/","title":"File generic_value_class.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; value &gt; generic_value_class.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\nstruct QUITE_CORE_EXPORT GenericClass\n{\n    using PropertyMap = std::unordered_map&lt;std::string, entt::meta_any&gt;;\n    PropertyMap properties;\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/object__id_8hpp/","title":"File object_id.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; value &gt; object_id.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"quite/meta/meta_type_id.hpp\"</code></li> </ul>"},{"location":"quite/object__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/object__id_8hpp/#classes","title":"Classes","text":"Type Name struct ObjectReference <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/object_id.hpp</code></p>"},{"location":"quite/object__id_8hpp_source/","title":"File object_id.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; value &gt; object_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstdint&gt;\n#include \"quite/meta/meta_type_id.hpp\"\n\nnamespace quite\n{\nusing ObjectId = std::uint64_t;\n\nstruct ObjectReference\n{\n    ObjectId object_id;\n    meta::TypeId type_id;\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/object__query_8hpp/","title":"File object_query.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; value &gt; object_query.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/object__query_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/object__query_8hpp/#classes","title":"Classes","text":"Type Name struct fmt &lt;&gt; struct ObjectQuery class ObjectQueryBuilder <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/object_query.hpp</code></p>"},{"location":"quite/object__query_8hpp_source/","title":"File object_query.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; value &gt; object_query.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;fmt/core.h&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\nclass QUITE_CORE_EXPORT ObjectQueryBuilder;\nstruct QUITE_CORE_EXPORT ObjectQuery\n{\n    using PropertyMap = std::unordered_map&lt;std::string, entt::meta_any&gt;;\n    std::shared_ptr&lt;ObjectQuery&gt; container; // use a shared pointer here, makes the python code gen much easier\n    PropertyMap properties;\n    std::string type_name;\n\n    ObjectQuery() = default;\n    ObjectQuery(const ObjectQuery &amp;other) = default;\n    ObjectQuery(ObjectQuery &amp;&amp;other) noexcept = default;\n    ObjectQuery &amp;operator=(const ObjectQuery &amp;other) = default;\n    ObjectQuery &amp;operator=(ObjectQuery &amp;&amp;other) noexcept = default;\n    ObjectQuery(const ObjectQueryBuilder &amp;builder);\n    ~ObjectQuery() = default;\n};\n\nclass QUITE_CORE_EXPORT ObjectQueryBuilder\n{\n    std::shared_ptr&lt;ObjectQuery&gt; query_;\n\n  public:\n    ObjectQueryBuilder();\n\n    ObjectQueryBuilder &amp;with_property(std::initializer_list&lt;std::pair&lt;std::string, entt::meta_any&gt;&gt; props);\n\n    ObjectQueryBuilder &amp;with_property(std::string key, std::int64_t value);\n\n    ObjectQueryBuilder &amp;with_property(std::string key, std::uint64_t value);\n\n    ObjectQueryBuilder &amp;with_property(std::string key, double value);\n\n    ObjectQueryBuilder &amp;with_property(std::string key, bool value);\n\n    ObjectQueryBuilder &amp;with_property(std::string key, std::string value);\n\n    ObjectQueryBuilder &amp;with_parent(std::shared_ptr&lt;ObjectQuery&gt; parent);\n\n    ObjectQueryBuilder &amp;with_type(std::string type_name);\n\n    operator std::shared_ptr&lt;ObjectQuery&gt;() const;\n\n  private:\n    friend ObjectQuery;\n};\n\n// Factory function\nQUITE_CORE_EXPORT ObjectQueryBuilder make_query();\n\n} // namespace quite\ntemplate &lt;&gt;\nstruct QUITE_CORE_EXPORT fmt::formatter&lt;quite::ObjectQuery&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const quite::ObjectQuery &amp;query, format_context &amp;ctx) const -&gt; format_context::iterator;\n};\n</code></pre>"},{"location":"quite/value__registry_8hpp/","title":"File value_registry.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; value &gt; value_registry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/container/dense_map.hpp&gt;</code></li> <li><code>#include &lt;entt/core/hashed_string.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/context.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/value__registry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/value__registry_8hpp/#classes","title":"Classes","text":"Type Name class ValueRegistry <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/value/value_registry.hpp</code></p>"},{"location":"quite/value__registry_8hpp_source/","title":"File value_registry.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; value &gt; value_registry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/container/dense_map.hpp&gt;\n#include &lt;entt/core/hashed_string.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;entt/meta/context.hpp&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\nclass QUITE_CORE_EXPORT ValueRegistry\n{\n  public:\n    using PropertyNameMap = entt::dense_map&lt;entt::id_type, std::string&gt;;\n\n  public:\n    entt::id_type named_property(std::string name);\n    const PropertyNameMap &amp;property_names() const;\n    entt::meta_ctx &amp;context() const;\n\n  private:\n    PropertyNameMap name_db_;\n    entt::meta_ctx &amp;context_ = entt::locator&lt;entt::meta_ctx&gt;::value_or();\n};\n} // namespace quite\n</code></pre>"},{"location":"quite/logger_8hpp/","title":"File logger.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quill/LogMacros.h&gt;</code></li> <li><code>#include &lt;quill/Logger.h&gt;</code></li> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/logger_8hpp/#macros","title":"Macros","text":"Type Name define DEFINE_LOGGER (name) <code>/* multi line expression */</code>"},{"location":"quite/logger_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/logger_8hpp/#define-define_logger","title":"define DEFINE_LOGGER","text":"<pre><code>#define DEFINE_LOGGER (\n    name\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/logger.hpp</code></p>"},{"location":"quite/logger_8hpp_source/","title":"File logger.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quill/LogMacros.h&gt;\n#include &lt;quill/Logger.h&gt;\n#include \"quite/quite_core_export.hpp\"\n\nnamespace quite\n{\nQUITE_CORE_EXPORT quill::Logger *create_logger(std::string_view logger_name);\n}\n\n#define DEFINE_LOGGER(name)                                                                                            \\\n    namespace                                                                                                          \\\n    {                                                                                                                  \\\n    auto name()                                                                                                        \\\n    {                                                                                                                  \\\n        static const auto &amp;&amp;name_logger = ::quite::create_logger(#name);                                               \\\n        return name_logger;                                                                                            \\\n    }                                                                                                                  \\\n    }\n</code></pre>"},{"location":"quite/meta__any__formatter_8hpp/","title":"File meta_any_formatter.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; meta_any_formatter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> <li><code>#include \"quite/value/generic_value_class.hpp\"</code></li> </ul>"},{"location":"quite/meta__any__formatter_8hpp/#classes","title":"Classes","text":"Type Name struct formatter&lt; entt::meta_any &gt; &lt;&gt; <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/meta_any_formatter.hpp</code></p>"},{"location":"quite/meta__any__formatter_8hpp_source/","title":"File meta_any_formatter.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; meta_any_formatter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;fmt/core.h&gt;\n#include &lt;fmt/ranges.h&gt;\n#include \"quite/value/generic_value_class.hpp\"\n\ntemplate &lt;&gt;\nstruct fmt::formatter&lt;entt::meta_any&gt; : fmt::formatter&lt;std::string_view&gt;\n{\n    auto format(const entt::meta_any &amp;value, format_context &amp;ctx) const -&gt; format_context::iterator\n    {\n        const auto type = value.type();\n\n        fmt::format_to(ctx.out(), \"any(type={}: value=\", type.info().name());\n        auto value_printer = [&amp;value, &amp;type]() {\n            if (type.is_arithmetic())\n            {\n                return fmt::format(\"{}\", value.allow_cast&lt;double&gt;().cast&lt;double&gt;());\n            }\n            if (type.is_sequence_container())\n            {\n                return fmt::format(\"{}\", value.as_sequence_container());\n            }\n            if (type.is_associative_container())\n            {\n                return fmt::format(\"{}\", value.as_associative_container());\n            }\n            if (type.is_class())\n            {\n                if (type.info() == entt::type_id&lt;std::string&gt;())\n                {\n                    return value.cast&lt;std::string&gt;();\n                }\n                if (type.info() == entt::type_id&lt;quite::GenericClass&gt;())\n                {\n                    return std::string{\"todo\"};\n                }\n                return std::string{\"no-formatter\"};\n            }\n            return std::string{\"unknown\"};\n        };\n        return fmt::format_to(ctx.out(),\n                              \"any(type_id={}, name={} value={})\",\n                              value.type().id(),\n                              value.type().info().name(),\n                              value_printer());\n    }\n};\n</code></pre>"},{"location":"quite/result_8hpp/","title":"File result.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; result.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;expected&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> </ul>"},{"location":"quite/result_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/result.hpp</code></p>"},{"location":"quite/result_8hpp_source/","title":"File result.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; result.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;expected&gt;\n#include \"error.hpp\"\n\nnamespace quite\n{\n\ntemplate &lt;typename T&gt;\nusing Result = std::expected&lt;T, Error&gt;;\n\ntemplate &lt;typename MessageT&gt;\nconstexpr auto make_error_result(const ErrorCode code, MessageT &amp;&amp;message)\n{\n    return std::unexpected{Error{.code = code, .message = std::forward&lt;MessageT&gt;(message)}};\n}\n\n} // namespace quite\n</code></pre>"},{"location":"quite/service__handle_8hpp/","title":"File service_handle.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; service_handle.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"quite/service__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/service__handle_8hpp/#classes","title":"Classes","text":"Type Name class ServiceHandle &lt;typename T&gt;A lightweight handle for accessing shared service instances. <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/service_handle.hpp</code></p>"},{"location":"quite/service__handle_8hpp_source/","title":"File service_handle.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; service_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n\nnamespace quite\n{\n\ntemplate &lt;typename T&gt;\nclass ServiceHandle\n{\n  public:\n    using Type = T;\n\n    ServiceHandle() = default;\n\n    explicit ServiceHandle(std::shared_ptr&lt;T&gt; service)\n        : service_{std::move(service)}\n    {}\n\n    template &lt;typename... Args&gt;\n    explicit ServiceHandle(std::in_place_t /*_*/, Args &amp;&amp;...args)\n        : service_{std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...)}\n    {}\n\n    T *operator-&gt;() const\n    {\n        return service_.get();\n    }\n\n    T &amp;operator*() const\n    {\n        return *service_;\n    }\n\n    explicit operator bool() const\n    {\n        return service_ != nullptr;\n    }\n\n  private:\n    std::shared_ptr&lt;T&gt; service_;\n};\n\n} // namespace quite\n</code></pre>"},{"location":"quite/setup__logger_8hpp/","title":"File setup_logger.hpp","text":"<p>FileList &gt; core &gt; include &gt; quite &gt; setup_logger.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/quite_core_export.hpp\"</code></li> </ul>"},{"location":"quite/setup__logger_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/include/quite/setup_logger.hpp</code></p>"},{"location":"quite/setup__logger_8hpp_source/","title":"File setup_logger.hpp","text":"<p>File List &gt; core &gt; include &gt; quite &gt; setup_logger.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"quite/quite_core_export.hpp\"\nnamespace quite\n{\nQUITE_CORE_EXPORT void setup_logger(bool log_to_file = false);\n}\n</code></pre>"},{"location":"quite/dir_232ab8dc75117fda122ab855789b1b2c/","title":"Dir libs/core/src","text":"<p>FileList &gt; core &gt; src</p>"},{"location":"quite/dir_232ab8dc75117fda122ab855789b1b2c/#files","title":"Files","text":"Type Name file asio_context.cpp file error.cpp file image.cpp file image_utils.cpp file logger.cpp"},{"location":"quite/dir_232ab8dc75117fda122ab855789b1b2c/#directories","title":"Directories","text":"Type Name dir meta dir value <p>The documentation for this class was generated from the following file <code>libs/core/src/</code></p>"},{"location":"quite/asio__context_8cpp/","title":"File asio_context.cpp","text":"<p>FileList &gt; core &gt; src &gt; asio_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;execpools/asio/asio_thread_pool.hpp&gt;</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> </ul>"},{"location":"quite/asio__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/src/asio_context.cpp</code></p>"},{"location":"quite/asio__context_8cpp_source/","title":"File asio_context.cpp","text":"<p>File List &gt; core &gt; src &gt; asio_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;execpools/asio/asio_thread_pool.hpp&gt;\n#include &lt;quite/asio_context.hpp&gt;\n\nnamespace quite\n{\nexecpools::asio_thread_pool &amp;thread_pool()\n{\n    return entt::locator&lt;execpools::asio_thread_pool&gt;::value_or(2);\n}\n\nauto get_executor() -&gt; decltype(thread_pool().get_executor())\n{\n    return thread_pool().get_executor();\n}\n} // namespace quite\n</code></pre>"},{"location":"quite/error_8cpp/","title":"File error.cpp","text":"<p>FileList &gt; core &gt; src &gt; error.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/error.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>libs/core/src/error.cpp</code></p>"},{"location":"quite/error_8cpp_source/","title":"File error.cpp","text":"<p>File List &gt; core &gt; src &gt; error.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/error.hpp\"\n\nauto fmt::formatter&lt;quite::ErrorCode&gt;::format(quite::ErrorCode error_code, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return formatter&lt;string_view&gt;::format(\n        [error_code]() {\n            using quite::ErrorCode;\n            switch (error_code)\n            {\n            case ErrorCode::unknown:\n                return \"unknown\";\n            case ErrorCode::aborted:\n                return \"aborted\";\n            case ErrorCode::cancelled:\n                return \"cancelled\";\n            case ErrorCode::invalid_argument:\n                return \"invalid_argument\";\n            case ErrorCode::deadline_exceeded:\n                return \"deadline_exceeded\";\n            case ErrorCode::not_found:\n                return \"not_found\";\n            case ErrorCode::failed_precondition:\n                return \"failed_precondition\";\n            case ErrorCode::unimplemented:\n                return \"unimplemented\";\n            case ErrorCode::unavailable:\n                return \"unavailable\";\n            }\n            return \"unknown\";\n        }(),\n        ctx);\n}\n\nauto fmt::formatter&lt;quite::Error&gt;::format(const quite::Error &amp;error, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"(error_code: {}: message: {})\", error.code, error.message);\n}\n</code></pre>"},{"location":"quite/image_8cpp/","title":"File image.cpp","text":"<p>FileList &gt; core &gt; src &gt; image.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/image.hpp\"</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;stb_image.h&gt;</code></li> <li><code>#include &lt;stb_image_write.h&gt;</code></li> </ul>"},{"location":"quite/image_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/image_8cpp/#classes","title":"Classes","text":"Type Name class Impl"},{"location":"quite/image_8cpp/#macros","title":"Macros","text":"Type Name define STB_IMAGE_IMPLEMENTATION define STB_IMAGE_WRITE_IMPLEMENTATION"},{"location":"quite/image_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/image_8cpp/#define-stb_image_implementation","title":"define STB_IMAGE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_IMPLEMENTATION \n</code></pre>"},{"location":"quite/image_8cpp/#define-stb_image_write_implementation","title":"define STB_IMAGE_WRITE_IMPLEMENTATION","text":"<pre><code>#define STB_IMAGE_WRITE_IMPLEMENTATION \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/src/image.cpp</code></p>"},{"location":"quite/image_8cpp_source/","title":"File image.cpp","text":"<p>File List &gt; core &gt; src &gt; image.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/image.hpp\"\n#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#define STB_IMAGE_IMPLEMENTATION\n#include &lt;stb_image.h&gt;\n#include &lt;stb_image_write.h&gt;\n\nnamespace quite\n{\nclass Image::Impl final\n{\n  public:\n    explicit Impl(std::vector&lt;std::byte&gt; image_data, std::uint32_t width, std::uint32_t height, int channels)\n        : image_data_{std::move(image_data)}\n        , width_{width}\n        , height_{height}\n        , channels_{channels}\n    {}\n\n    ~Impl() = default;\n\n  public:\n    std::vector&lt;std::byte&gt; image_data_;\n    std::uint32_t width_;\n    std::uint32_t height_;\n    int channels_;\n};\n\nImage::Image()\n    : impl_{std::make_unique&lt;Impl&gt;(std::vector&lt;std::byte&gt;{}, 0, 0, 0)}\n{}\n\nImage::Image(std::vector&lt;std::byte&gt; image_data, std::uint32_t width, std::uint32_t height, int channels)\n    : impl_{std::make_unique&lt;Impl&gt;(std::move(image_data), width, height, channels)}\n{}\n\nImage::Image(const std::filesystem::path &amp;filename)\n{\n    int w, h, channels;\n    auto *data = stbi_load(filename.c_str(), &amp;w, &amp;h, &amp;channels, 0);\n    if (data != nullptr)\n    {\n        const size_t image_size = w * h * channels;\n        std::vector&lt;std::byte&gt; image_data{reinterpret_cast&lt;std::byte *&gt;(data),\n                                          reinterpret_cast&lt;std::byte *&gt;(data) + image_size};\n        stbi_image_free(data);\n        impl_ = std::make_unique&lt;Impl&gt;(std::move(image_data), w, h, channels);\n    }\n    else\n    {\n        impl_ = std::make_unique&lt;Impl&gt;(std::vector&lt;std::byte&gt;{}, 0, 0, 0);\n    }\n}\n\nImage::Image(Image &amp;&amp;other) noexcept\n    : impl_{std::exchange(other.impl_, nullptr)}\n{}\n\nImage &amp;Image::operator=(Image &amp;&amp;other) noexcept\n{\n    impl_ = std::exchange(other.impl_, nullptr);\n    return *this;\n}\n\nImage::Image(const Image &amp;other)\n    : Image{}\n{\n    *this = other;\n}\n\nImage &amp;Image::operator=(const Image &amp;other)\n{\n    if (this == &amp;other)\n    {\n        return *this;\n    }\n    std::ranges::copy(other.impl_-&gt;image_data_, std::back_inserter(impl_-&gt;image_data_));\n    this-&gt;impl_-&gt;channels_ = other.impl_-&gt;channels_;\n    this-&gt;impl_-&gt;width_ = other.impl_-&gt;width_;\n    this-&gt;impl_-&gt;height_ = other.impl_-&gt;height_;\n    return *this;\n}\n\nImage::~Image() = default;\n\nvoid Image::save_to(const std::filesystem::path &amp;destination) const\n{\n    const bool written = stbi_write_png(destination.c_str(),\n                                        impl_-&gt;width_,\n                                        impl_-&gt;height_,\n                                        impl_-&gt;channels_,\n                                        impl_-&gt;image_data_.data(),\n                                        impl_-&gt;width_ * impl_-&gt;channels_);\n}\n\nImageView Image::data() const\n{\n    return ImageView{\n        .width = impl_-&gt;width_,\n        .height = impl_-&gt;height_,\n        .channels = impl_-&gt;channels_,\n        .data = impl_-&gt;image_data_,\n    };\n}\n} // namespace quite\n</code></pre>"},{"location":"quite/image__utils_8cpp/","title":"File image_utils.cpp","text":"<p>FileList &gt; core &gt; src &gt; image_utils.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/image_utils.hpp\"</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"quite/image__utils_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/src/image_utils.cpp</code></p>"},{"location":"quite/image__utils_8cpp_source/","title":"File image_utils.cpp","text":"<p>File List &gt; core &gt; src &gt; image_utils.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/image_utils.hpp\"\n#include &lt;cstddef&gt;\n#include &lt;utility&gt;\nnamespace quite\n{\nnamespace\n{\nconstexpr bool is_pixel_data(const PixelData data)\n{\n    return !data.empty();\n}\n\nconstexpr auto rgb2y(uint8_t r, uint8_t g, uint8_t b)\n{\n    return (r * 0.29889531) + (g * 0.58662247) + (b * 0.11448223);\n}\n\nconstexpr auto rgb2i(uint8_t r, uint8_t g, uint8_t b)\n{\n    return (r * 0.59597799) - (g * 0.27417610) - (b * 0.32180189);\n}\n\nconstexpr auto rgb2q(uint8_t r, uint8_t g, uint8_t b)\n{\n    return (r * 0.21147017) - (g * 0.52261711) + (b * 0.31114694);\n}\n\nconstexpr uint8_t blend(double c, double a)\n{\n    return static_cast&lt;uint8_t&gt;(255 + ((c - 255) * a));\n}\n\nconstexpr void draw_pixel(PixelData output, size_t pos, uint8_t r, uint8_t g, uint8_t b)\n{\n    output[pos + 0] = std::byte{r};\n    output[pos + 1] = std::byte{g};\n    output[pos + 2] = std::byte{b};\n    output[pos + 3] = std::byte{255};\n}\n\nconstexpr void draw_gray_pixel(const PixelData img, int i, double alpha, PixelData output)\n{\n    const auto r = img[i + 0];\n    const auto g = img[i + 1];\n    const auto b = img[i + 2];\n    auto val = blend(rgb2y(static_cast&lt;uint8_t&gt;(r), static_cast&lt;uint8_t&gt;(g), static_cast&lt;uint8_t&gt;(b)),\n                     alpha * static_cast&lt;uint8_t&gt;(img[i + 3]) / 255.0);\n    draw_pixel(output, i, val, val, val);\n}\n\nconstexpr double color_delta(const PixelData img1, const PixelData img2, int k, int m, bool yOnly = false)\n{\n    uint8_t r1 = static_cast&lt;uint8_t&gt;(img1[k + 0]);\n    uint8_t g1 = static_cast&lt;uint8_t&gt;(img1[k + 1]);\n    uint8_t b1 = static_cast&lt;uint8_t&gt;(img1[k + 2]);\n    uint8_t a1 = static_cast&lt;uint8_t&gt;(img1[k + 3]);\n    uint8_t r2 = static_cast&lt;uint8_t&gt;(img2[m + 0]);\n    uint8_t g2 = static_cast&lt;uint8_t&gt;(img2[m + 1]);\n    uint8_t b2 = static_cast&lt;uint8_t&gt;(img2[m + 2]);\n    uint8_t a2 = static_cast&lt;uint8_t&gt;(img2[m + 3]);\n\n    if (a1 == a2 &amp;&amp; r1 == r2 &amp;&amp; g1 == g2 &amp;&amp; b1 == b2)\n    {\n        return 0;\n    }\n\n    if (a1 &lt; 255)\n    {\n        double a1d = a1 / 255.0;\n        r1 = blend(r1, a1d);\n        g1 = blend(g1, a1d);\n        b1 = blend(b1, a1d);\n    }\n\n    if (a2 &lt; 255)\n    {\n        double a2d = a2 / 255.0;\n        r2 = blend(r2, a2d);\n        g2 = blend(g2, a2d);\n        b2 = blend(b2, a2d);\n    }\n\n    const double y1 = rgb2y(r1, g1, b1);\n    const double y2 = rgb2y(r2, g2, b2);\n    const double y = y1 - y2;\n\n    if (yOnly)\n    {\n        return y;\n    }\n\n    const auto i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);\n    const auto q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    const auto delta = (0.5053 * y * y) + (0.299 * i * i) + (0.1957 * q * q);\n    return y1 &gt; y2 ? -delta : delta;\n}\n\nconstexpr bool has_many_siblings(const PixelData img, int x1, int y1, int width, int height)\n{\n    const int x0 = std::max(x1 - 1, 0);\n    const int y0 = std::max(y1 - 1, 0);\n    const int x2 = std::min(x1 + 1, width - 1);\n    const int y2 = std::min(y1 + 1, height - 1);\n    const auto pos = (y1 * width + x1) * 4;\n    int zeroes = (x1 == x0 || x1 == x2 || y1 == y0 || y1 == y2) ? 1 : 0;\n\n    for (auto x = x0; x &lt;= x2; x++)\n    {\n        for (auto y = y0; y &lt;= y2; y++)\n        {\n            if (x == x1 &amp;&amp; y == y1)\n            {\n                continue;\n            }\n\n            auto pos2 = (y * width + x) * 4;\n            if (img[pos] == img[pos2] &amp;&amp; img[pos + 1] == img[pos2 + 1] &amp;&amp; img[pos + 2] == img[pos2 + 2] &amp;&amp;\n                img[pos + 3] == img[pos2 + 3])\n            {\n                zeroes++;\n            }\n\n            if (zeroes &gt; 2)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nconstexpr bool antialiased(const PixelData img, int x1, int y1, int width, int height, const PixelData img2)\n{\n    int x0 = std::max(x1 - 1, 0);\n    int y0 = std::max(y1 - 1, 0);\n    int x2 = std::min(x1 + 1, width - 1);\n    int y2 = std::min(y1 + 1, height - 1);\n    size_t pos = (y1 * width + x1) * 4;\n    int zeroes = (x1 == x0 || x1 == x2 || y1 == y0 || y1 == y2) ? 1 : 0;\n    double min = 0;\n    double max = 0;\n    int minX = 0;\n    int minY = 0;\n    int maxX = 0;\n    int maxY = 0;\n\n    for (int x = x0; x &lt;= x2; x++)\n    {\n        for (int y = y0; y &lt;= y2; y++)\n        {\n            if (x == x1 &amp;&amp; y == y1)\n            {\n                continue;\n            }\n\n            const auto delta = color_delta(img, img, pos, (y * width + x) * 4, true);\n\n            if (delta == 0)\n            {\n                zeroes++;\n                if (zeroes &gt; 2)\n                {\n                    return false;\n                }\n            }\n            else if (delta &lt; min)\n            {\n                min = delta;\n                minX = x;\n                minY = y;\n            }\n            else if (delta &gt; max)\n            {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    if (min == 0 || max == 0)\n    {\n        return false;\n    }\n\n    return (has_many_siblings(img, minX, minY, width, height) &amp;&amp; has_many_siblings(img2, minX, minY, width, height)) ||\n           (has_many_siblings(img, maxX, maxY, width, height) &amp;&amp; has_many_siblings(img2, maxX, maxY, width, height));\n}\n\n} // namespace\n\nResult&lt;ImageCompareResult&gt; pixel_match(const ImageView &amp;expected_img,\n                                       const ImageView &amp;actual_img,\n                                       const PixelCompareOptions &amp;options)\n{\n    std::vector&lt;std::byte&gt; out_image_data{\n        static_cast&lt;size_t&gt;(actual_img.width * actual_img.height * actual_img.channels)};\n\n    ImageCompareResult result{\n        .diff_image = Image{std::move(out_image_data), actual_img.width, actual_img.height, actual_img.channels},\n    };\n    auto &amp;output_image = result.diff_image;\n\n    if (!is_pixel_data(expected_img.data) || !is_pixel_data(actual_img.data) ||\n        (!is_pixel_data(output_image.data().data)))\n    {\n        return make_error_result(ErrorCode::failed_precondition, \"Some image is empty\");\n    }\n\n    if (expected_img.data.size() != actual_img.data.size())\n    {\n        return make_error_result(ErrorCode::failed_precondition, \"Image sizes do not match.\");\n    }\n\n    // check if images are identical\n    const bool identical = std::equal(expected_img.data.cbegin(), expected_img.data.cend(), actual_img.data.cbegin());\n    if (identical)\n    {\n        if (!options.diff_mask)\n        {\n            for (size_t i = 0; i &lt; (static_cast&lt;size_t&gt;(actual_img.width * actual_img.height)); i++)\n            {\n                draw_gray_pixel(actual_img.data, actual_img.channels * i, options.alpha, output_image.data().data);\n            }\n        }\n        return result;\n    }\n\n    double maxDelta = 35215 * options.threshold * options.threshold;\n    auto &amp;&amp;aaColor = options.anti_aliased_color;\n    auto &amp;&amp;diffColor = options.diff_color;\n    auto &amp;&amp;diffColorAlt = options.diff_color_alt.has_value() ? *options.diff_color_alt : options.diff_color;\n    int &amp;diff = result.diff;\n\n    for (int y = 0; y &lt; actual_img.height; y++)\n    {\n        for (int x = 0; x &lt; actual_img.width; x++)\n        {\n            const size_t pos = (y * actual_img.width + x) * actual_img.channels;\n            const double delta = color_delta(expected_img.data, actual_img.data, pos, pos);\n            if (std::abs(delta) &gt; maxDelta)\n            {\n                if (!options.skip_anti_aliasing &amp;&amp;\n                    (antialiased(expected_img.data, x, y, expected_img.width, expected_img.height, actual_img.data) ||\n                     antialiased(actual_img.data, x, y, expected_img.width, expected_img.height, expected_img.data)))\n                {\n                    if (!options.diff_mask)\n                    {\n                        draw_pixel(output_image.data().data, pos, aaColor[0], aaColor[1], aaColor[2]);\n                    }\n                }\n                else\n                {\n                    if (delta &lt; 0)\n                    {\n                        draw_pixel(output_image.data().data, pos, diffColorAlt[0], diffColorAlt[1], diffColorAlt[2]);\n                    }\n                    else\n                    {\n                        draw_pixel(output_image.data().data, pos, diffColor[0], diffColor[1], diffColor[2]);\n                    }\n                    diff++;\n                }\n            }\n            else if (!options.diff_mask)\n            {\n                draw_gray_pixel(expected_img.data, pos, options.alpha, output_image.data().data);\n            }\n        }\n    }\n    return result;\n}\n\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_dc23c1f860ba56840f37028d447c4fe9/","title":"Dir libs/core/src/meta","text":"<p>FileList &gt; core &gt; src &gt; meta</p>"},{"location":"quite/dir_dc23c1f860ba56840f37028d447c4fe9/#files","title":"Files","text":"Type Name file meta_types.cpp <p>The documentation for this class was generated from the following file <code>libs/core/src/meta/</code></p>"},{"location":"quite/meta__types_8cpp/","title":"File meta_types.cpp","text":"<p>FileList &gt; core &gt; src &gt; meta &gt; meta_types.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/meta/meta_types.hpp\"</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>libs/core/src/meta/meta_types.cpp</code></p>"},{"location":"quite/meta__types_8cpp_source/","title":"File meta_types.cpp","text":"<p>File List &gt; core &gt; src &gt; meta &gt; meta_types.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/meta/meta_types.hpp\"\n#include &lt;utility&gt;\n#include &lt;fmt/ranges.h&gt;\n\nnamespace\n{\nstruct FormatVisitor\n{\n    template &lt;typename T&gt;\n    auto operator()(const std::unique_ptr&lt;T&gt; &amp;type)\n    {\n        return fmt::format(\"{}\", *type);\n    }\n\n    auto operator()(auto &amp;&amp;type)\n    {\n        return fmt::format(\"{}\", type);\n    }\n};\n} // namespace\n\nauto fmt::formatter&lt;quite::meta::Property&gt;::format(const quite::meta::Property &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"Property(name={}, type_id={})\", type.name, type.type);\n}\n\nauto fmt::formatter&lt;quite::meta::Method&gt;::format(const quite::meta::Method &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(\n        ctx.out(), \"Method(name={}, returns={}, parameters={})\", type.name, type.return_type, type.parameters);\n}\n\nauto fmt::formatter&lt;quite::meta::ObjectType&gt;::format(const quite::meta::ObjectType &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(),\n                          \"ObjectType(name={}, type_id={}, properties={}, constructors={}, methods={})\",\n                          type.name,\n                          type.id,\n                          type.properties,\n                          type.constructors,\n                          type.methods);\n}\n\nauto fmt::formatter&lt;quite::meta::MapType&gt;::format(const quite::meta::MapType &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(\n        ctx.out(), \"MapType(name={}, id={} key={}, value={})\", type.name, type.id, type.key_type, type.value_type);\n}\n\nauto fmt::formatter&lt;quite::meta::ListType&gt;::format(const quite::meta::ListType &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"ListType(name={}, id={}, type_id={})\", type.name, type.id, type.value_type);\n}\n\nauto fmt::formatter&lt;quite::meta::EnumType&gt;::format(const quite::meta::EnumType &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"EnumType(name={}, id={}, values={})\", type.name, type.id, type.values);\n}\n\nauto fmt::formatter&lt;quite::meta::PrimitiveType&gt;::format(const quite::meta::PrimitiveType &amp;type,\n                                                        format_context &amp;ctx) const -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"PrimitiveType::{}\", std::to_underlying(type));\n}\n\nauto fmt::formatter&lt;quite::meta::Type&gt;::format(const quite::meta::Type &amp;type, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    return fmt::format_to(ctx.out(), \"Type({})\", std::visit(FormatVisitor{}, type));\n}\n</code></pre>"},{"location":"quite/dir_0eca0b5bd173d9114e1516dc11ca978d/","title":"Dir libs/core/src/value","text":"<p>FileList &gt; core &gt; src &gt; value</p>"},{"location":"quite/dir_0eca0b5bd173d9114e1516dc11ca978d/#files","title":"Files","text":"Type Name file object_query.cpp file value_registry.cpp <p>The documentation for this class was generated from the following file <code>libs/core/src/value/</code></p>"},{"location":"quite/object__query_8cpp/","title":"File object_query.cpp","text":"<p>FileList &gt; core &gt; src &gt; value &gt; object_query.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/value/object_query.hpp\"</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> <li><code>#include \"quite/meta_any_formatter.hpp\"</code></li> </ul>"},{"location":"quite/object__query_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/src/value/object_query.cpp</code></p>"},{"location":"quite/object__query_8cpp_source/","title":"File object_query.cpp","text":"<p>File List &gt; core &gt; src &gt; value &gt; object_query.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/value/object_query.hpp\"\n#include &lt;fmt/ranges.h&gt;\n#include \"quite/meta_any_formatter.hpp\"\n\nnamespace quite\n{\nObjectQueryBuilder::ObjectQueryBuilder()\n    : query_(std::make_shared&lt;ObjectQuery&gt;())\n{}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(\n    std::initializer_list&lt;std::pair&lt;std::string, entt::meta_any&gt;&gt; props)\n{\n    for (const auto &amp;[key, val] : props)\n    {\n        query_-&gt;properties.emplace(key, val);\n    }\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(std::string key, std::int64_t value)\n{\n    query_-&gt;properties.insert_or_assign(std::move(key), std::move(value));\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(std::string key, std::uint64_t value)\n{\n    query_-&gt;properties.insert_or_assign(std::move(key), std::move(value));\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(std::string key, double value)\n{\n    query_-&gt;properties.insert_or_assign(std::move(key), std::move(value));\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(std::string key, bool value)\n{\n    query_-&gt;properties.insert_or_assign(std::move(key), std::move(value));\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_property(std::string key, std::string value)\n{\n    query_-&gt;properties.insert_or_assign(std::move(key), std::move(value));\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_parent(std::shared_ptr&lt;ObjectQuery&gt; parent)\n{\n    query_-&gt;container = std::move(parent);\n    return *this;\n}\n\nObjectQueryBuilder &amp;ObjectQueryBuilder::with_type(std::string type_name)\n{\n    query_-&gt;type_name = std::move(type_name);\n    return *this;\n}\n\nObjectQueryBuilder::operator std::shared_ptr&lt;ObjectQuery&gt;() const\n{\n    return query_;\n}\n\nObjectQueryBuilder make_query()\n{\n    return ObjectQueryBuilder{};\n}\n\nObjectQuery::ObjectQuery(const ObjectQueryBuilder &amp;builder)\n    : container{builder.query_-&gt;container}\n    , properties{builder.query_-&gt;properties}\n    , type_name{builder.query_-&gt;type_name}\n{}\n} // namespace quite\n\nauto fmt::formatter&lt;quite::ObjectQuery&gt;::format(const quite::ObjectQuery &amp;query, format_context &amp;ctx) const\n    -&gt; format_context::iterator\n{\n    constexpr std::string_view kNoneStr{\"none\"};\n    return fmt::format_to(ctx.out(),\n                          \"(container: {}: properties: [{}], type: {})\",\n                          query.container == nullptr ? kNoneStr : fmt::format(\"{}\", *query.container),\n                          fmt::join(query.properties, \":\"),\n                          query.type_name);\n}\n</code></pre>"},{"location":"quite/value__registry_8cpp/","title":"File value_registry.cpp","text":"<p>FileList &gt; core &gt; src &gt; value &gt; value_registry.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/value/value_registry.hpp\"</code></li> </ul>"},{"location":"quite/value__registry_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/src/value/value_registry.cpp</code></p>"},{"location":"quite/value__registry_8cpp_source/","title":"File value_registry.cpp","text":"<p>File List &gt; core &gt; src &gt; value &gt; value_registry.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/value/value_registry.hpp\"\n\nnamespace quite\n{\nentt::id_type ValueRegistry::named_property(std::string name)\n{\n    auto &amp;&amp;[emplaced_name, _] = name_db_.emplace(entt::hashed_string{name.c_str()}.value(), std::move(name));\n    return emplaced_name-&gt;first;\n}\n\nconst ValueRegistry::PropertyNameMap &amp;ValueRegistry::property_names() const\n{\n    return name_db_;\n}\n\nentt::meta_ctx &amp;ValueRegistry::context() const\n{\n    return context_;\n}\n} // namespace quite\n</code></pre>"},{"location":"quite/logger_8cpp/","title":"File logger.cpp","text":"<p>FileList &gt; core &gt; src &gt; logger.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quill/Backend.h&gt;</code></li> <li><code>#include &lt;quill/Frontend.h&gt;</code></li> <li><code>#include &lt;quill/sinks/ConsoleSink.h&gt;</code></li> <li><code>#include &lt;quill/sinks/FileSink.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> </ul>"},{"location":"quite/logger_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/core/src/logger.cpp</code></p>"},{"location":"quite/logger_8cpp_source/","title":"File logger.cpp","text":"<p>File List &gt; core &gt; src &gt; logger.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;quill/Backend.h&gt;\n#include &lt;quill/Frontend.h&gt;\n#include &lt;quill/sinks/ConsoleSink.h&gt;\n#include &lt;quill/sinks/FileSink.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n\nnamespace quite\n{\nquill::Logger *create_logger(std::string_view logger_name)\n{\n    try\n    {\n        auto default_sink = quill::Frontend::get_sink(\"default_sink\");\n        auto &amp;&amp;logger = quill::Frontend::create_or_get_logger(std::string{logger_name}, std::move(default_sink));\n        logger-&gt;set_log_level(quill::LogLevel::Debug);\n\n        return logger;\n    }\n    catch (const quill::QuillError &amp;ex)\n    {\n        auto default_sink = quill::Frontend::create_or_get_sink&lt;quill::ConsoleSink&gt;(\"default_sink\");\n        auto &amp;&amp;logger = quill::Frontend::create_or_get_logger(std::string{logger_name}, std::move(default_sink));\n        logger-&gt;set_log_level(quill::LogLevel::Debug);\n\n        LOG_CRITICAL(logger, \"Did you forget to call quite::setup_logger()? Error: {}\", ex.what());\n\n        return logger;\n    }\n}\n\nvoid setup_logger(bool log_to_file)\n{\n    quill::Backend::start();\n    quill::Frontend::preallocate();\n    auto default_sink = [log_to_file]() {\n        if (log_to_file)\n        {\n            return quill::Frontend::create_or_get_sink&lt;quill::FileSink&gt;(\n                \"default_sink\",\n                []() {\n                    quill::FileSinkConfig cfg;\n                    cfg.set_open_mode('w');\n                    // cfg.set_filename_append_option(quill::FilenameAppendOption::StartDateTime);\n                    return cfg;\n                }(),\n                quill::FileEventNotifier{});\n        }\n        return quill::Frontend::create_or_get_sink&lt;quill::ConsoleSink&gt;(\"default_sink\");\n    }();\n    auto &amp;&amp;logger = quill::Frontend::create_or_get_logger(\"root\", std::move(default_sink));\n    logger-&gt;set_log_level(quill::LogLevel::Debug);\n\n    LOG_INFO(logger, \"logging finished setup\");\n}\n\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_57af785f642af5d82b5c3ebf8a595104/","title":"Dir libs/core/test","text":"<p>FileList &gt; core &gt; test</p>"},{"location":"quite/dir_57af785f642af5d82b5c3ebf8a595104/#files","title":"Files","text":"Type Name file main.cpp file test_error.cpp <p>The documentation for this class was generated from the following file <code>libs/core/test/</code></p>"},{"location":"quite/core_2test_2main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; core &gt; test &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> </ul>"},{"location":"quite/core_2test_2main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, const char ** argv)"},{"location":"quite/core_2test_2main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/core_2test_2main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char ** argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/test/main.cpp</code></p>"},{"location":"quite/core_2test_2main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; core &gt; test &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/ut.hpp&gt;\nusing namespace boost::ut;\nint main(int argc, const char **argv)\n{\n    boost::ut::detail::cfg::parse_arg_with_fallback(argc, argv);\n}\n</code></pre>"},{"location":"quite/test__error_8cpp/","title":"File test_error.cpp","text":"<p>FileList &gt; core &gt; test &gt; test_error.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> </ul>"},{"location":"quite/test__error_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace string_view_literals"},{"location":"quite/test__error_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"core::error\"&gt; _   = <code>/* multi line expression */</code>"},{"location":"quite/test__error_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__error_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"core::error\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/core/test/test_error.cpp</code></p>"},{"location":"quite/test__error_8cpp_source/","title":"File test_error.cpp","text":"<p>File List &gt; core &gt; test &gt; test_error.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/ut.hpp&gt;\n#include &lt;quite/error.hpp&gt;\n\nusing namespace quite;\nusing namespace boost::ut;\nusing namespace std::literals::string_view_literals;\n\nstatic suite&lt;\"core::error\"&gt; _ = [] {\n    \"formatting\"_test = [] {\n        const quite::Error error{\n            .code = quite::ErrorCode::deadline_exceeded,\n            .message = \"test message\",\n        };\n        expect(that % \"(error_code: deadline_exceeded: message: test message)\"sv == fmt::format(\"{}\", error));\n    };\n};\n</code></pre>"},{"location":"quite/version_8hpp_8in/","title":"File version.hpp.in","text":"<p>FileList &gt; core &gt; version.hpp.in</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/core/version.hpp.in</code></p>"},{"location":"quite/version_8hpp_8in_source/","title":"File version.hpp.in","text":"<p>File List &gt; core &gt; version.hpp.in</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string_view&gt;\nnamespace quite\n{\ninline constexpr unsigned int kVersionMajor = @PROJECT_VERSION_MAJOR@;\ninline constexpr unsigned int kVersionMinor = @PROJECT_VERSION_MINOR@;\ninline constexpr unsigned int kVersionPatch = @PROJECT_VERSION_PATCH@;\ninline constexpr std::string_view kVersion = \"@PROJECT_VERSION@\";\ninline constexpr std::string_view kGitRef = \"@git_sha@\";\ninline constexpr std::string_view kGitBranch = \"@git_branch@\";\n\n\ninline constexpr std::string_view kRuntimeDir = \"@CMAKE_RUNTIME_OUTPUT_DIRECTORY@\";\n} // namespace protodoc\n</code></pre>"},{"location":"quite/dir_b048ed2415d89a3588bcd07e27f16f41/","title":"Dir libs/manager","text":"<p>FileList &gt; libs &gt; manager</p>"},{"location":"quite/dir_b048ed2415d89a3588bcd07e27f16f41/#directories","title":"Directories","text":"Type Name dir include dir src dir tests <p>The documentation for this class was generated from the following file <code>libs/manager/</code></p>"},{"location":"quite/dir_4016f4d3acd3fc8991c53702cd4dc6d5/","title":"Dir libs/manager/include","text":"<p>FileList &gt; include</p>"},{"location":"quite/dir_4016f4d3acd3fc8991c53702cd4dc6d5/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/manager/include/</code></p>"},{"location":"quite/dir_b37ea4b54adf6aca6f6e7e088c5d43d6/","title":"Dir libs/manager/include/quite","text":"<p>FileList &gt; include &gt; quite</p>"},{"location":"quite/dir_b37ea4b54adf6aca6f6e7e088c5d43d6/#directories","title":"Directories","text":"Type Name dir manager <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/</code></p>"},{"location":"quite/dir_3f8205de661b2b55b021bbc49d05e58b/","title":"Dir libs/manager/include/quite/manager","text":"<p>FileList &gt; include &gt; quite &gt; manager</p>"},{"location":"quite/dir_3f8205de661b2b55b021bbc49d05e58b/#files","title":"Files","text":"Type Name file basic_process_manager.hpp file process.hpp file process_handle.hpp file process_manager.hpp file server.hpp <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/</code></p>"},{"location":"quite/basic__process__manager_8hpp/","title":"File basic_process_manager.hpp","text":"<p>FileList &gt; include &gt; quite &gt; manager &gt; basic_process_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include \"process_handle.hpp\"</code></li> <li><code>#include \"quite/quite_manager_export.hpp\"</code></li> </ul>"},{"location":"quite/basic__process__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/basic__process__manager_8hpp/#classes","title":"Classes","text":"Type Name class BasicProcessManager struct ProcessId <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/basic_process_manager.hpp</code></p>"},{"location":"quite/basic__process__manager_8hpp_source/","title":"File basic_process_manager.hpp","text":"<p>File List &gt; include &gt; quite &gt; manager &gt; basic_process_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;quite/async_result.hpp&gt;\n#include \"process_handle.hpp\"\n#include \"quite/quite_manager_export.hpp\"\n\nnamespace quite::manager\n{\nclass Process;\nstruct QUITE_MANAGER_EXPORT ProcessId\n{\n    std::string name;\n};\n\nclass QUITE_MANAGER_EXPORT BasicProcessManager\n{\n  public:\n    using Environment = std::unordered_map&lt;std::string, std::string&gt;;\n\n    virtual ~BasicProcessManager();\n\n    virtual AsyncResult&lt;ProcessHandle&gt; application(ProcessId name) = 0;\n\n    virtual AsyncResult&lt;ProcessHandle&gt; launch_application(ProcessId id,\n                                                          std::string path_to_application,\n                                                          std::vector&lt;std::string&gt; args,\n                                                          Environment environment) = 0;\n\n    virtual AsyncResult&lt;std::filesystem::path&gt; find_executable(std::filesystem::path exe_name,\n                                                               Environment environment) = 0;\n\n    static ProcessHandle noop_process();\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process_8hpp/","title":"File process.hpp","text":"<p>FileList &gt; include &gt; quite &gt; manager &gt; process.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include \"quite/quite_manager_export.hpp\"</code></li> </ul>"},{"location":"quite/process_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process_8hpp/#classes","title":"Classes","text":"Type Name class Process <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process.hpp</code></p>"},{"location":"quite/process_8hpp_source/","title":"File process.hpp","text":"<p>File List &gt; include &gt; quite &gt; manager &gt; process.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/async_result.hpp&gt;\n#include \"quite/quite_manager_export.hpp\"\nnamespace quite::manager\n{\nclass QUITE_MANAGER_EXPORT Process\n{\n  public:\n    virtual ~Process() = default;\n    virtual bool is_running() = 0;\n    virtual int exit_code() = 0;\n    virtual AsyncResult&lt;int&gt; async_wait_exit() = 0;\n    virtual Result&lt;void&gt; request_exit() = 0;\n    virtual Result&lt;void&gt; terminate() = 0;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__handle_8hpp/","title":"File process_handle.hpp","text":"<p>FileList &gt; include &gt; quite &gt; manager &gt; process_handle.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"quite/quite_manager_export.hpp\"</code></li> </ul>"},{"location":"quite/process__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process__handle_8hpp/#classes","title":"Classes","text":"Type Name class ProcessHandle <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process_handle.hpp</code></p>"},{"location":"quite/process__handle_8hpp_source/","title":"File process_handle.hpp","text":"<p>File List &gt; include &gt; quite &gt; manager &gt; process_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include \"quite/quite_manager_export.hpp\"\n\nnamespace quite::manager\n{\nclass Process;\nclass QUITE_MANAGER_EXPORT ProcessHandle\n{\n  public:\n    explicit ProcessHandle(std::shared_ptr&lt;Process&gt; process);\n    Process &amp;instance();\n    Process *operator-&gt;();\n\n  private:\n    std::shared_ptr&lt;Process&gt; process_;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__manager_8hpp/","title":"File process_manager.hpp","text":"<p>FileList &gt; include &gt; quite &gt; manager &gt; process_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;quite/asio_config.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/result.hpp&gt;</code></li> <li><code>#include \"basic_process_manager.hpp\"</code></li> <li><code>#include \"process_handle.hpp\"</code></li> <li><code>#include \"quite/quite_manager_export.hpp\"</code></li> </ul>"},{"location":"quite/process__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process__manager_8hpp/#classes","title":"Classes","text":"Type Name class ProcessManager <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/process_manager.hpp</code></p>"},{"location":"quite/process__manager_8hpp_source/","title":"File process_manager.hpp","text":"<p>File List &gt; include &gt; quite &gt; manager &gt; process_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;filesystem&gt;\n#include &lt;vector&gt;\n#include &lt;quite/asio_config.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/result.hpp&gt;\n#include \"basic_process_manager.hpp\"\n#include \"process_handle.hpp\"\n#include \"quite/quite_manager_export.hpp\"\n\nnamespace quite::manager\n{\nclass QUITE_MANAGER_EXPORT ProcessManager : public BasicProcessManager\n{\n  public:\n    QUITE_DISABLE_COPY(ProcessManager);\n    QUITE_DEFAULT_MOVE(ProcessManager);\n    explicit ProcessManager(asio_impl::thread_pool::executor_type executor);\n    ~ProcessManager() override;\n\n    AsyncResult&lt;ProcessHandle&gt; application(ProcessId id) override;\n\n    AsyncResult&lt;ProcessHandle&gt; launch_application(ProcessId id,\n                                                  std::string path_to_application,\n                                                  std::vector&lt;std::string&gt; args = {},\n                                                  Environment environment = current_environment()) override;\n\n    static Environment current_environment();\n\n    AsyncResult&lt;std::filesystem::path&gt; find_executable(std::filesystem::path exe_name,\n                                                       Environment environment = current_environment()) override;\n\n  private:\n    struct Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/manager_2include_2quite_2manager_2server_8hpp/","title":"File server.hpp","text":"<p>FileList &gt; include &gt; quite &gt; manager &gt; server.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> </ul>"},{"location":"quite/manager_2include_2quite_2manager_2server_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/manager_2include_2quite_2manager_2server_8hpp/#classes","title":"Classes","text":"Type Name class Server <p>The documentation for this class was generated from the following file <code>libs/manager/include/quite/manager/server.hpp</code></p>"},{"location":"quite/manager_2include_2quite_2manager_2server_8hpp_source/","title":"File server.hpp","text":"<p>File List &gt; include &gt; quite &gt; manager &gt; server.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n\nnamespace quite::manager\n{\nclass Server final\n{\n  public:\n    QUITE_DISABLE_COPY(Server);\n    QUITE_DEFAULT_MOVE(Server);\n\n    Server();\n    ~Server();\n\n  private:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/dir_acad3136c8ed89325e9252603ad8366c/","title":"Dir libs/manager/src","text":"<p>FileList &gt; libs &gt; manager &gt; src</p>"},{"location":"quite/dir_acad3136c8ed89325e9252603ad8366c/#files","title":"Files","text":"Type Name file basic_process_manager.cpp file noop_process.cpp file noop_process.hpp file process_handle.cpp file process_impl.cpp file process_impl.hpp file process_manager.cpp file process_manager_client.cpp file process_manager_client.hpp file remote_process_manager.cpp file remote_process_manager.hpp file server.cpp <p>The documentation for this class was generated from the following file <code>libs/manager/src/</code></p>"},{"location":"quite/basic__process__manager_8cpp/","title":"File basic_process_manager.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; basic_process_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/manager/basic_process_manager.hpp\"</code></li> <li><code>#include \"noop_process.hpp\"</code></li> </ul>"},{"location":"quite/basic__process__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/basic_process_manager.cpp</code></p>"},{"location":"quite/basic__process__manager_8cpp_source/","title":"File basic_process_manager.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; basic_process_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/manager/basic_process_manager.hpp\"\n#include \"noop_process.hpp\"\n\nnamespace quite::manager\n{\nBasicProcessManager::~BasicProcessManager() = default;\n\nProcessHandle BasicProcessManager::noop_process()\n{\n    return ProcessHandle{std::make_shared&lt;NoopProcess&gt;()};\n}\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/noop__process_8cpp/","title":"File noop_process.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; noop_process.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"noop_process.hpp\"</code></li> </ul>"},{"location":"quite/noop__process_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/noop_process.cpp</code></p>"},{"location":"quite/noop__process_8cpp_source/","title":"File noop_process.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; noop_process.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"noop_process.hpp\"\n\nnamespace quite::manager\n{\nbool NoopProcess::is_running()\n{\n    return true;\n}\n\nint NoopProcess::exit_code()\n{\n    return EXIT_SUCCESS;\n}\n\nAsyncResult&lt;int&gt; NoopProcess::async_wait_exit()\n{\n    co_return exit_code();\n}\n\nResult&lt;void&gt; NoopProcess::request_exit()\n{\n    return {};\n}\n\nResult&lt;void&gt; NoopProcess::terminate()\n{\n    return {};\n}\n\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/noop__process_8hpp/","title":"File noop_process.hpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; noop_process.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/manager/process.hpp\"</code></li> </ul>"},{"location":"quite/noop__process_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/noop__process_8hpp/#classes","title":"Classes","text":"Type Name class NoopProcess <p>The documentation for this class was generated from the following file <code>libs/manager/src/noop_process.hpp</code></p>"},{"location":"quite/noop__process_8hpp_source/","title":"File noop_process.hpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; noop_process.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"quite/manager/process.hpp\"\n\nnamespace quite::manager\n{\nclass NoopProcess final : public Process\n{\n  public:\n    bool is_running() override;\n    int exit_code() override;\n    AsyncResult&lt;int&gt; async_wait_exit() override;\n    Result&lt;void&gt; request_exit() override;\n    Result&lt;void&gt; terminate() override;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__handle_8cpp/","title":"File process_handle.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_handle.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/manager/process_handle.hpp\"</code></li> </ul>"},{"location":"quite/process__handle_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_handle.cpp</code></p>"},{"location":"quite/process__handle_8cpp_source/","title":"File process_handle.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_handle.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/manager/process_handle.hpp\"\nnamespace quite::manager\n{\nProcessHandle::ProcessHandle(std::shared_ptr&lt;Process&gt; process)\n    : process_{std::move(process)}\n{}\n\nProcess &amp;ProcessHandle::instance()\n{\n    return *process_;\n}\n\nProcess *ProcessHandle::operator-&gt;()\n{\n    return process_.get();\n}\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__impl_8cpp/","title":"File process_impl.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"process_impl.hpp\"</code></li> <li><code>#include &lt;asioexec/use_sender.hpp&gt;</code></li> </ul>"},{"location":"quite/process__impl_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_impl.cpp</code></p>"},{"location":"quite/process__impl_8cpp_source/","title":"File process_impl.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"process_impl.hpp\"\n#include &lt;asioexec/use_sender.hpp&gt;\n\nusing boost::system::error_code;\nnamespace quite::manager\n{\nProcessImpl::ProcessImpl(boost::process::v2::process &amp;&amp;process)\n    : process_{std::move(process)}\n{}\n\nbool ProcessImpl::is_running()\n{\n    error_code ec;\n    return process_.running(ec);\n}\n\nint ProcessImpl::exit_code()\n{\n    return process_.exit_code();\n}\n\nAsyncResult&lt;int&gt; ProcessImpl::async_wait_exit()\n{\n    auto exit_code = co_await process_.async_wait(asioexec::use_sender);\n    co_return exit_code;\n}\n\nResult&lt;void&gt; ProcessImpl::request_exit()\n{\n    error_code ec;\n    process_.request_exit(ec);\n    return {};\n}\n\nResult&lt;void&gt; ProcessImpl::terminate()\n{\n    error_code ec;\n    process_.terminate(ec);\n    return {};\n}\n\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__impl_8hpp/","title":"File process_impl.hpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_impl.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/process/v2/process.hpp&gt;</code></li> <li><code>#include \"quite/manager/process.hpp\"</code></li> </ul>"},{"location":"quite/process__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process__impl_8hpp/#classes","title":"Classes","text":"Type Name class ProcessImpl <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_impl.hpp</code></p>"},{"location":"quite/process__impl_8hpp_source/","title":"File process_impl.hpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;boost/process/v2/process.hpp&gt;\n#include \"quite/manager/process.hpp\"\n\nnamespace quite::manager\n{\nclass ProcessImpl final : public Process\n{\n  public:\n    explicit ProcessImpl(boost::process::v2::process &amp;&amp;process);\n    bool is_running() override;\n    int exit_code() override;\n    AsyncResult&lt;int&gt; async_wait_exit() override;\n    Result&lt;void&gt; request_exit() override;\n    Result&lt;void&gt; terminate() override;\n\n  private:\n    boost::process::v2::process process_;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__manager_8cpp/","title":"File process_manager.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/manager/process_manager.hpp\"</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;boost/process/environment.hpp&gt;</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> <li><code>#include &lt;fmt/std.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"process_impl.hpp\"</code></li> </ul>"},{"location":"quite/process__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process__manager_8cpp/#classes","title":"Classes","text":"Type Name struct Impl <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_manager.cpp</code></p>"},{"location":"quite/process__manager_8cpp_source/","title":"File process_manager.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/manager/process_manager.hpp\"\n#include &lt;filesystem&gt;\n#include &lt;boost/process/environment.hpp&gt;\n#include &lt;fmt/ranges.h&gt;\n#include &lt;fmt/std.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"process_impl.hpp\"\n\nDEFINE_LOGGER(process_manager)\n\nnamespace bp = boost::process::v2;\n\nnamespace quite::manager\n{\nstruct ProcessManager::Impl\n{\n    quite::asio_impl::any_io_executor executor_;\n    std::unordered_map&lt;std::string, std::shared_ptr&lt;Process&gt;&gt; applications_;\n};\n\nProcessManager::ProcessManager(asio_impl::thread_pool::executor_type executor)\n    : impl_{std::make_unique&lt;Impl&gt;(std::move(executor))}\n{}\n\nProcessManager::~ProcessManager() = default;\n\nAsyncResult&lt;ProcessHandle&gt; ProcessManager::application(const ProcessId id)\n{\n    const auto it = impl_-&gt;applications_.find(id.name);\n    if (it == impl_-&gt;applications_.end())\n    {\n        co_return make_error_result(ErrorCode::not_found,\n                                    fmt::format(\"Process with id '{}' is not present (anymore)\", id.name));\n    }\n    co_return ProcessHandle{it-&gt;second};\n}\n\nAsyncResult&lt;ProcessHandle&gt; ProcessManager::launch_application(ProcessId id,\n                                                              std::string path_to_application,\n                                                              std::vector&lt;std::string&gt; args,\n                                                              Environment environment)\n{\n    try\n    {\n        LOG_DEBUG(process_manager(), \"Trying to launch application {}...\", path_to_application);\n        if (not std::filesystem::exists(path_to_application))\n        {\n            LOG_DEBUG(process_manager(), \"Could not find application as path. Trying to find it in the environment...\");\n            const auto exe_found_in_env = co_await find_executable(path_to_application, environment);\n            if (not exe_found_in_env.has_value())\n            {\n                LOG_ERROR(process_manager(), \"Could not find application as path or in the environment.\");\n                co_return make_error_result(\n                    ErrorCode::not_found,\n                    fmt::format(\"Could not find {} as path or in given environment.\", path_to_application));\n            }\n        }\n\n        bp::process process{impl_-&gt;executor_,\n                            std::move(path_to_application),\n                            std::move(args),\n                            bp::process_environment{std::move(environment)}};\n        auto [app, emplaced] = impl_-&gt;applications_.insert_or_assign(std::move(id.name),\n                                                                     std::make_shared&lt;ProcessImpl&gt;(std::move(process)));\n        if (not emplaced)\n        {\n            LOG_WARNING(process_manager(),\n                        \"A process with id '{}' was already in place. Replaced with the newly launched process.\",\n                        app-&gt;first);\n        }\n        co_return ProcessHandle{app-&gt;second};\n    }\n    catch (const boost::system::system_error &amp;e)\n    {\n        co_return make_error_result(ErrorCode::aborted, e.what());\n    }\n}\n\nProcessManager::Environment ProcessManager::current_environment()\n{\n    ProcessManager::Environment env;\n    auto &amp;&amp;c = bp::environment::current();\n    for (auto &amp;&amp;kv : c)\n    {\n        env.emplace(kv.key().string(), kv.value().string());\n    }\n    return env;\n}\n\nAsyncResult&lt;std::filesystem::path&gt; ProcessManager::find_executable(std::filesystem::path exe_name,\n                                                                   Environment environment)\n{\n    auto exe = bp::environment::find_executable(bp::filesystem::path{std::move(exe_name)}, std::move(environment));\n    if (exe.empty())\n    {\n        co_return make_error_result(ErrorCode::not_found,\n                                    fmt::format(\"Could not find {} in environment {}\", exe_name, environment));\n    }\n    co_return std::filesystem::path{exe.string()};\n}\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/process__manager__client_8cpp/","title":"File process_manager_client.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_manager_client.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_manager_client.cpp</code></p>"},{"location":"quite/process__manager__client_8cpp_source/","title":"File process_manager_client.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_manager_client.cpp</p> <p>Go to the documentation of this file</p>"},{"location":"quite/process__manager__client_8hpp/","title":"File process_manager_client.hpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; process_manager_client.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include \"quite/manager/remote_process_manager.hpp\"</code></li> </ul>"},{"location":"quite/process__manager__client_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/process__manager__client_8hpp/#classes","title":"Classes","text":"Type Name class ProcessManagerClient <p>The documentation for this class was generated from the following file <code>libs/manager/src/process_manager_client.hpp</code></p>"},{"location":"quite/process__manager__client_8hpp_source/","title":"File process_manager_client.hpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; process_manager_client.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include \"quite/manager/remote_process_manager.hpp\"\n\nnamespace quite::manager\n{\nclass Process;\nclass ProcessManagerClient : public RemoteProcessManager\n{\n  public:\n    QUITE_DISABLE_COPY(ProcessManagerClient);\n    QUITE_DEFAULT_MOVE(ProcessManagerClient);\n    explicit ProcessManagerClient();\n    ~ProcessManagerClient() override;\n\n    Result&lt;ProcessHandle&gt; application(const ProcessId &amp;id) override;\n    Result&lt;ProcessHandle&gt; launch_application(ProcessId id,\n                                             const std::string &amp;path_to_application,\n                                             const std::vector&lt;std::string&gt; &amp;args,\n                                             const Environment &amp;environment) override;\n    AsyncResult&lt;Environment&gt; current_environment();\n    Result&lt;std::filesystem::path&gt; find_executable(std::filesystem::path exe_name, Environment environment) override;\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/remote__process__manager_8cpp/","title":"File remote_process_manager.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; remote_process_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"remote_process_manager.hpp\"</code></li> </ul>"},{"location":"quite/remote__process__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/remote_process_manager.cpp</code></p>"},{"location":"quite/remote__process__manager_8cpp_source/","title":"File remote_process_manager.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; remote_process_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"remote_process_manager.hpp\"\n\nnamespace quite::manager\n{\nAsyncResult&lt;RemoteProcessManager::Environment&gt; RemoteProcessManager::current_remote_environment()\n{}\n\nAsyncResult&lt;ProcessHandle&gt; RemoteProcessManager::application(ProcessId name)\n{}\n\nAsyncResult&lt;ProcessHandle&gt; RemoteProcessManager::launch_application(ProcessId id,\n                                                                    std::string path_to_application,\n                                                                    std::vector&lt;std::string&gt; args,\n                                                                    Environment environment)\n{}\n\nAsyncResult&lt;std::filesystem::path&gt; RemoteProcessManager::find_executable(std::filesystem::path exe_name,\n                                                                         Environment environment)\n{}\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/remote__process__manager_8hpp/","title":"File remote_process_manager.hpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; remote_process_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include \"quite/manager/basic_process_manager.hpp\"</code></li> </ul>"},{"location":"quite/remote__process__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager"},{"location":"quite/remote__process__manager_8hpp/#classes","title":"Classes","text":"Type Name class RemoteProcessManager <p>The documentation for this class was generated from the following file <code>libs/manager/src/remote_process_manager.hpp</code></p>"},{"location":"quite/remote__process__manager_8hpp_source/","title":"File remote_process_manager.hpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; remote_process_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/async_result.hpp&gt;\n#include \"quite/manager/basic_process_manager.hpp\"\n\nnamespace quite::manager\n{\nclass RemoteProcessManager : public BasicProcessManager\n{\n  public:\n    AsyncResult&lt;Environment&gt; current_remote_environment();\n\n    AsyncResult&lt;ProcessHandle&gt; application(ProcessId name) override;\n    AsyncResult&lt;ProcessHandle&gt; launch_application(ProcessId id,\n                                                  std::string path_to_application,\n                                                  std::vector&lt;std::string&gt; args,\n                                                  Environment environment) override;\n    AsyncResult&lt;std::filesystem::path&gt; find_executable(std::filesystem::path exe_name,\n                                                       Environment environment) override;\n\n  private:\n};\n} // namespace quite::manager\n</code></pre>"},{"location":"quite/manager_2src_2server_8cpp/","title":"File server.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; src &gt; server.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/manager/server.hpp\"</code></li> </ul>"},{"location":"quite/manager_2src_2server_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace manager <p>The documentation for this class was generated from the following file <code>libs/manager/src/server.cpp</code></p>"},{"location":"quite/manager_2src_2server_8cpp_source/","title":"File server.cpp","text":"<p>File List &gt; libs &gt; manager &gt; src &gt; server.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/manager/server.hpp\"\n\nnamespace quite::manager\n{} // namespace quite::manager\n</code></pre>"},{"location":"quite/dir_0da81ac3ea6d1987f7ba9a902aa51f1c/","title":"Dir libs/manager/tests","text":"<p>FileList &gt; libs &gt; manager &gt; tests</p>"},{"location":"quite/dir_0da81ac3ea6d1987f7ba9a902aa51f1c/#files","title":"Files","text":"Type Name file runnable_exe.cpp file runnable_path.in.hpp file test_process_manager.cpp <p>The documentation for this class was generated from the following file <code>libs/manager/tests/</code></p>"},{"location":"quite/runnable__exe_8cpp/","title":"File runnable_exe.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; tests &gt; runnable_exe.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;CLI/App.hpp&gt;</code></li> </ul>"},{"location":"quite/runnable__exe_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char ** argv)"},{"location":"quite/runnable__exe_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/runnable__exe_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char ** argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/tests/runnable_exe.cpp</code></p>"},{"location":"quite/runnable__exe_8cpp_source/","title":"File runnable_exe.cpp","text":"<p>File List &gt; libs &gt; manager &gt; tests &gt; runnable_exe.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;cstdlib&gt;\n#include &lt;CLI/App.hpp&gt;\n\nint main(int argc, char **argv)\n{\n    CLI::App app{\"A simple test program\"};\n    argv = app.ensure_utf8(argv);\n\n    int exit_code{EXIT_SUCCESS};\n    app.add_option(\"--exit-code\", exit_code, \"The exit code to return\")-&gt;envname(\"TEST_EXIT_CODE\");\n\n    CLI11_PARSE(app, argc, argv);\n\n    return exit_code;\n}\n</code></pre>"},{"location":"quite/runnable__path_8in_8hpp/","title":"File runnable_path.in.hpp","text":"<p>FileList &gt; libs &gt; manager &gt; tests &gt; runnable_path.in.hpp</p> <p>Go to the source code of this file</p>"},{"location":"quite/runnable__path_8in_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr auto kRunnablePath   = <code>\"$&amp;lt;TARGET\\_FILE:test\\_manager\\_runnable&amp;gt;\"</code>"},{"location":"quite/runnable__path_8in_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/runnable__path_8in_8hpp/#variable-krunnablepath","title":"variable kRunnablePath","text":"<pre><code>constexpr auto kRunnablePath;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/tests/runnable_path.in.hpp</code></p>"},{"location":"quite/runnable__path_8in_8hpp_source/","title":"File runnable_path.in.hpp","text":"<p>File List &gt; libs &gt; manager &gt; tests &gt; runnable_path.in.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\ninline constexpr auto kRunnablePath = \"$&lt;TARGET_FILE:test_manager_runnable&gt;\";\n</code></pre>"},{"location":"quite/test__process__manager_8cpp/","title":"File test_process_manager.cpp","text":"<p>FileList &gt; libs &gt; manager &gt; tests &gt; test_process_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;catch2/catch_test_macros.hpp&gt;</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/manager/process.hpp&gt;</code></li> <li><code>#include &lt;quite/manager/process_manager.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> <li><code>#include \"runnable_path.hpp\"</code></li> </ul>"},{"location":"quite/test__process__manager_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST_CASE (\"Test ProcessManager\", \"\")"},{"location":"quite/test__process__manager_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/test__process__manager_8cpp/#function-test_case","title":"function TEST_CASE","text":"<pre><code>TEST_CASE (\n    \"Test ProcessManager\",\n    \"\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/manager/tests/test_process_manager.cpp</code></p>"},{"location":"quite/test__process__manager_8cpp_source/","title":"File test_process_manager.cpp","text":"<p>File List &gt; libs &gt; manager &gt; tests &gt; test_process_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/manager/process.hpp&gt;\n#include &lt;quite/manager/process_manager.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n#include \"runnable_path.hpp\"\n\nusing namespace quite::manager;\n\nTEST_CASE(\"Test ProcessManager\", \"[manager]\")\n{\n    quite::setup_logger();\n    ProcessManager manager{quite::get_executor()};\n\n    SECTION(\"A non probe process from environment can be launched\")\n    {\n        auto [exe] = stdexec::sync_wait(manager.find_executable({\"ls\"})).value();\n        REQUIRE(exe.and_then([&amp;](auto &amp;&amp;path) {\n                       return std::get&lt;0&gt;(\n                           stdexec::sync_wait(manager.launch_application({\"ls\"}, path, {\"-a\", \".\"}, {})).value());\n                   })\n                    .and_then([&amp;](auto &amp;&amp;process) {\n                        auto [exit_code] = stdexec::sync_wait(process-&gt;async_wait_exit()).value();\n                        REQUIRE(exit_code.has_value());\n                        REQUIRE(exit_code.value() == EXIT_SUCCESS);\n                        return exit_code;\n                    })\n                    .has_value());\n    }\n\n    SECTION(\"A non probe process can be launched\")\n    {\n        auto [process] = stdexec::sync_wait(manager.launch_application({\"runnable\"}, kRunnablePath, {}, {})).value();\n        auto [exit_code] = stdexec::sync_wait(process.value()-&gt;async_wait_exit()).value();\n        REQUIRE(exit_code.has_value());\n        REQUIRE(exit_code.value() == EXIT_SUCCESS);\n\n        auto [runnable] = stdexec::sync_wait(manager.application({\"runnable\"})).value();\n        REQUIRE(runnable.has_value());\n        REQUIRE(runnable.value()-&gt;exit_code() == EXIT_SUCCESS);\n    }\n\n    SECTION(\"A non probe process can be launched with args\")\n    {\n        auto [process] =\n            stdexec::sync_wait(manager.launch_application({\"runnable\"}, kRunnablePath, {\"--exit-code\", \"10\"}, {}))\n                .value();\n        auto [exit_code] = stdexec::sync_wait(process.value()-&gt;async_wait_exit()).value();\n        REQUIRE(exit_code.has_value());\n        REQUIRE(exit_code.value() == 10);\n    }\n\n    SECTION(\"A non probe process can be launched with a custom environment\")\n    {\n        auto [process] =\n            stdexec::sync_wait(manager.launch_application({\"runnable\"}, kRunnablePath, {}, {{\"TEST_EXIT_CODE\", \"20\"}}))\n                .value();\n        auto [exit_code] = stdexec::sync_wait(process.value()-&gt;async_wait_exit()).value();\n        REQUIRE(exit_code.has_value());\n        REQUIRE(exit_code.value() == 20);\n    }\n\n    SECTION(\"A non probe process can be launched multiple times\")\n    {\n        for (int i = 0; i &lt; 2; i++)\n        {\n            const auto expected_exit_code = i + 42;\n            auto [process] =\n                stdexec::sync_wait(\n                    manager.launch_application(\n                        {\"runnable\"}, kRunnablePath, {\"--exit-code\", fmt::format(\"{}\", expected_exit_code)}, {}))\n                    .value();\n            auto [exit_code] = stdexec::sync_wait(process.value()-&gt;async_wait_exit()).value();\n            REQUIRE(exit_code.has_value());\n            REQUIRE(exit_code.value() == expected_exit_code);\n\n            auto [runnable] = stdexec::sync_wait(manager.application({\"runnable\"})).value();\n            REQUIRE(runnable.has_value());\n            REQUIRE(runnable.value()-&gt;exit_code() == expected_exit_code);\n        }\n    }\n\n    SECTION(\"An invalid process will not crash\")\n    {\n        auto [process] =\n            stdexec::sync_wait(\n                manager.launch_application({\"not-found\"}, \"quite-not-found-program-42\", {}, {{\"TEST_EXIT_CODE\", \"42\"}}))\n                .value();\n        REQUIRE_FALSE(process.has_value());\n    }\n}\n</code></pre>"},{"location":"quite/dir_ae4f153cafaf07a7427603efac14088a/","title":"Dir libs/probe","text":"<p>FileList &gt; libs &gt; probe</p>"},{"location":"quite/dir_ae4f153cafaf07a7427603efac14088a/#directories","title":"Directories","text":"Type Name dir include dir src <p>The documentation for this class was generated from the following file <code>libs/probe/</code></p>"},{"location":"quite/dir_248610c7c7855733370a23eb8ee334df/","title":"Dir libs/probe/include","text":"<p>FileList &gt; include</p>"},{"location":"quite/dir_248610c7c7855733370a23eb8ee334df/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/probe/include/</code></p>"},{"location":"quite/dir_6ea7810d42f11748e7a5ac93411fd1ce/","title":"Dir libs/probe/include/quite","text":"<p>FileList &gt; include &gt; quite</p>"},{"location":"quite/dir_6ea7810d42f11748e7a5ac93411fd1ce/#files","title":"Files","text":"Type Name file probe.hpp <p>The documentation for this class was generated from the following file <code>libs/probe/include/quite/</code></p>"},{"location":"quite/probe_2include_2quite_2probe_8hpp/","title":"File probe.hpp","text":"<p>FileList &gt; include &gt; quite &gt; probe.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"quite/quite_probe_export.hpp\"</code></li> </ul>"},{"location":"quite/probe_2include_2quite_2probe_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/probe_2include_2quite_2probe_8hpp/#classes","title":"Classes","text":"Type Name struct GrpcServer <p>The documentation for this class was generated from the following file <code>libs/probe/include/quite/probe.hpp</code></p>"},{"location":"quite/probe_2include_2quite_2probe_8hpp_source/","title":"File probe.hpp","text":"<p>File List &gt; include &gt; quite &gt; probe.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;string&gt;\n#include \"quite/quite_probe_export.hpp\"\n\nnamespace quite\n{\nstruct GrpcServer\n{\n    std::string server_address;\n};\n\nPROBE_EXPORT void setup_hooks(GrpcServer server_config = GrpcServer{.server_address = \"unix:///tmp/grpc_probe.sock\"});\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_060cbf3b90b300eaf029d97551e4bad1/","title":"Dir libs/probe/src","text":"<p>FileList &gt; libs &gt; probe &gt; src</p>"},{"location":"quite/dir_060cbf3b90b300eaf029d97551e4bad1/#files","title":"Files","text":"Type Name file probe.cpp <p>The documentation for this class was generated from the following file <code>libs/probe/src/</code></p>"},{"location":"quite/probe_2src_2probe_8cpp/","title":"File probe.cpp","text":"<p>FileList &gt; libs &gt; probe &gt; src &gt; probe.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/probe.hpp\"</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;probe_context.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> </ul>"},{"location":"quite/probe_2src_2probe_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/probe/src/probe.cpp</code></p>"},{"location":"quite/probe_2src_2probe_8cpp_source/","title":"File probe.cpp","text":"<p>File List &gt; libs &gt; probe &gt; src &gt; probe.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/probe.hpp\"\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;probe_context.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n\nnamespace quite\n{\nvoid setup_hooks(GrpcServer server_config)\n{\n    setup_logger(false);\n    entt::locator&lt;probe::ProbeContext&gt;::emplace(server_config.server_address);\n}\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_22ab9f3959c1273824a5221c73ee839d/","title":"Dir libs/probeqt","text":"<p>FileList &gt; libs &gt; probeqt</p>"},{"location":"quite/dir_22ab9f3959c1273824a5221c73ee839d/#files","title":"Files","text":"Type Name file meta_adapter.cpp file meta_adapter.hpp file meta_qt_containers.hpp file method_invoker.cpp file method_invoker.hpp file object_tracker.cpp file object_tracker.hpp file probe_context.cpp file probe_context.hpp file property_collector.cpp file property_collector.hpp file qt_meta_registry.cpp file qt_meta_registry.hpp file qt_meta_type_accessor.cpp file qt_meta_type_accessor.hpp file qt_probe_handler.cpp file qt_probe_handler.hpp file qtstdexec.h file to_object_id.hpp file value_converters.cpp file value_converters.hpp"},{"location":"quite/dir_22ab9f3959c1273824a5221c73ee839d/#directories","title":"Directories","text":"Type Name dir injector dir tests <p>The documentation for this class was generated from the following file <code>libs/probeqt/</code></p>"},{"location":"quite/dir_91fe3d89382dfb9ec1070f72fd853fa0/","title":"Dir libs/probeqt/injector","text":"<p>FileList &gt; injector</p>"},{"location":"quite/dir_91fe3d89382dfb9ec1070f72fd853fa0/#files","title":"Files","text":"Type Name file clipboard_injector.hpp file keyboard_injector.hpp file mouse_injector.cpp file mouse_injector.hpp file touch_injector.hpp <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/</code></p>"},{"location":"quite/clipboard__injector_8hpp/","title":"File clipboard_injector.hpp","text":"<p>FileList &gt; injector &gt; clipboard_injector.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/clipboard_injector.hpp</code></p>"},{"location":"quite/clipboard__injector_8hpp_source/","title":"File clipboard_injector.hpp","text":"<p>File List &gt; injector &gt; clipboard_injector.hpp</p> <p>Go to the documentation of this file</p>"},{"location":"quite/keyboard__injector_8hpp/","title":"File keyboard_injector.hpp","text":"<p>FileList &gt; injector &gt; keyboard_injector.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/keyboard_injector.hpp</code></p>"},{"location":"quite/keyboard__injector_8hpp_source/","title":"File keyboard_injector.hpp","text":"<p>File List &gt; injector &gt; keyboard_injector.hpp</p> <p>Go to the documentation of this file</p>"},{"location":"quite/mouse__injector_8cpp/","title":"File mouse_injector.cpp","text":"<p>FileList &gt; injector &gt; mouse_injector.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"mouse_injector.hpp\"</code></li> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;QPointer&gt;</code></li> </ul>"},{"location":"quite/mouse__injector_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/mouse_injector.cpp</code></p>"},{"location":"quite/mouse__injector_8cpp_source/","title":"File mouse_injector.cpp","text":"<p>File List &gt; injector &gt; mouse_injector.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"mouse_injector.hpp\"\n#include &lt;QCoreApplication&gt;\n#include &lt;QPointer&gt;\n\nnamespace quite::probe\n{\nMouseInjector::MouseInjector(const ObjectTracker &amp;object_tracker)\n    : object_tracker_{object_tracker}\n    , mouse_{QStringLiteral(\"QuiteProbeTestingMouse\"),\n             100,\n             QInputDevice::DeviceType::Mouse,\n             QPointingDevice::PointerType::Generic,\n             QInputDevice::Capability::MouseEmulation,\n             1,\n             3}\n{}\n\nMouseInjector::~MouseInjector() = default;\n\nAsyncResult&lt;void&gt; MouseInjector::single_action(ObjectId target_id, core::MouseAction action)\n{\n    auto target = object_tracker_.get_object_by_id(target_id);\n    if (not target.has_value())\n    {\n        co_return std::unexpected{target.error()};\n    }\n    std::unique_ptr&lt;QMouseEvent&gt; event;\n    switch (action.trigger)\n    {\n    case core::MouseTrigger::none:\n        break;\n    case core::MouseTrigger::click:\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseButtonPress,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseButtonRelease,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        break;\n    case core::MouseTrigger::double_click:\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseButtonDblClick,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        break;\n    case core::MouseTrigger::press:\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseButtonPress,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        break;\n    case core::MouseTrigger::release:\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseButtonRelease,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        break;\n    case core::MouseTrigger::move:\n        dispatch_mouse_event(target.value(),\n                             std::make_unique&lt;QMouseEvent&gt;(QMouseEvent::Type::MouseMove,\n                                                           QPointF{action.position.x, action.position.y},\n                                                           QPointF{},\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::MouseButton::LeftButton,\n                                                           Qt::KeyboardModifiers{},\n                                                           &amp;mouse_));\n        break;\n    }\n\n    if (event != nullptr)\n    {\n        QCoreApplication::postEvent(target.value(), event.release());\n    }\n    co_return {};\n}\n\nvoid MouseInjector::dispatch_mouse_event(QObject *target, std::unique_ptr&lt;QMouseEvent&gt; event)\n{\n    if (event != nullptr)\n    {\n        QCoreApplication::postEvent(target, event.release());\n    }\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/probeqt_2injector_2mouse__injector_8hpp/","title":"File mouse_injector.hpp","text":"<p>FileList &gt; injector &gt; mouse_injector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPointingDevice&gt;</code></li> <li><code>#include &lt;quite/injectors/mouse_injector.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include \"object_tracker.hpp\"</code></li> </ul>"},{"location":"quite/probeqt_2injector_2mouse__injector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/probeqt_2injector_2mouse__injector_8hpp/#classes","title":"Classes","text":"Type Name class MouseInjector <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/mouse_injector.hpp</code></p>"},{"location":"quite/probeqt_2injector_2mouse__injector_8hpp_source/","title":"File mouse_injector.hpp","text":"<p>File List &gt; injector &gt; mouse_injector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QMouseEvent&gt;\n#include &lt;QPointingDevice&gt;\n#include &lt;quite/injectors/mouse_injector.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include \"object_tracker.hpp\"\nnamespace quite::probe\n{\n\nclass MouseInjector final : public core::IMouseInjector\n{\n  public:\n    explicit MouseInjector(const ObjectTracker &amp;object_tracker);\n    ~MouseInjector() override;\n\n    AsyncResult&lt;void&gt; single_action(ObjectId target_id, core::MouseAction action) override;\n\n  private:\n    static void dispatch_mouse_event(QObject *target, std::unique_ptr&lt;QMouseEvent&gt; event);\n\n  private:\n    const ObjectTracker &amp;object_tracker_;\n    QPointingDevice mouse_;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/touch__injector_8hpp/","title":"File touch_injector.hpp","text":"<p>FileList &gt; injector &gt; touch_injector.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>libs/probeqt/injector/touch_injector.hpp</code></p>"},{"location":"quite/touch__injector_8hpp_source/","title":"File touch_injector.hpp","text":"<p>File List &gt; injector &gt; touch_injector.hpp</p> <p>Go to the documentation of this file</p>"},{"location":"quite/dir_c1613d43beada98aaa8aaa25db1fb827/","title":"Dir libs/probeqt/tests","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests</p>"},{"location":"quite/dir_c1613d43beada98aaa8aaa25db1fb827/#files","title":"Files","text":"Type Name file main.cpp file test_method_invoker.cpp file test_object_tracker.cpp file test_probe_context.cpp file test_property_collector.cpp file test_qt_probe_handler.cpp file test_value_containers.cpp <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/</code></p>"},{"location":"quite/probeqt_2tests_2main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quill/Frontend.h&gt;</code></li> <li><code>#include &lt;quill/LogMacros.h&gt;</code></li> <li><code>#include &lt;quill/core/LogLevel.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"value_converters.hpp\"</code></li> </ul>"},{"location":"quite/probeqt_2tests_2main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"quite/probeqt_2tests_2main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/probeqt_2tests_2main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/main.cpp</code></p>"},{"location":"quite/probeqt_2tests_2main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QCoreApplication&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;quill/Frontend.h&gt;\n#include &lt;quill/LogMacros.h&gt;\n#include &lt;quill/core/LogLevel.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"value_converters.hpp\"\n\nDEFINE_LOGGER(qt_log)\n\nnamespace\n{\nvoid quite_message_handler(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)\n{\n    quill::LogLevel lvl{};\n    switch (type)\n    {\n    case QtDebugMsg:\n        lvl = quill::LogLevel::Debug;\n        break;\n    case QtInfoMsg:\n        lvl = quill::LogLevel::Info;\n        break;\n    case QtWarningMsg:\n        lvl = quill::LogLevel::Warning;\n        break;\n    case QtFatalMsg:\n        lvl = quill::LogLevel::Critical;\n        break;\n    default:\n        lvl = quill::LogLevel::Debug;\n    }\n    LOG_RUNTIME_METADATA(qt_log(), lvl, context.file, context.line, context.function, \"{}\", msg.toStdString());\n}\n} // namespace\n\nint main(int argc, char *argv[])\n{\n    quite::setup_logger();\n    qInstallMessageHandler(quite_message_handler);\n    quite::probe::register_converters(entt::locator&lt;quite::ValueRegistry&gt;::emplace());\n    QCoreApplication app{argc, argv};\n    return static_cast&lt;int&gt;(\n        boost::ut::cfg&lt;&gt;.run({.report_errors = true, .argc = argc, .argv = const_cast&lt;const char **&gt;(argv)}));\n}\n</code></pre>"},{"location":"quite/test__method__invoker_8cpp/","title":"File test_method_invoker.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_method_invoker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QEventLoop&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;fmt/base.h&gt;</code></li> <li><code>#include &lt;fmt/std.h&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> <li><code>#include &lt;quite/meta_any_formatter.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"method_invoker.hpp\"</code></li> <li><code>#include \"test_method_invoker.moc\"</code></li> </ul>"},{"location":"quite/test__method__invoker_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe methodinvoker\"&gt; _"},{"location":"quite/test__method__invoker_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__method__invoker_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe methodinvoker\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_method_invoker.cpp</code></p>"},{"location":"quite/test__method__invoker_8cpp_source/","title":"File test_method_invoker.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_method_invoker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QEventLoop&gt;\n#include &lt;QObject&gt;\n#include &lt;QString&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;fmt/base.h&gt;\n#include &lt;fmt/std.h&gt;\n#include &lt;quite/error.hpp&gt;\n#include &lt;quite/meta_any_formatter.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"method_invoker.hpp\"\n\nusing namespace quite;\nusing namespace quite::probe;\nusing namespace boost::ut;\nusing namespace std::literals::string_view_literals;\n\nnamespace\n{\nclass TestObject : public QObject\n{\n    Q_OBJECT\n  public:\n    Q_INVOKABLE int add(int a, int b) // NOLINT\n    {\n        return a + b;\n    }\n    Q_INVOKABLE void setValue(int v) // NOLINT\n    {\n        value = v;\n    }\n    Q_INVOKABLE int getValue() const // NOLINT\n    {\n        return value;\n    }\n    Q_INVOKABLE QString echo(const QString &amp;s) // NOLINT\n    {\n        return s;\n    }\n    int value{0};\n};\n} // namespace\n\nstatic suite&lt;\"qtprobe methodinvoker\"&gt; _ = [] { // NOLINT\n    \"invoke int add(int,int)\"_test = [] {\n        MethodInvoker invoker;\n\n        TestObject obj;\n        entt::meta_any obj_any = static_cast&lt;QObject *&gt;(&amp;obj);\n        std::vector&lt;entt::meta_any&gt; params = {entt::forward_as_meta(1), entt::forward_as_meta(2)};\n        auto result = invoker.invoke_method(obj_any, \"add(int,int)\", params);\n\n        expect(result.has_value());\n        expect(result-&gt;cast&lt;int&gt;() == 3);\n    };\n\n    \"invoke void setValue(int) and getValue\"_test = [] {\n        MethodInvoker invoker;\n\n        TestObject obj;\n        entt::meta_any obj_any = static_cast&lt;QObject *&gt;(&amp;obj);\n        std::vector&lt;entt::meta_any&gt; params = {42};\n        auto set_result = invoker.invoke_method(obj_any, \"setValue(int)\", params);\n\n        expect(set_result.has_value());\n\n        std::vector&lt;entt::meta_any&gt; get_params;\n        auto get_result = invoker.invoke_method(obj_any, \"getValue()\", get_params);\n\n        expect(get_result.has_value());\n        expect(get_result-&gt;cast&lt;int&gt;() == 42);\n    };\n\n    \"invoke QString echo(QString)\"_test = [] {\n        MethodInvoker invoker;\n\n        TestObject obj;\n        entt::meta_any obj_any = static_cast&lt;QObject *&gt;(&amp;obj);\n        std::vector&lt;entt::meta_any&gt; params = {std::string{\"hello\"}};\n        auto result = invoker.invoke_method(obj_any, \"echo(QString)\", params);\n\n        expect(result.has_value());\n        expect(result-&gt;cast&lt;QString&gt;().toStdString() == \"hello\"sv);\n    };\n\n    \"invoke with wrong method name returns error\"_test = [] {\n        MethodInvoker invoker;\n\n        TestObject obj;\n        entt::meta_any obj_any = static_cast&lt;QObject *&gt;(&amp;obj);\n        std::vector&lt;entt::meta_any&gt; params;\n        auto result = invoker.invoke_method(obj_any, \"doesNotExist()\", params);\n\n        expect(!result.has_value());\n        expect(result.error().code == ErrorCode::invalid_argument);\n    };\n\n    \"invoke with wrong argument count returns error\"_test = [] {\n        MethodInvoker invoker;\n\n        TestObject obj;\n        entt::meta_any obj_any = static_cast&lt;QObject *&gt;(&amp;obj);\n        std::vector&lt;entt::meta_any&gt; params = {1}; // add(int,int) expects 2\n        auto result = invoker.invoke_method(obj_any, \"add(int,int)\", params);\n\n        expect(!result.has_value());\n        expect(result.error().code == ErrorCode::failed_precondition);\n    };\n};\n\n#include \"test_method_invoker.moc\"\n</code></pre>"},{"location":"quite/test__object__tracker_8cpp/","title":"File test_object_tracker.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_object_tracker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QEventLoop&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"object_tracker.hpp\"</code></li> <li><code>#include \"to_object_id.hpp\"</code></li> <li><code>#include \"test_object_tracker.moc\"</code></li> </ul>"},{"location":"quite/test__object__tracker_8cpp/#classes","title":"Classes","text":"Type Name class MyCustomClass"},{"location":"quite/test__object__tracker_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe\"&gt; _"},{"location":"quite/test__object__tracker_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__object__tracker_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_object_tracker.cpp</code></p>"},{"location":"quite/test__object__tracker_8cpp_source/","title":"File test_object_tracker.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_object_tracker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QEventLoop&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;quite/error.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"object_tracker.hpp\"\n#include \"to_object_id.hpp\"\n\nusing namespace quite;\nusing namespace quite::probe;\n\nusing namespace quite;\nusing namespace boost::ut;\nusing namespace std::literals::string_view_literals;\n\nclass MyCustomClass : public QObject\n{\n    Q_OBJECT\n};\n\nstatic suite&lt;\"qtprobe\"&gt; _ = [] { // NOLINT\n    \"find object by name\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject obj1;\n        obj1.setObjectName(\"obj1\");\n        tracker.add_object(&amp;obj1);\n\n        QObject obj2;\n        obj2.setObjectName(\"obj2\");\n        tracker.add_object(&amp;obj2);\n\n        expect(loop.processEvents());\n\n        auto found1 = tracker.find_object(\"obj1\");\n        expect(found1.has_value());\n        expect(found1-&gt;object_id == to_object_id(&amp;obj1));\n\n        auto found2 = tracker.find_object(\"obj2\");\n        expect(found2.has_value());\n        expect(found2-&gt;object_id == to_object_id(&amp;obj2));\n    };\n\n    \"find object by query (flat)\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject obj1;\n        obj1.setObjectName(\"obj1\");\n        tracker.add_object(&amp;obj1);\n\n        QObject obj2;\n        obj2.setObjectName(\"obj2\");\n        tracker.add_object(&amp;obj2);\n\n        expect(loop.processEvents());\n\n        ObjectQuery query;\n        query.properties = {{\"objectName\", std::string{\"obj2\"}}};\n        auto found = tracker.find_object_by_query(query);\n        expect(found.has_value());\n        expect(found-&gt;object_id == to_object_id(&amp;obj2));\n    };\n\n    \"find object by query with parent (container)\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject parent;\n        parent.setObjectName(\"parent\");\n        tracker.add_object(&amp;parent);\n\n        QObject child(&amp;parent);\n        child.setObjectName(\"child\");\n        tracker.add_object(&amp;child);\n\n        QObject child2;\n        child2.setObjectName(\"child\");\n        tracker.add_object(&amp;child2);\n\n        expect(loop.processEvents());\n\n        auto parent_query = std::make_shared&lt;ObjectQuery&gt;();\n        parent_query-&gt;properties = {{\"objectName\", std::string{\"parent\"}}};\n\n        ObjectQuery query;\n        query.container = parent_query;\n        query.properties = {{\"objectName\", std::string{\"child\"}}};\n\n        auto found = tracker.find_object_by_query(query);\n        expect(found.has_value());\n        expect(found-&gt;object_id == to_object_id(&amp;child));\n    };\n\n    \"find object by query with multiple parents\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject grandparent;\n        grandparent.setObjectName(\"grandparent\");\n        tracker.add_object(&amp;grandparent);\n\n        QObject parent(&amp;grandparent);\n        parent.setObjectName(\"parent\");\n        tracker.add_object(&amp;parent);\n\n        QObject child(&amp;parent);\n        child.setObjectName(\"child\");\n        tracker.add_object(&amp;child);\n\n        QObject child2;\n        child2.setObjectName(\"child\");\n        tracker.add_object(&amp;child2);\n\n        expect(loop.processEvents());\n\n        auto grandparent_query = std::make_shared&lt;ObjectQuery&gt;();\n        grandparent_query-&gt;properties = {{\"objectName\", std::string{\"grandparent\"}}};\n\n        auto parent_query = std::make_shared&lt;ObjectQuery&gt;();\n        parent_query-&gt;container = grandparent_query;\n        parent_query-&gt;properties = {{\"objectName\", std::string{\"parent\"}}};\n\n        ObjectQuery query;\n        query.container = parent_query;\n        query.properties = {{\"objectName\", std::string{\"child\"}}};\n\n        auto found = tracker.find_object_by_query(query);\n        expect(found.has_value());\n        expect(found-&gt;object_id == to_object_id(&amp;child));\n    };\n\n    \"find object by query with type name\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject a1;\n        MyCustomClass my_class;\n        QObject a2;\n        tracker.add_object(&amp;a1);\n        tracker.add_object(&amp;my_class);\n        tracker.add_object(&amp;a2);\n        expect(loop.processEvents());\n\n        auto &amp;&amp;query = make_query().with_type(\"MyCustomClass\");\n        auto found = tracker.find_object_by_query(query);\n        expect(found.has_value());\n        expect(found-&gt;object_id == to_object_id(&amp;my_class));\n    };\n\n    \"remove object\"_test = [] {\n        QEventLoop loop;\n        ObjectTracker tracker;\n\n        QObject obj;\n        obj.setObjectName(\"to_remove\");\n        tracker.add_object(&amp;obj);\n\n        expect(loop.processEvents());\n\n        auto found = tracker.find_object(\"to_remove\");\n        expect(found.has_value());\n\n        tracker.remove_object(&amp;obj);\n\n        auto not_found = tracker.find_object(\"to_remove\");\n        expect(!not_found.has_value());\n    };\n};\n#include \"test_object_tracker.moc\"\n</code></pre>"},{"location":"quite/test__probe__context_8cpp/","title":"File test_probe_context.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_probe_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include \"probe_context.hpp\"</code></li> </ul>"},{"location":"quite/test__probe__context_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe ProbeContext\"&gt; _   = <code>/* multi line expression */</code>"},{"location":"quite/test__probe__context_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__probe__context_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe ProbeContext\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_probe_context.cpp</code></p>"},{"location":"quite/test__probe__context_8cpp_source/","title":"File test_probe_context.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_probe_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QObject&gt;\n#include &lt;boost/ut.hpp&gt;\n#include \"probe_context.hpp\"\n\nusing namespace boost::ut;\nusing quite::probe::ProbeContext;\n\nstatic suite&lt;\"qtprobe ProbeContext\"&gt; _ = [] { // NOLINT\n    \"ProbeContext can be constructed and destructed\"_test = [] {\n        // Should not crash or throw\n        ProbeContext ctx{\"localhost:12345\"};\n    };\n\n    \"ProbeContext installs and restores Qt hooks\"_test = [] {\n        // Check if hooks are restored on destruction\n        {\n            ProbeContext ctx{\"localhost:12345\"};\n            expect(qtHookData[QHooks::AddQObject] != 0);\n            expect(qtHookData[QHooks::RemoveQObject] != 0);\n            expect(qtHookData[QHooks::Startup] != 0);\n        }\n        expect(qtHookData[QHooks::AddQObject] == 0);\n        expect(qtHookData[QHooks::RemoveQObject] == 0);\n        expect(qtHookData[QHooks::Startup] == 0);\n    };\n};\n</code></pre>"},{"location":"quite/test__property__collector_8cpp/","title":"File test_property_collector.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_property_collector.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QEventLoop&gt;</code></li> <li><code>#include &lt;QMetaProperty&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"property_collector.hpp\"</code></li> <li><code>#include \"test_property_collector.moc\"</code></li> </ul>"},{"location":"quite/test__property__collector_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe propertycollector\"&gt; _"},{"location":"quite/test__property__collector_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__property__collector_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe propertycollector\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_property_collector.cpp</code></p>"},{"location":"quite/test__property__collector_8cpp_source/","title":"File test_property_collector.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_property_collector.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QEventLoop&gt;\n#include &lt;QMetaProperty&gt;\n#include &lt;QObject&gt;\n#include &lt;QString&gt;\n#include &lt;QVariant&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;quite/error.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"property_collector.hpp\"\n\nusing namespace quite;\nusing namespace boost::ut;\nusing namespace std::literals::string_view_literals;\n\nnamespace\n{\nclass SimpleObject : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(int number MEMBER m_number)\n    Q_PROPERTY(QString text MEMBER m_text)\n  public:\n    int m_number{42};\n    QString m_text{\"hello\"};\n};\n} // namespace\n\nstatic suite&lt;\"qtprobe propertycollector\"&gt; _ = [] { // NOLINT\n    \"read_property returns correct int and string\"_test = [] {\n        SimpleObject obj;\n        const QMetaObject *meta = obj.metaObject();\n\n        // int property\n        int number_idx = meta-&gt;indexOfProperty(\"number\");\n        QMetaProperty number_prop = meta-&gt;property(number_idx);\n        auto [name1, value1] = read_property(obj.property(\"number\"), number_prop);\n        expect(name1 == \"number\");\n        expect(value1.cast&lt;int&gt;() == 42);\n\n        // QString property\n        int text_idx = meta-&gt;indexOfProperty(\"text\");\n        QMetaProperty text_prop = meta-&gt;property(text_idx);\n        auto [name2, value2] = read_property(obj.property(\"text\"), text_prop);\n        expect(name2 == \"text\");\n        expect(value2.cast&lt;QString&gt;().toStdString() == \"hello\"sv);\n    };\n\n    \"collect_properties returns all properties\"_test = [] {\n        SimpleObject obj;\n        auto meta = ObjectMeta::from_qobject(&amp;obj);\n\n        // Collect all properties\n        auto props = collect_properties(meta, {});\n        expect(props.contains(\"number\"));\n        expect(props.contains(\"text\"));\n        expect(props[\"number\"].cast&lt;int&gt;() == 42);\n        expect(props[\"text\"].cast&lt;QString&gt;().toStdString() == \"hello\"sv);\n    };\n\n    \"collect_properties filters by property_names\"_test = [] {\n        SimpleObject obj;\n        auto meta = ObjectMeta::from_qobject(&amp;obj);\n\n        std::vector&lt;std::string&gt; names = {\"text\"};\n        auto props = collect_properties(meta, names);\n        expect(!props.contains(\"number\"));\n        expect(props.contains(\"text\"));\n        expect(props[\"text\"].cast&lt;QString&gt;().toStdString() == \"hello\"sv);\n    };\n};\n\n#include \"test_property_collector.moc\"\n</code></pre>"},{"location":"quite/test__qt__probe__handler_8cpp/","title":"File test_qt_probe_handler.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_qt_probe_handler.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QEventLoop&gt;</code></li> <li><code>#include &lt;QImage&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;exec/async_scope.hpp&gt;</code></li> <li><code>#include &lt;stdexec/execution.hpp&gt;</code></li> <li><code>#include \"object_tracker.hpp\"</code></li> <li><code>#include \"qt_probe_handler.hpp\"</code></li> <li><code>#include \"to_object_id.hpp\"</code></li> </ul>"},{"location":"quite/test__qt__probe__handler_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe QtProbeHandler\"&gt; _"},{"location":"quite/test__qt__probe__handler_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__qt__probe__handler_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe QtProbeHandler\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_qt_probe_handler.cpp</code></p>"},{"location":"quite/test__qt__probe__handler_8cpp_source/","title":"File test_qt_probe_handler.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_qt_probe_handler.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QEventLoop&gt;\n#include &lt;QImage&gt;\n#include &lt;QObject&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;exec/async_scope.hpp&gt;\n#include &lt;stdexec/execution.hpp&gt;\n#include \"object_tracker.hpp\"\n#include \"qt_probe_handler.hpp\"\n#include \"to_object_id.hpp\"\n\nusing namespace boost::ut;\nusing namespace quite;\nusing namespace quite::probe;\n\nstatic suite&lt;\"qtprobe QtProbeHandler\"&gt; _ = [] {\n    QEventLoop loop;\n    ObjectTracker tracker;\n    QObject obj;\n    obj.setObjectName(\"probe_obj\");\n    tracker.add_object(&amp;obj);\n    expect(loop.processEvents());\n\n    \"object_instance returns meta_any for valid object\"_test = [&amp;] {\n        QtProbeHandler handler{tracker};\n        auto id = to_object_id(&amp;obj);\n\n        auto [result] = stdexec::sync_wait(handler.object_instance(id)).value();\n        expect(result.has_value());\n        expect(result-&gt;cast&lt;QObject *&gt;() == &amp;obj);\n    };\n\n    \"find_object returns correct reference\"_test = [&amp;] {\n        fmt::println(\"find_object\");\n        QtProbeHandler handler{tracker};\n        ObjectQuery query;\n        query.properties = {{\"objectName\", std::string{\"probe_obj\"}}};\n\n        exec::async_scope scope;\n        auto wait_senders = scope.on_empty();\n        ObjectReference found_obj{};\n        scope.spawn(stdexec::starts_on(exec::inline_scheduler{},\n                                       handler.find_object(query) | stdexec::then([&amp;found_obj](auto &amp;&amp;result) {\n                                           expect(result.has_value());\n                                           found_obj = result.value();\n                                       })));\n        expect(loop.processEvents());\n        stdexec::sync_wait(wait_senders);\n\n        expect(found_obj.object_id == to_object_id(&amp;obj));\n    };\n\n    \"write property\"_test = [&amp;] {\n        fmt::println(\"find_object\");\n        QtProbeHandler handler{tracker};\n        ObjectQuery query;\n        query.properties = {{\"objectName\", std::string{\"probe_obj\"}}};\n\n        exec::async_scope scope;\n        auto wait_senders = scope.on_empty();\n        const std::string new_name{\"testName\"};\n        scope.spawn(stdexec::starts_on(exec::inline_scheduler{},\n                                       handler.set_property(to_object_id(&amp;obj), \"objectName\", new_name)) |\n                    stdexec::then([&amp;](auto &amp;&amp;result) {\n                        expect(result.has_value());\n                        const auto actual_name = obj.objectName().toStdString();\n                        expect(actual_name == new_name);\n                    }));\n        expect(loop.processEvents());\n        stdexec::sync_wait(wait_senders);\n    };\n#if 0\n    \"fetch_windows returns all top-level views\"_test = [&amp;] {\n        QEventLoop loop;\n        fmt::println(\"fetch_windows\");\n        ObjectTracker tracker;\n        QObject obj1;\n        obj1.setObjectName(\"win1\");\n        tracker.add_object(&amp;obj1);\n\n        QObject obj2;\n        obj2.setObjectName(\"win2\");\n        tracker.add_object(&amp;obj2);\n\n        expect(loop.processEvents());\n\n        QtProbeHandler handler{tracker};\n        auto [result] = stdexec::sync_wait(handler.fetch_windows()).value();\n        expect(result.has_value());\n        auto windows = result.value();\n        if (not expect(windows.size() == 2_u))\n        {\n            return;\n        }\n        expect(windows[0].object_id == to_object_id(&amp;obj1) or windows[1].object_id == to_object_id(&amp;obj1));\n        expect(windows[0].object_id == to_object_id(&amp;obj2) or windows[1].object_id == to_object_id(&amp;obj2));\n    };\n\n    \"fetch_properties returns property map\"_test = [&amp;] {\n        QtProbeHandler handler{tracker};\n        auto id = to_object_id(&amp;obj);\n\n        std::vector&lt;std::string&gt; props = {\"objectName\"};\n        auto [result] = stdexec::sync_wait(handler.fetch_properties(id, props)).value();\n        expect(result.has_value());\n        expect(result-&gt;contains(\"objectName\"));\n        expect((*result)[\"objectName\"].allow_cast&lt;QString&gt;());\n        expect((*result)[\"objectName\"].cast&lt;QString&gt;() == \"probe_obj\");\n    };\n\n    \"take_snapshot returns error for non-visual object\"_test = [&amp;] {\n        QtProbeHandler handler{tracker};\n        auto id = to_object_id(&amp;obj);\n\n        auto [result] = stdexec::sync_wait(handler.take_snapshot(id)).value();\n        expect(!result.has_value());\n    };\n#endif\n};\n</code></pre>"},{"location":"quite/test__value__containers_8cpp/","title":"File test_value_containers.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; tests &gt; test_value_containers.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QPointF&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> <li><code>#include &lt;QRectF&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/resolve.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"value_converters.hpp\"</code></li> </ul>"},{"location":"quite/test__value__containers_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"qtprobe value converters\"&gt; _"},{"location":"quite/test__value__containers_8cpp/#macros","title":"Macros","text":"Type Name define TEST_PRIMITIVE_TYPE (TypeName, TypeId, Type) <code>/* multi line expression */</code>"},{"location":"quite/test__value__containers_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__value__containers_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"qtprobe value converters\"&gt; _;\n</code></pre>"},{"location":"quite/test__value__containers_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/test__value__containers_8cpp/#define-test_primitive_type","title":"define TEST_PRIMITIVE_TYPE","text":"<pre><code>#define TEST_PRIMITIVE_TYPE (\n    TypeName,\n    TypeId,\n    Type\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/tests/test_value_containers.cpp</code></p>"},{"location":"quite/test__value__containers_8cpp_source/","title":"File test_value_containers.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; tests &gt; test_value_containers.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QColor&gt;\n#include &lt;QCoreApplication&gt;\n#include &lt;QList&gt;\n#include &lt;QPoint&gt;\n#include &lt;QPointF&gt;\n#include &lt;QRect&gt;\n#include &lt;QRectF&gt;\n#include &lt;QString&gt;\n#include &lt;QUrl&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;entt/meta/resolve.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"value_converters.hpp\"\n\nusing namespace quite;\nusing namespace quite::probe;\nusing namespace boost::ut;\nusing namespace entt::literals;\n\nstatic suite&lt;\"qtprobe value converters\"&gt; _ = [] { // NOLINT\n    \"register_converters registers QString\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QString\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QString s = \"abc\";\n        auto any = entt::forward_as_meta(s);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QString&gt;().toStdString() == std::string(\"abc\"));\n    };\n\n    \"register_converters registers QRect\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QRect\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QRect rect(1, 2, 3, 4);\n        auto any = entt::forward_as_meta(rect);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QRect&gt;() == rect);\n    };\n\n    \"register_converters registers QPoint\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QPoint\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QPoint pt(5, 7);\n        auto any = entt::forward_as_meta(pt);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QPoint&gt;() == pt);\n    };\n\n    \"register_converters registers QPointF\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QPointF\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QPointF ptf(1.5, 2.5);\n        auto any = entt::forward_as_meta(ptf);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QPointF&gt;() == ptf);\n    };\n\n    \"register_converters registers QRectF\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QRectF\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QRectF rectf(1.1, 2.2, 3.3, 4.4);\n        auto any = entt::forward_as_meta(rectf);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QRectF&gt;() == rectf);\n    };\n\n    \"register_converters registers QColor\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QColor\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QColor color(Qt::red);\n        auto any = entt::forward_as_meta(color);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QColor&gt;() == color);\n    };\n\n    \"register_converters registers QUrl\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QUrl\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QUrl url(\"https://github.com/mathisloge/ng-quite\");\n        auto any = entt::forward_as_meta(url);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QUrl&gt;() == url);\n    };\n\n    \"register_converters registers QObjectList\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        auto meta = entt::resolve(\"QObjectList\"_hs);\n        expect(static_cast&lt;bool&gt;(meta));\n        QList&lt;QObject *&gt; list;\n        QObject obj;\n        list.append(&amp;obj);\n        list.append(&amp;obj);\n        auto any = entt::forward_as_meta(list);\n        expect(any.type() == meta);\n        expect(any.cast&lt;QList&lt;QObject *&gt;&gt;().size() == 2);\n    };\n\n    // Macro for testing registration of a type by name and a value\n#define TEST_PRIMITIVE_TYPE(TypeName, TypeId, Type)                                                                    \\\n    {                                                                                                                  \\\n        auto meta = entt::resolve(#Type##_hs);                                                                         \\\n        expect(static_cast&lt;bool&gt;(meta));                                                                               \\\n        auto any = entt::forward_as_meta((Type){});                                                                    \\\n        expect(any.type() == meta);                                                                                    \\\n        expect(any.cast&lt;Type&gt;() == (Type){});                                                                          \\\n    }\n    \"register_converters registers all static primitive types\"_test = [] {\n        ValueRegistry registry;\n        register_converters(registry);\n\n        QT_FOR_EACH_STATIC_PRIMITIVE_NON_VOID_TYPE(TEST_PRIMITIVE_TYPE);\n    };\n};\n</code></pre>"},{"location":"quite/meta__adapter_8cpp/","title":"File meta_adapter.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; meta_adapter.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"meta_adapter.hpp\"</code></li> </ul>"},{"location":"quite/meta__adapter_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_adapter.cpp</code></p>"},{"location":"quite/meta__adapter_8cpp_source/","title":"File meta_adapter.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; meta_adapter.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"meta_adapter.hpp\"\n\nnamespace quite::probe\n{\n\nAsyncResult&lt;meta::Type&gt; MetaAdapter::find_type_by_id(meta::TypeId type_id)\n{\n    return type_registry_.lookup_type(type_id);\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/meta__adapter_8hpp/","title":"File meta_adapter.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; meta_adapter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/meta/meta_types.hpp&gt;</code></li> <li><code>#include &lt;quite/result.hpp&gt;</code></li> <li><code>#include \"qt_meta_registry.hpp\"</code></li> </ul>"},{"location":"quite/meta__adapter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/meta__adapter_8hpp/#classes","title":"Classes","text":"Type Name class MetaAdapter <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_adapter.hpp</code></p>"},{"location":"quite/meta__adapter_8hpp_source/","title":"File meta_adapter.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; meta_adapter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/meta/meta_types.hpp&gt;\n#include &lt;quite/result.hpp&gt;\n#include \"qt_meta_registry.hpp\"\n\nnamespace quite::probe\n{\n\nclass MetaAdapter\n{\n  public:\n    AsyncResult&lt;meta::Type&gt; find_type_by_id(meta::TypeId type_id);\n\n  private:\n    QtMetaRegistry type_registry_;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/meta__qt__containers_8hpp/","title":"File meta_qt_containers.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; meta_qt_containers.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/meta/container.hpp&gt;</code></li> <li><code>#include &lt;qcontainerfwd.h&gt;</code></li> </ul>"},{"location":"quite/meta__qt__containers_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace entt"},{"location":"quite/meta__qt__containers_8hpp/#classes","title":"Classes","text":"Type Name struct meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; &lt;Args&gt; struct meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; &lt;Args&gt; struct meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; &lt;Args&gt; <p>The documentation for this class was generated from the following file <code>libs/probeqt/meta_qt_containers.hpp</code></p>"},{"location":"quite/meta__qt__containers_8hpp_source/","title":"File meta_qt_containers.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; meta_qt_containers.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/meta/container.hpp&gt;\n#include &lt;qcontainerfwd.h&gt;\nnamespace entt\n{\ntemplate &lt;typename... Args&gt;\nstruct meta_sequence_container_traits&lt;QList&lt;Args...&gt;&gt; : basic_meta_sequence_container_traits&lt;QList&lt;Args...&gt;&gt;\n{};\n\ntemplate &lt;typename... Args&gt;\nstruct meta_associative_container_traits&lt;QMap&lt;Args...&gt;&gt; : basic_meta_associative_container_traits&lt;QMap&lt;Args...&gt;&gt;\n{};\n\ntemplate &lt;typename... Args&gt;\nstruct meta_associative_container_traits&lt;QHash&lt;Args...&gt;&gt; : basic_meta_associative_container_traits&lt;QHash&lt;Args...&gt;&gt;\n{};\n} // namespace entt\n</code></pre>"},{"location":"quite/method__invoker_8cpp/","title":"File method_invoker.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; method_invoker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"method_invoker.hpp\"</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QMetaMethod&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;entt/meta/resolve.hpp&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> </ul>"},{"location":"quite/method__invoker_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace literals namespace quite namespace probe"},{"location":"quite/method__invoker_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name QMetaType meta_type"},{"location":"quite/method__invoker_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"quite/method__invoker_8cpp/#variable-meta_type","title":"variable meta_type","text":"<pre><code>QMetaType meta_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/method_invoker.cpp</code></p>"},{"location":"quite/method__invoker_8cpp_source/","title":"File method_invoker.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; method_invoker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"method_invoker.hpp\"\n#include &lt;QDebug&gt;\n#include &lt;QMetaMethod&gt;\n#include &lt;ranges&gt;\n#include &lt;entt/meta/resolve.hpp&gt;\n#include &lt;fmt/format.h&gt;\n#include &lt;quite/logger.hpp&gt;\n\nDEFINE_LOGGER(method_invoker)\n\nusing namespace entt::literals;\nnamespace quite::probe\n{\nnamespace\n{\nstruct MetaValueDeleter\n{\n    QMetaType meta_type;\n    void operator()(void *value) const\n    {\n        meta_type.destroy(value);\n    }\n};\n\nResult&lt;entt::meta_any&gt; invoke_qmeta_method(entt::meta_ctx &amp;meta_context,\n                                           QObject *obj,\n                                           std::string_view qualified_method_signature,\n                                           std::span&lt;entt::meta_any&gt; params)\n{\n    auto &amp;&amp;meta_obj = obj-&gt;metaObject();\n    const QByteArray normalized_method_signature = QMetaObject::normalizedSignature(qualified_method_signature.data());\n    const auto method_index = meta_obj-&gt;indexOfMethod(normalized_method_signature);\n    auto &amp;&amp;meta_method = meta_obj-&gt;method(method_index);\n    if (method_index &lt; 0)\n    {\n        return std::unexpected{Error{\n            .code = ErrorCode::invalid_argument,\n            .message =\n                fmt::format(\"Could a method for {} of type {}\", qualified_method_signature, meta_obj-&gt;className())}};\n    }\n\n    if (meta_method.parameterCount() != params.size())\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Method {} expects {} arguments but only {} were passed\",\n                                             qualified_method_signature,\n                                             meta_method.parameterCount(),\n                                             params.size()));\n    }\n\n    using MetaValue = std::unique_ptr&lt;void, MetaValueDeleter&gt;;\n\n    auto create_meta_value = [](QMetaType meta_type) -&gt; MetaValue {\n        MetaValueDeleter deleter{.meta_type = std::move(meta_type)};\n        return MetaValue{deleter.meta_type.create(), std::move(deleter)};\n    };\n    std::vector&lt;MetaValue&gt; args{};\n    args.reserve(1 + meta_method.parameterCount());\n    // return value ALWAYS at the first position\n    args.emplace_back(create_meta_value(meta_method.returnMetaType()));\n\n    for (int i = 0; i &lt; meta_method.parameterCount(); i++)\n    {\n        const auto param_meta_type = meta_method.parameterMetaType(i);\n        const auto &amp;param_value = params[i];\n\n        const QMetaType *any_meta_type = param_value.type().custom();\n\n        // first try to convert with Qt. If that fails, try to convert with the custom meta system.\n        if (any_meta_type != nullptr and QMetaType::canConvert(*any_meta_type, param_meta_type))\n        {\n            auto &amp;&amp;value = args.emplace_back(create_meta_value(param_meta_type));\n            QMetaType::convert(*any_meta_type, param_value.base().data(), param_meta_type, value.get());\n        }\n        else if (auto param_meta_value =\n                     param_value.allow_cast(entt::resolve(entt::hashed_string{param_meta_type.name()}.value()));\n                 param_meta_value)\n        {\n            auto &amp;&amp;value = args.emplace_back(create_meta_value(param_meta_type));\n            param_meta_value.type().from_void(value.get(), false).assign(std::move(param_value));\n        }\n        else\n        {\n            return make_error_result(ErrorCode::invalid_argument,\n                                     fmt::format(\"Could convert arg {} with base type {} to type {}\",\n                                                 i,\n                                                 param_value.type().info().name(),\n                                                 param_meta_type.name()));\n        }\n    }\n\n    std::vector&lt;void *&gt; meta_call_args;\n    meta_call_args.reserve(args.size());\n\n    std::ranges::copy(std::views::transform(args, [](auto &amp;&amp;val) { return val.get(); }),\n                      std::back_inserter(meta_call_args));\n    const auto call_result = obj-&gt;qt_metacall(QMetaObject::Call::InvokeMetaMethod, method_index, meta_call_args.data());\n\n    LOG_DEBUG(method_invoker(), \"Return type: {}\", meta_method.returnMetaType().name());\n    const auto custom_meta_type =\n        entt::resolve(meta_context, entt::hashed_string{meta_method.returnMetaType().name()}.value());\n    if (call_result &lt; 0)\n    {\n        if (meta_method.returnMetaType() == QMetaType::fromType&lt;void&gt;())\n        {\n            return entt::meta_any{std::in_place_type&lt;void&gt;};\n        }\n        if (custom_meta_type)\n        {\n            constexpr bool kTransferOwnership{true};\n            // args[0] is always the return type.\n            return custom_meta_type.from_void(args[0].release(), kTransferOwnership);\n        }\n    }\n    return make_error_result(ErrorCode::cancelled,\n                             fmt::format(\"Could not invoke or wrap return type. Call status = {}, convertible = \",\n                                         call_result,\n                                         static_cast&lt;bool&gt;(custom_meta_type)));\n}\n} // namespace\n\nMethodInvoker::MethodInvoker()\n{}\n\nResult&lt;entt::meta_any&gt; MethodInvoker::invoke_method(const entt::meta_any &amp;object,\n                                                    std::string_view qualified_method_signature,\n                                                    std::span&lt;entt::meta_any&gt; params) const\n{\n    const auto *object_ref = object.try_cast&lt;QObject *&gt;();\n    if (object_ref != nullptr)\n    {\n        auto &amp;value_registy = entt::locator&lt;ValueRegistry&gt;::value_or();\n        return invoke_qmeta_method(value_registy.context(), *object_ref, qualified_method_signature, params);\n    }\n    return make_error_result(ErrorCode::invalid_argument, \"Could find a qobject for the given base type\");\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/method__invoker_8hpp/","title":"File method_invoker.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; method_invoker.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;quite/result.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> </ul>"},{"location":"quite/method__invoker_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/method__invoker_8hpp/#classes","title":"Classes","text":"Type Name class MethodInvoker <p>The documentation for this class was generated from the following file <code>libs/probeqt/method_invoker.hpp</code></p>"},{"location":"quite/method__invoker_8hpp_source/","title":"File method_invoker.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; method_invoker.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;span&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;quite/result.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n\nnamespace quite::probe\n{\nclass ObjectTracker;\nclass MethodInvoker\n{\n  public:\n    MethodInvoker();\n\n    Result&lt;entt::meta_any&gt; invoke_method(const entt::meta_any &amp;object,\n                                         std::string_view qualified_method_signature,\n                                         std::span&lt;entt::meta_any&gt; params) const;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/object__tracker_8cpp/","title":"File object_tracker.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; object_tracker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"object_tracker.hpp\"</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QMetaProperty&gt;</code></li> <li><code>#include &lt;QThread&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> <li><code>#include &lt;QtQml/private/qqmldata_p.h&gt;</code></li> <li><code>#include &lt;QtQml/private/qqmlmetatype_p.h&gt;</code></li> <li><code>#include &lt;entt/meta/factory.hpp&gt;</code></li> <li><code>#include &lt;fmt/ranges.h&gt;</code></li> <li><code>#include &lt;private/qv4executablecompilationunit_p.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/meta_any_formatter.hpp&gt;</code></li> <li><code>#include \"qt_meta_type_accessor.hpp\"</code></li> <li><code>#include \"to_object_id.hpp\"</code></li> </ul>"},{"location":"quite/object__tracker_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/object_tracker.cpp</code></p>"},{"location":"quite/object__tracker_8cpp_source/","title":"File object_tracker.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; object_tracker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"object_tracker.hpp\"\n#include &lt;QDebug&gt;\n#include &lt;QMetaProperty&gt;\n#include &lt;QThread&gt;\n#include &lt;QVariant&gt;\n#include &lt;QtQml/private/qqmldata_p.h&gt;\n#include &lt;QtQml/private/qqmlmetatype_p.h&gt;\n#include &lt;entt/meta/factory.hpp&gt;\n#include &lt;fmt/ranges.h&gt;\n#include &lt;private/qv4executablecompilationunit_p.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/meta_any_formatter.hpp&gt;\n#include \"qt_meta_type_accessor.hpp\"\n#include \"to_object_id.hpp\"\n\nDEFINE_LOGGER(object_tracker_logger)\n\nnamespace\n{\nclass InOwnContext final\n{\n  public:\n    InOwnContext(std::atomic_bool &amp;context)\n        : context_{context}\n    {\n        context_ = true;\n    }\n    ~InOwnContext()\n    {\n        context_ = false;\n    }\n\n  private:\n    std::atomic_bool &amp;context_;\n};\n} // namespace\nnamespace quite::probe\n{\n\nObjectTracker::ObjectTracker()\n{\n    tracked_objects_.reserve(10000);\n    init_timer_.setInterval(0);\n    init_timer_.setSingleShot(true);\n    connect(&amp;init_timer_, &amp;QTimer::timeout, this, &amp;ObjectTracker::process_new_objects);\n}\nObjectTracker::~ObjectTracker() = default;\n\nvoid ObjectTracker::process_new_objects()\n{\n    std::unique_lock l{locker_};\n    for (auto &amp;&amp;obj : objects_to_track_)\n    {\n        // dump_props(obj);\n        if (obj-&gt;parent() == nullptr and obj-&gt;isWindowType())\n        {\n            top_level_views_.emplace(obj);\n        }\n        tracked_objects_.emplace(obj);\n    }\n    objects_to_track_.clear();\n}\n\nvoid ObjectTracker::add_object(QObject *obj)\n{\n    if (own_ctx_)\n    {\n        return;\n    }\n    std::unique_lock l{locker_};\n    InOwnContext c{own_ctx_};\n    connect(obj, &amp;QObject::destroyed, this, [this, obj]() { remove_object((obj)); });\n    objects_to_track_.emplace(obj);\n    start_timer();\n}\n\nconst std::unordered_set&lt;QObject *&gt; &amp;ObjectTracker::top_level_views() const\n{\n    return top_level_views_;\n}\n\nResult&lt;ObjectReference&gt; ObjectTracker::find_object(const std::string &amp;object_name) const\n{\n    std::shared_lock l{locker_};\n    InOwnContext c{own_ctx_};\n    for (auto &amp;&amp;obj : tracked_objects_)\n    {\n        if (obj-&gt;objectName() == QString::fromStdString(object_name))\n        {\n            return ObjectReference{\n                .object_id = to_object_id(obj),\n                .type_id = static_cast&lt;meta::TypeId&gt;(try_get_qt_meta_type(obj).id()),\n            };\n        }\n    }\n    return make_error_result(ErrorCode::not_found, fmt::format(\"Could not found object with name {}\", object_name));\n}\n\nnamespace\n{\nbool operator==(const QVariant &amp;variant, const entt::meta_any &amp;value)\n{\n    auto custom_meta_type = entt::resolve(entt::hashed_string{variant.metaType().name()}.value());\n    if (not custom_meta_type)\n    {\n        LOG_DEBUG(object_tracker_logger(), \"no custom_meta_type\");\n        return false;\n    }\n    const auto any_obj = custom_meta_type.from_void(variant.data());\n    const entt::meta_any casted_value = any_obj.allow_cast(value.type());\n\n    LOG_TRACE_L3(object_tracker_logger(),\n                 \"custom_meta_type: {} cmp with casted value: {}\",\n                 fmt::format(\"{}\", any_obj),\n                 fmt::format(\"{}\", casted_value));\n    return casted_value == value;\n}\n\nbool match_property(QObject *object, std::string_view property_name, const entt::meta_any &amp;value)\n{\n    const auto property_value = object-&gt;property(property_name.cbegin());\n    return property_value.isValid() and property_value == value;\n}\n\nstd::string get_class_name(QObject *object)\n{\n    const QMetaObject *meta_obj = try_get_qt_meta_object(object);\n    if (meta_obj == nullptr)\n    {\n        return {};\n    }\n\n    std::string_view class_name = meta_obj-&gt;className();\n    // Remove QML-generated suffixes\n    if (auto pos = class_name.find(\"_QMLTYPE_\"); pos != std::string_view::npos)\n    {\n        class_name = class_name.substr(0, pos);\n    }\n    else if (auto pos = class_name.find(\"_QML_\"); pos != std::string_view::npos)\n    {\n        class_name = class_name.substr(0, pos);\n    }\n    return std::string{class_name};\n}\n} // namespace\nResult&lt;ObjectReference&gt; ObjectTracker::find_object_by_query(const ObjectQuery &amp;query) const\n{\n    std::shared_lock l{locker_};\n    InOwnContext c{own_ctx_};\n\n    // Helper function to recursively match the parent hierarchy\n    const auto match_parent_hierarchy = [](QObject *object, const std::shared_ptr&lt;ObjectQuery&gt; &amp;query) -&gt; bool {\n        QObject *current_parent = object-&gt;parent();\n        auto current_query = query;\n\n        while (current_query &amp;&amp; current_parent)\n        {\n            bool matched =\n                current_query-&gt;type_name.empty() or\n                (not current_query-&gt;type_name.empty() and get_class_name(current_parent) == current_query-&gt;type_name);\n            if (matched)\n            {\n                // Check if the current parent matches the current query\n                for (auto &amp;&amp;[prop_name, prop_value] : current_query-&gt;properties)\n                {\n                    if (not match_property(current_parent, prop_name, prop_value))\n                    {\n                        current_parent = current_parent-&gt;parent();\n                        matched = false;\n                        break;\n                    }\n                    matched = true;\n                }\n            }\n\n            if (matched)\n            {\n                // Move up the hierarchy\n                current_parent = current_parent-&gt;parent();\n                current_query = current_query-&gt;container;\n            }\n        }\n\n        return current_query == nullptr;\n    };\n\n    for (auto &amp;&amp;obj : tracked_objects_)\n    {\n        // First, check if the parent hierarchy matches\n        if (query.container &amp;&amp; !match_parent_hierarchy(obj, query.container))\n        {\n            continue;\n        }\n        const bool name_matched =\n            query.type_name.empty() or (not query.type_name.empty() and get_class_name(obj) == query.type_name);\n\n        // Then, check if the properties of the current object match\n        bool property_matches = true;\n        if (name_matched)\n        {\n            for (auto &amp;&amp;[prop_name, prop_value] : query.properties)\n            {\n                if (not match_property(obj, prop_name, prop_value))\n                {\n                    property_matches = false;\n                    break;\n                }\n            }\n        }\n\n        if (name_matched and property_matches)\n        {\n            return ObjectReference{.object_id = to_object_id(obj),\n                                   .type_id = static_cast&lt;meta::TypeId&gt;(try_get_qt_meta_type(obj).id())};\n        }\n    }\n\n    return make_error_result(ErrorCode::not_found, fmt::format(\"Could not find requested object by query {}\", query));\n}\n\nResult&lt;QObject *&gt; ObjectTracker::get_object_by_id(ObjectId obj_id) const\n{\n    std::shared_lock l{locker_};\n    InOwnContext c{own_ctx_};\n    auto it = tracked_objects_.find(from_object_id(obj_id));\n    if (it != tracked_objects_.end())\n    {\n        return *it;\n    }\n    return make_error_result(ErrorCode::not_found, fmt::format(\"Could not find object with id {}\", obj_id));\n}\n\nvoid ObjectTracker::remove_object(QObject *obj)\n{\n    std::unique_lock l{locker_};\n    InOwnContext c{own_ctx_};\n    if (const auto it = objects_to_track_.find(obj); it != objects_to_track_.end())\n    {\n        LOG_TRACE_L1(object_tracker_logger(), \"remove obj from objects_to_track {}\", obj-&gt;objectName().toStdString());\n        objects_to_track_.erase(it);\n    }\n    else if (const auto it = tracked_objects_.find(obj); it != tracked_objects_.end())\n    {\n        LOG_TRACE_L1(object_tracker_logger(), \"remove obj from tracked_objects {}\", obj-&gt;objectName().toStdString());\n        tracked_objects_.erase(it);\n    }\n    if (const auto it = top_level_views_.find(obj); it != top_level_views_.end())\n    {\n        top_level_views_.erase(it);\n    }\n}\n\nvoid ObjectTracker::start_timer()\n{\n    QMetaObject::invokeMethod(this, &amp;ObjectTracker::process_new_objects, Qt::ConnectionType::QueuedConnection);\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/object__tracker_8hpp/","title":"File object_tracker.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; object_tracker.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;expected&gt;</code></li> <li><code>#include &lt;shared_mutex&gt;</code></li> <li><code>#include &lt;unordered_set&gt;</code></li> <li><code>#include &lt;quite/meta/meta_type_id.hpp&gt;</code></li> <li><code>#include &lt;quite/result.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> </ul>"},{"location":"quite/object__tracker_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/object__tracker_8hpp/#classes","title":"Classes","text":"Type Name class ObjectTracker <p>The documentation for this class was generated from the following file <code>libs/probeqt/object_tracker.hpp</code></p>"},{"location":"quite/object__tracker_8hpp_source/","title":"File object_tracker.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; object_tracker.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QObject&gt;\n#include &lt;QTimer&gt;\n#include &lt;expected&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;unordered_set&gt;\n#include &lt;quite/meta/meta_type_id.hpp&gt;\n#include &lt;quite/result.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n\nnamespace quite::probe\n{\nclass ObjectTracker final : public QObject\n{\n    Q_OBJECT\n  public:\n    Q_DISABLE_COPY_MOVE(ObjectTracker)\n    ObjectTracker();\n    ~ObjectTracker() override;\n\n    void add_object(QObject *);\n    void remove_object(QObject *);\n    const std::unordered_set&lt;QObject *&gt; &amp;top_level_views() const;\n    Result&lt;ObjectReference&gt; find_object(const std::string &amp;object_name) const;\n    Result&lt;ObjectReference&gt; find_object_by_query(const ObjectQuery &amp;query) const;\n    Result&lt;QObject *&gt; get_object_by_id(ObjectId obj_id) const;\n\n  private:\n    void start_timer();\n    void process_new_objects();\n\n  private:\n    mutable std::atomic_bool own_ctx_{false};\n    mutable std::shared_mutex locker_;\n    QTimer init_timer_;\n    std::unordered_set&lt;QObject *&gt; objects_to_track_;\n    std::unordered_set&lt;QObject *&gt; tracked_objects_;\n    std::unordered_set&lt;QObject *&gt; top_level_views_;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/probe__context_8cpp/","title":"File probe_context.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; probe_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"probe_context.hpp\"</code></li> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;csignal&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"value_converters.hpp\"</code></li> </ul>"},{"location":"quite/probe__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/probe_context.cpp</code></p>"},{"location":"quite/probe__context_8cpp_source/","title":"File probe_context.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; probe_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"probe_context.hpp\"\n#include &lt;QCoreApplication&gt;\n#include &lt;csignal&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"value_converters.hpp\"\n\nDEFINE_LOGGER(probe_ctx_logger)\n\nnamespace quite::probe\n{\n\nnamespace\n{\nvoid quite_add_object(QObject *q);\nvoid quite_remove_object(QObject *q);\nvoid quite_app_startup();\n} // namespace\n\nProbeContext::ProbeContext(std::string server_address)\n    : server_{std::move(server_address), probe_handler_, mouse_injector_, meta_registry_, value_registry_}\n{\n    quite::probe::register_converters(*value_registry_);\n    install_qt_hooks();\n}\n\nProbeContext::~ProbeContext()\n{\n    qtHookData[QHooks::AddQObject] = reinterpret_cast&lt;quintptr&gt;(next_add_qobject_hook_);\n    qtHookData[QHooks::RemoveQObject] = reinterpret_cast&lt;quintptr&gt;(next_remove_qobject_hook_);\n    qtHookData[QHooks::Startup] = reinterpret_cast&lt;quintptr&gt;(next_startup_hook_);\n}\n\nvoid ProbeContext::install_qt_hooks()\n{\n    Q_ASSERT(qtHookData[QHooks::HookDataVersion] &gt;= 1);\n    Q_ASSERT(qtHookData[QHooks::HookDataSize] &gt;= 6);\n\n    const auto qt_version_number = qtHookData[QHooks::QtVersion];\n    const auto qt_major = (qt_version_number &gt;&gt; 16) &amp; 0xFF;\n    const auto qt_minor = (qt_version_number &gt;&gt; 8) &amp; 0xFF;\n    const auto qt_patch = qt_version_number &amp; 0xFF;\n\n    LOG_INFO(probe_ctx_logger(), \"Installing Qt hooks for Qt version {}.{}.{}\", qt_major, qt_minor, qt_patch);\n\n    next_add_qobject_hook_ = reinterpret_cast&lt;QHooks::AddQObjectCallback&gt;(qtHookData[QHooks::AddQObject]);\n    next_remove_qobject_hook_ = reinterpret_cast&lt;QHooks::RemoveQObjectCallback&gt;(qtHookData[QHooks::RemoveQObject]);\n    next_startup_hook_ = reinterpret_cast&lt;QHooks::StartupCallback&gt;(qtHookData[QHooks::Startup]);\n\n    qtHookData[QHooks::AddQObject] = reinterpret_cast&lt;quintptr&gt;(&amp;quite_add_object);\n    qtHookData[QHooks::RemoveQObject] = reinterpret_cast&lt;quintptr&gt;(&amp;quite_remove_object);\n    qtHookData[QHooks::Startup] = reinterpret_cast&lt;quintptr&gt;(&amp;quite_app_startup);\n\n    if (QCoreApplication::instance() != nullptr)\n    {\n        install_application_hooks();\n    }\n}\n\nvoid ProbeContext::install_application_hooks()\n{\n    LOG_INFO(probe_ctx_logger(), \"installing QCoreApplication signals...\");\n}\n\nvoid ProbeContext::qt_hook_add_object(QObject *q)\n{\n    object_tracker_.add_object(q);\n    if (next_add_qobject_hook_ != nullptr)\n    {\n        next_add_qobject_hook_(q);\n    }\n}\n\nvoid ProbeContext::qt_hook_remove_object(QObject *q)\n{\n    object_tracker_.remove_object(q);\n    if (next_remove_qobject_hook_ != nullptr)\n    {\n        next_remove_qobject_hook_(q);\n    }\n}\n\nvoid ProbeContext::qt_hook_startup()\n{\n    install_application_hooks();\n    if (next_startup_hook_ != nullptr)\n    {\n        next_startup_hook_();\n    }\n}\n\nnamespace\n{\nvoid quite_add_object(QObject *q)\n{\n    auto &amp;&amp;probe_context_handle = entt::locator&lt;ProbeContext&gt;::value();\n    probe_context_handle.qt_hook_add_object(q);\n}\n\nvoid quite_remove_object(QObject *q)\n{\n    auto &amp;&amp;probe_context_handle = entt::locator&lt;ProbeContext&gt;::value();\n    probe_context_handle.qt_hook_remove_object(q);\n}\n\nvoid quite_app_startup()\n{\n    auto &amp;&amp;probe_context_handle = entt::locator&lt;ProbeContext&gt;::value();\n    probe_context_handle.qt_hook_startup();\n}\n} // namespace\n\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/probe__context_8hpp/","title":"File probe_context.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; probe_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;private/qhooks_p.h&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe/server.hpp&gt;</code></li> <li><code>#include \"injector/mouse_injector.hpp\"</code></li> <li><code>#include \"object_tracker.hpp\"</code></li> <li><code>#include \"qt_meta_registry.hpp\"</code></li> <li><code>#include \"qt_probe_handler.hpp\"</code></li> </ul>"},{"location":"quite/probe__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/probe__context_8hpp/#classes","title":"Classes","text":"Type Name class ProbeContext <p>The documentation for this class was generated from the following file <code>libs/probeqt/probe_context.hpp</code></p>"},{"location":"quite/probe__context_8hpp_source/","title":"File probe_context.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; probe_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;private/qhooks_p.h&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/proto/probe/server.hpp&gt;\n#include \"injector/mouse_injector.hpp\"\n#include \"object_tracker.hpp\"\n#include \"qt_meta_registry.hpp\"\n#include \"qt_probe_handler.hpp\"\n\nnamespace quite::probe\n{\nclass ProbeContext final\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(ProbeContext);\n    explicit ProbeContext(std::string server_address);\n    ~ProbeContext();\n\n    void qt_hook_add_object(QObject *q);\n    void qt_hook_remove_object(QObject *q);\n    void qt_hook_startup();\n\n  private:\n    void install_qt_hooks();\n    void install_application_hooks();\n\n  private:\n    quite::probe::ObjectTracker object_tracker_;\n    ServiceHandle&lt;proto::IProbeHandler&gt; probe_handler_{std::make_shared&lt;QtProbeHandler&gt;(object_tracker_)};\n    ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector_{std::make_shared&lt;MouseInjector&gt;(object_tracker_)};\n    ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry_{std::make_shared&lt;QtMetaRegistry&gt;()};\n    ServiceHandle&lt;ValueRegistry&gt; value_registry_{std::in_place};\n    quite::proto::Server server_;\n\n    QHooks::AddQObjectCallback next_add_qobject_hook_{nullptr};\n    QHooks::RemoveQObjectCallback next_remove_qobject_hook_{nullptr};\n    QHooks::StartupCallback next_startup_hook_{nullptr};\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/property__collector_8cpp/","title":"File property_collector.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; property_collector.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"property_collector.hpp\"</code></li> <li><code>#include &lt;QMetaProperty&gt;</code></li> <li><code>#include &lt;QQmlListReference&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;entt/meta/factory.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/meta_any_formatter.hpp&gt;</code></li> <li><code>#include &lt;quite/value/generic_value_class.hpp&gt;</code></li> <li><code>#include \"qt_meta_type_accessor.hpp\"</code></li> </ul>"},{"location":"quite/property__collector_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite <p>The documentation for this class was generated from the following file <code>libs/probeqt/property_collector.cpp</code></p>"},{"location":"quite/property__collector_8cpp_source/","title":"File property_collector.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; property_collector.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"property_collector.hpp\"\n#include &lt;QMetaProperty&gt;\n#include &lt;QQmlListReference&gt;\n#include &lt;ranges&gt;\n#include &lt;entt/meta/factory.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/meta_any_formatter.hpp&gt;\n#include &lt;quite/value/generic_value_class.hpp&gt;\n#include \"qt_meta_type_accessor.hpp\"\n\nDEFINE_LOGGER(property_collector_logger)\nnamespace quite\n{\nObjectMeta ObjectMeta::from_qobject(QObject *object)\n{\n    return ObjectMeta{.object = object, .meta_object = probe::try_get_qt_meta_object(object)};\n}\n\nstd::pair&lt;std::string, entt::meta_any&gt; read_property(const QVariant property_value, const QMetaProperty &amp;property)\n{\n    entt::meta_any value;\n\n    // important: check for explicit conversions first. E.g. QQuickAnchorLine is a QGadget but should be converted with\n    // the explicit converter.\n    if (auto custom_meta_type = entt::resolve(entt::hashed_string{property.metaType().name()}.value());\n        custom_meta_type)\n    {\n        LOG_DEBUG(property_collector_logger(), \"got known type {}\", custom_meta_type.info().name());\n        // create a copy of the underlying variant object and transfer the ownership.\n        value = custom_meta_type.from_void(property_value.metaType().create(property_value.data()), true);\n    }\n    else if (property.metaType().flags().testAnyFlags(QMetaType::IsGadget | QMetaType::PointerToGadget))\n    {\n        auto &amp;&amp;gadget_metaobj = property.metaType().metaObject();\n        LOG_DEBUG(property_collector_logger(),\n                  \"prop {}={} convertible to QGadget (props={})\",\n                  property.name(),\n                  property.typeName(),\n                  gadget_metaobj-&gt;propertyCount());\n        GenericClass generic_class;\n        auto view =\n            std::ranges::iota_view(0, gadget_metaobj-&gt;propertyCount()) |\n            std::views::transform([&amp;](int prop_idx) { return gadget_metaobj-&gt;property(prop_idx); }) |\n            std::views::filter([](const QMetaProperty &amp;prop) { return prop.isValid() and prop.isReadable(); }) |\n            std::views::transform([&amp;](auto &amp;&amp;prop) {\n                return std::tuple{prop.readOnGadget(property_value.data()), std::forward&lt;decltype(prop)&gt;(prop)};\n            }) |\n            std::views::transform([&amp;](auto &amp;&amp;prop) { return read_property(std::get&lt;0&gt;(prop), std::get&lt;1&gt;(prop)); });\n        for (auto &amp;&amp;name_value : view)\n        {\n            generic_class.properties.emplace(std::forward&lt;decltype(name_value)&gt;(name_value));\n        }\n        value = std::move(generic_class);\n    }\n    else if (QQmlListReference qml_list{property_value};\n             qml_list.isValid() and qml_list.canCount() and qml_list.canAt())\n    {\n        LOG_DEBUG(property_collector_logger(),\n                  \"prop {}={} convertible to QQmlListReference\",\n                  property.name(),\n                  property.typeName());\n        const auto size = qml_list.count();\n        std::vector&lt;entt::meta_any&gt; object_list;\n        object_list.reserve(size);\n        for (qsizetype i = 0; i &lt; size; i++)\n        {\n            object_list.emplace_back(entt::forward_as_meta(qml_list.at(i)));\n        }\n        value = std::move(object_list);\n    }\n    else\n    {\n        LOG_DEBUG(property_collector_logger(), \"prop {}={} not convertible\", property.name(), property.typeName());\n    }\n    return {property.name(), std::move(value)};\n}\n\nResult&lt;void&gt; write_property(const ObjectMeta &amp;meta,\n                            const std::string &amp;property_name,\n                            const entt::meta_any &amp;property_value)\n{\n    const auto idx = meta.meta_object-&gt;indexOfProperty(property_name.c_str());\n    const auto prop = meta.meta_object-&gt;property(idx);\n\n    if (not prop.isValid())\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Property {} is not valid\", property_name));\n    }\n\n    if (not prop.isWritable())\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Property {} is not writable\", property_name));\n    }\n\n    auto &amp;&amp;variant_value = property_value.allow_cast&lt;QVariant&gt;();\n    if (not variant_value)\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Could not convert {} to QVariant\", property_value));\n    }\n\n    const auto written = prop.write(meta.object, variant_value.cast&lt;QVariant&gt;());\n\n    if (not written)\n    {\n        return make_error_result(ErrorCode::aborted,\n                                 fmt::format(\"Could not write {} to {}\", property_value, property_name));\n    }\n    return {};\n}\n\nentt::dense_map&lt;std::string, entt::meta_any&gt; collect_properties(ObjectMeta object_meta,\n                                                                std::span&lt;const std::string&gt; property_names)\n{\n    entt::dense_map&lt;std::string, entt::meta_any&gt; properties;\n\n    auto view = std::ranges::iota_view(0, object_meta.meta_object-&gt;propertyCount()) | //\n                std::views::transform([&amp;](int prop_idx) { return object_meta.meta_object-&gt;property(prop_idx); }) |\n                std::views::filter([](auto &amp;&amp;prop) { return prop.isValid() and prop.isReadable(); }) |\n                std::views::filter([&amp;property_names](auto &amp;&amp;prop) {\n                    if (property_names.size() == 0)\n                    {\n                        return true;\n                    }\n                    const auto it = std::ranges::find(property_names, prop.name());\n                    return it != property_names.end();\n                }) |\n                std::views::transform([&amp;](auto &amp;&amp;prop) {\n                    return std::tuple{prop.read(object_meta.object), std::forward&lt;decltype(prop)&gt;(prop)};\n                }) |\n                std::views::transform([&amp;](auto &amp;&amp;prop) { return read_property(std::get&lt;0&gt;(prop), std::get&lt;1&gt;(prop)); });\n    for (auto &amp;&amp;property : view)\n    {\n        properties.emplace(std::forward&lt;decltype(property)&gt;(property));\n    }\n\n    return properties;\n}\n\n} // namespace quite\n</code></pre>"},{"location":"quite/property__collector_8hpp/","title":"File property_collector.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; property_collector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMetaObject&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;quite/result.hpp&gt;</code></li> </ul>"},{"location":"quite/property__collector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/property__collector_8hpp/#classes","title":"Classes","text":"Type Name struct ObjectMeta <p>The documentation for this class was generated from the following file <code>libs/probeqt/property_collector.hpp</code></p>"},{"location":"quite/property__collector_8hpp_source/","title":"File property_collector.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; property_collector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QMetaObject&gt;\n#include &lt;QObject&gt;\n#include &lt;string&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;quite/result.hpp&gt;\n\nnamespace quite\n{\nstruct ObjectMeta\n{\n    QObject *object;\n    const QMetaObject *meta_object;\n\n    [[nodiscard]] static ObjectMeta from_qobject(QObject *object);\n};\n[[nodiscard]] std::pair&lt;std::string, entt::meta_any&gt; read_property(QVariant property_value,\n                                                                   const QMetaProperty &amp;property);\nResult&lt;void&gt; write_property(const ObjectMeta &amp;meta,\n                            const std::string &amp;property_name,\n                            const entt::meta_any &amp;property_value);\n[[nodiscard]] entt::dense_map&lt;std::string, entt::meta_any&gt; collect_properties(\n    ObjectMeta object_meta, std::span&lt;const std::string&gt; property_names);\n\n} // namespace quite\n</code></pre>"},{"location":"quite/qt__meta__registry_8cpp/","title":"File qt_meta_registry.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_meta_registry.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"qt_meta_registry.hpp\"</code></li> <li><code>#include &lt;QAssociativeIterable&gt;</code></li> <li><code>#include &lt;QMetaMethod&gt;</code></li> <li><code>#include &lt;QMetaObject&gt;</code></li> <li><code>#include &lt;QMetaProperty&gt;</code></li> <li><code>#include &lt;QMetaType&gt;</code></li> <li><code>#include &lt;QSequentialIterable&gt;</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;entt/meta/resolve.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> </ul>"},{"location":"quite/qt__meta__registry_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/qt__meta__registry_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOGGER (qt_meta_registry)"},{"location":"quite/qt__meta__registry_8cpp/#macros","title":"Macros","text":"Type Name define TRY_RETURN_PRIMITIVE (qt_meta_type, quite_type) <code>/* multi line expression */</code>"},{"location":"quite/qt__meta__registry_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/qt__meta__registry_8cpp/#function-define_logger","title":"function DEFINE_LOGGER","text":"<pre><code>DEFINE_LOGGER (\n    qt_meta_registry\n) \n</code></pre>"},{"location":"quite/qt__meta__registry_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/qt__meta__registry_8cpp/#define-try_return_primitive","title":"define TRY_RETURN_PRIMITIVE","text":"<pre><code>#define TRY_RETURN_PRIMITIVE (\n    qt_meta_type,\n    quite_type\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_registry.cpp</code></p>"},{"location":"quite/qt__meta__registry_8cpp_source/","title":"File qt_meta_registry.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_meta_registry.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"qt_meta_registry.hpp\"\n#include &lt;QAssociativeIterable&gt;\n#include &lt;QMetaMethod&gt;\n#include &lt;QMetaObject&gt;\n#include &lt;QMetaProperty&gt;\n#include &lt;QMetaType&gt;\n#include &lt;QSequentialIterable&gt;\n#include &lt;ranges&gt;\n#include &lt;entt/meta/resolve.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n\nDEFINE_LOGGER(qt_meta_registry);\n\nnamespace quite::probe\n{\nnamespace\n{\nconstexpr meta::Property from_qmetaproperty(const QMetaProperty &amp;prop)\n{\n    return meta::Property{.name = prop.name(), .type = static_cast&lt;meta::TypeId&gt;(prop.typeId())};\n}\n\nauto from_qmetamethod(const QMetaMethod &amp;method)\n{\n    meta::Method meta_method{.name = method.methodSignature().toStdString(),\n                             .return_type = static_cast&lt;meta::TypeId&gt;(method.returnType())};\n    std::ranges::copy(std::ranges::iota_view(0, method.parameterCount()) | std::views::transform([&amp;](int prop_idx) {\n                          return meta::Property{.name = method.parameterNames().at(prop_idx).toStdString(),\n                                                .type = static_cast&lt;meta::TypeId&gt;(method.parameterType(prop_idx))};\n                      }),\n                      std::back_inserter(meta_method.parameters));\n    return meta_method;\n}\n\nResult&lt;meta::Type&gt; convert_enum_type(QMetaType type)\n{\n    LOG_DEBUG(qt_meta_registry(), \"Converting to enum. Name {}\", type.name());\n    auto meta_enum = std::make_unique&lt;meta::EnumType&gt;();\n    meta_enum-&gt;id = type.id();\n    meta_enum-&gt;name = type.name();\n    const QMetaObject *meta_object = type.metaObject();\n    if (type.metaObject() == nullptr)\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Could not get a QMetaObject from '{}'\", type.name()));\n    }\n\n    // the indexOfEnumerator function expect the simple name, but the type.name() always returns the fully qualified\n    // name\n    const std::string_view qualified_enum_name = type.name();\n    std::string_view simple_enum_name = qualified_enum_name;\n    const auto ns_end_pos = qualified_enum_name.find_last_of(':');\n    if (ns_end_pos != std::string_view::npos)\n    {\n        simple_enum_name = qualified_enum_name.substr(ns_end_pos + 1);\n    }\n    const auto enum_idx = meta_object-&gt;indexOfEnumerator(simple_enum_name.begin());\n    if (enum_idx &lt; 0)\n    {\n        return make_error_result(ErrorCode::failed_precondition,\n                                 fmt::format(\"Could not find enum index of type '{}' in enclosing type '{}'\",\n                                             type.name(),\n                                             meta_object-&gt;className()));\n    }\n    const auto qt_meta_enum = meta_object-&gt;enumerator(enum_idx);\n\n    std::ranges::for_each(\n        std::ranges::iota_view(0, qt_meta_enum.keyCount()) | std::views::transform([&amp;](int index) {\n            return std::make_pair&lt;meta::EnumType::ValueName, std::int64_t&gt;(qt_meta_enum.key(index),\n                                                                           qt_meta_enum.value(index));\n        }),\n        [&amp;meta_enum](auto &amp;&amp;enum_value) { meta_enum-&gt;values.emplace(std::forward&lt;decltype(enum_value)&gt;(enum_value)); });\n\n    return meta_enum;\n}\n\nResult&lt;meta::Type&gt; convert_list_type(QMetaType list_type, QMetaType containing_type)\n{\n    LOG_DEBUG(qt_meta_registry(), \"List type '{}' with containing type '{}'\", list_type.name(), containing_type.name());\n\n    return meta::ListType{.id = static_cast&lt;meta::TypeId&gt;(list_type.id()),\n                          .name = list_type.name(),\n                          .value_type = static_cast&lt;meta::TypeId&gt;(containing_type.id())};\n}\n\nResult&lt;meta::Type&gt; convert_map_type(QMetaType map_type, QMetaType key_type, QMetaType value_type)\n{\n    LOG_DEBUG(qt_meta_registry(), \"Map type: {} k: {} v: {}\", map_type.name(), key_type.name(), value_type.name());\n\n    return meta::MapType{\n        .id = static_cast&lt;meta::TypeId&gt;(map_type.id()),\n        .name = map_type.name(),\n        .key_type = static_cast&lt;meta::TypeId&gt;(key_type.id()),\n        .value_type = static_cast&lt;meta::TypeId&gt;(value_type.id()),\n    };\n}\n\nResult&lt;meta::Type&gt; convert_object_type(QMetaType type)\n{\n    QVariant meta_type_instance;\n    if (type.flags().testFlag(QMetaType::TypeFlag::NeedsConstruction))\n    {\n        meta_type_instance = QVariant{type};\n        if (type.metaObject() == nullptr)\n        {\n            if (meta_type_instance.canConvert&lt;QVariantList&gt;())\n            {\n                const auto iterable = meta_type_instance.value&lt;QSequentialIterable&gt;();\n                return convert_list_type(type, iterable.metaContainer().valueMetaType());\n            }\n            if (meta_type_instance.canConvert&lt;QVariantMap&gt;())\n            {\n                const auto iterable = meta_type_instance.value&lt;QAssociativeIterable&gt;();\n                return convert_map_type(\n                    type, iterable.metaContainer().keyMetaType(), iterable.metaContainer().mappedMetaType());\n            }\n            return make_error_result(\n                ErrorCode::failed_precondition,\n                fmt::format(\"Could not create an instance of '{}'. Type is default constructible ={}\",\n                            type.name(),\n                            type.flags().testFlag(QMetaType::TypeFlag::NeedsConstruction)));\n        }\n    }\n\n    const QMetaObject *meta_object = type.metaObject();\n    if (meta_object == nullptr)\n    {\n        return make_error_result(ErrorCode::failed_precondition, \"Could not create a meta type from object\");\n    }\n    std::unique_ptr&lt;meta::ObjectType&gt; obj = std::make_unique&lt;meta::ObjectType&gt;();\n    obj-&gt;name = meta_object-&gt;className();\n    obj-&gt;id = type.id();\n\n    std::ranges::copy(std::ranges::iota_view(0, meta_object-&gt;propertyCount()) |\n                          std::views::transform([&amp;](int prop_idx) { return meta_object-&gt;property(prop_idx); }) |\n                          std::views::transform(from_qmetaproperty),\n                      std::back_inserter(obj-&gt;properties));\n\n    std::ranges::copy(std::ranges::iota_view(0, meta_object-&gt;constructorCount()) |\n                          std::views::transform([&amp;](int prop_idx) { return meta_object-&gt;constructor(prop_idx); }) |\n                          std::views::transform(from_qmetamethod),\n                      std::back_inserter(obj-&gt;constructors));\n\n    std::ranges::copy(std::ranges::iota_view(0, meta_object-&gt;methodCount()) | std::views::transform([&amp;](int prop_idx) {\n                          return meta_object-&gt;method(prop_idx);\n                      }) | std::views::transform(from_qmetamethod),\n                      std::back_inserter(obj-&gt;methods));\n\n    return meta::Type{std::move(obj)};\n}\n\n#define TRY_RETURN_PRIMITIVE(qt_meta_type, quite_type)                                                                 \\\n    if (type.id() == (qt_meta_type))                                                                                   \\\n    {                                                                                                                  \\\n        return meta::Type{quite_type};                                                                                 \\\n    }\n\nResult&lt;meta::Type&gt; convert(QMetaType type)\n{\n    if (type.flags().testFlag(QMetaType::TypeFlag::IsEnumeration))\n    {\n        return convert_enum_type(type);\n    }\n    TRY_RETURN_PRIMITIVE(QMetaType::UnknownType, meta::PrimitiveType::type_unknown);\n    TRY_RETURN_PRIMITIVE(QMetaType::Void, meta::PrimitiveType::type_void);\n    TRY_RETURN_PRIMITIVE(QMetaType::Int, meta::PrimitiveType::type_int);\n    TRY_RETURN_PRIMITIVE(QMetaType::UInt, meta::PrimitiveType::type_uint);\n    TRY_RETURN_PRIMITIVE(QMetaType::Float, meta::PrimitiveType::type_float);\n    TRY_RETURN_PRIMITIVE(QMetaType::Double, meta::PrimitiveType::type_double);\n    TRY_RETURN_PRIMITIVE(QMetaType::Bool, meta::PrimitiveType::type_bool);\n    TRY_RETURN_PRIMITIVE(QMetaType::QString, meta::PrimitiveType::type_string);\n\n    return convert_object_type(type);\n}\n} // namespace\n\nAsyncResult&lt;meta::Type&gt; QtMetaRegistry::lookup_type(meta::TypeId type_id)\n{\n    auto qt_meta_result = QMetaType{static_cast&lt;int&gt;(type_id)};\n    if (qt_meta_result.isValid())\n    {\n        co_return convert(qt_meta_result);\n    }\n\n    auto internal_result = entt::resolve(type_id);\n    if (internal_result)\n    {\n    }\n\n    co_return make_error_result(ErrorCode::not_found, fmt::format(\"Could not find type with id '{}'\", type_id));\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qt__meta__registry_8hpp/","title":"File qt_meta_registry.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_meta_registry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> </ul>"},{"location":"quite/qt__meta__registry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/qt__meta__registry_8hpp/#classes","title":"Classes","text":"Type Name class QtMetaRegistry <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_registry.hpp</code></p>"},{"location":"quite/qt__meta__registry_8hpp_source/","title":"File qt_meta_registry.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_meta_registry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/meta/meta_registry.hpp&gt;\n\nnamespace quite::probe\n{\nclass QtMetaRegistry : public meta::MetaRegistry\n{\n  public:\n    AsyncResult&lt;meta::Type&gt; lookup_type(meta::TypeId type_id) override;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qt__meta__type__accessor_8cpp/","title":"File qt_meta_type_accessor.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_meta_type_accessor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"qt_meta_type_accessor.hpp\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QtQml/private/qqmldata_p.h&gt;</code></li> <li><code>#include &lt;QtQml/private/qqmlmetatype_p.h&gt;</code></li> <li><code>#include &lt;private/qv4executablecompilationunit_p.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"to_object_id.hpp\"</code></li> </ul>"},{"location":"quite/qt__meta__type__accessor_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_type_accessor.cpp</code></p>"},{"location":"quite/qt__meta__type__accessor_8cpp_source/","title":"File qt_meta_type_accessor.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_meta_type_accessor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"qt_meta_type_accessor.hpp\"\n#include &lt;QObject&gt;\n#include &lt;QtQml/private/qqmldata_p.h&gt;\n#include &lt;QtQml/private/qqmlmetatype_p.h&gt;\n#include &lt;private/qv4executablecompilationunit_p.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"to_object_id.hpp\"\n\nDEFINE_LOGGER(qt_meta_type_accessor)\n\nnamespace quite::probe\n{\nconst QMetaObject *try_get_qt_meta_object(const QObject *object)\n{\n    QPointer p{object};\n    if (p.isNull())\n    {\n        LOG_DEBUG(qt_meta_type_accessor(), \"Could not get a meta object from a null object\");\n        return nullptr;\n    }\n\n    const QMetaObject *meta_object{nullptr};\n    if (object-&gt;metaObject() != nullptr)\n    {\n        return object-&gt;metaObject();\n    }\n    auto &amp;&amp;data = QQmlData::get(object);\n    if (data != nullptr or not data-&gt;compilationUnit)\n    {\n        LOG_DEBUG(qt_meta_type_accessor(), \"Could not get any data from object {}\", to_object_id(object));\n        return nullptr;\n    }\n    const auto qml_type = QQmlMetaType::qmlType(data-&gt;compilationUnit-&gt;url());\n    if (qml_type.metaObject() == nullptr)\n    {\n        LOG_DEBUG(qt_meta_type_accessor(),\n                  \"Could not get QQmlMetaType from compilation unit. Object: {}\",\n                  to_object_id(object));\n        return nullptr;\n    }\n    return qml_type.metaObject();\n}\n\nQMetaType try_get_qt_meta_type(const QMetaObject *meta_object)\n{\n    if (meta_object == nullptr)\n    {\n        LOG_DEBUG(qt_meta_type_accessor(), \"Could get meta type from null object\");\n        return QMetaType{};\n    }\n    auto meta_type = meta_object-&gt;metaType();\n    if (not meta_type.isValid())\n    {\n        LOG_DEBUG(qt_meta_type_accessor(), \"Not a valid meta type, trying with the superclass\");\n        meta_type = try_get_qt_meta_type(meta_object-&gt;superClass());\n    }\n    return meta_type;\n}\n\nQMetaType try_get_qt_meta_type(const QObject *object)\n{\n    return try_get_qt_meta_type(try_get_qt_meta_object(object));\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qt__meta__type__accessor_8hpp/","title":"File qt_meta_type_accessor.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_meta_type_accessor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMetaType&gt;</code></li> </ul>"},{"location":"quite/qt__meta__type__accessor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_meta_type_accessor.hpp</code></p>"},{"location":"quite/qt__meta__type__accessor_8hpp_source/","title":"File qt_meta_type_accessor.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_meta_type_accessor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QMetaType&gt;\nnamespace quite::probe\n{\nconst QMetaObject *try_get_qt_meta_object(const QObject *object);\nQMetaType try_get_qt_meta_type(const QMetaObject *meta_object);\nQMetaType try_get_qt_meta_type(const QObject *object);\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qt__probe__handler_8cpp/","title":"File qt_probe_handler.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_probe_handler.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"qt_probe_handler.hpp\"</code></li> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QQuickItem&gt;</code></li> <li><code>#include &lt;QQuickItemGrabResult&gt;</code></li> <li><code>#include &lt;QQuickWindow&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"object_tracker.hpp\"</code></li> <li><code>#include \"property_collector.hpp\"</code></li> <li><code>#include \"qt_meta_type_accessor.hpp\"</code></li> <li><code>#include \"qtstdexec.h\"</code></li> <li><code>#include \"to_object_id.hpp\"</code></li> </ul>"},{"location":"quite/qt__probe__handler_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_probe_handler.cpp</code></p>"},{"location":"quite/qt__probe__handler_8cpp_source/","title":"File qt_probe_handler.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_probe_handler.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"qt_probe_handler.hpp\"\n#include &lt;QPointer&gt;\n#include &lt;QQuickItem&gt;\n#include &lt;QQuickItemGrabResult&gt;\n#include &lt;QQuickWindow&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"object_tracker.hpp\"\n#include \"property_collector.hpp\"\n#include \"qt_meta_type_accessor.hpp\"\n#include \"qtstdexec.h\"\n#include \"to_object_id.hpp\"\n\nDEFINE_LOGGER(qt_probe_handler)\n\nnamespace quite::probe\n{\nAsyncResult&lt;QImage&gt; take_snapshot_of_qobject(QObject *object)\n{\n    if (object-&gt;isQuickItemType())\n    {\n        if (auto *item = qobject_cast&lt;QQuickItem *&gt;(object); item)\n        {\n            auto grab_job = item-&gt;grabToImage();\n\n            co_await qobject_as_sender(grab_job.get(), &amp;QQuickItemGrabResult::ready);\n            co_return grab_job-&gt;image();\n        }\n    }\n    else if (object-&gt;isWindowType())\n    {\n        if (auto &amp;&amp;item = qobject_cast&lt;QQuickWindow *&gt;(object); item)\n        {\n            auto grabbed_image = item-&gt;grabWindow();\n            co_return grabbed_image;\n        }\n    }\n    co_return make_error_result(ErrorCode::not_found,\n                                fmt::format(\"Could not capture an image from object '{}'\",\n                                            object != nullptr ? object-&gt;objectName().toStdString() : \"unknown\"));\n}\n\nQtProbeHandler::QtProbeHandler(const ObjectTracker &amp;object_tracker)\n    : object_tracker_{object_tracker}\n{}\n\nAsyncResult&lt;entt::meta_any&gt; QtProbeHandler::object_instance(ObjectId object_id)\n{\n    auto find_result = object_tracker_.get_object_by_id(object_id);\n    if (find_result.has_value())\n    {\n        co_return entt::meta_any{std::in_place_type&lt;QObject *&gt;, find_result.value()};\n    }\n    co_return std::unexpected{std::move(find_result.error())};\n}\n\nAsyncResult&lt;QtProbeHandler::ImageData&gt; QtProbeHandler::take_snapshot(ObjectId object_id)\n{\n    auto object = object_tracker_.get_object_by_id(object_id);\n    if (not object.has_value())\n    {\n        co_return std::unexpected{std::move(object.error())};\n    }\n    auto expected_image =\n        co_await stdexec::starts_on(qthread_as_scheduler(object.value()-&gt;thread()), take_snapshot_of_qobject(*object));\n    if (not expected_image.has_value())\n    {\n        co_return std::unexpected{std::move(expected_image.error())};\n    }\n\n    expected_image-&gt;convertTo(QImage::Format::Format_RGBA8888);\n    ImageData image{.width = static_cast&lt;std::uint32_t&gt;(expected_image-&gt;width()),\n                    .height = static_cast&lt;std::uint32_t&gt;(expected_image-&gt;height())};\n    image.image_data.reserve(expected_image-&gt;sizeInBytes());\n    std::span&lt;const std::uint8_t&gt; data_view{expected_image-&gt;bits(),\n                                            static_cast&lt;std::size_t&gt;(expected_image-&gt;sizeInBytes())};\n    std::ranges::copy(data_view, std::back_inserter(image.image_data));\n    co_return image;\n}\n\nAsyncResult&lt;ObjectReference&gt; QtProbeHandler::find_object(ObjectQuery query)\n{\n    auto obj_info =\n        co_await (stdexec::when_all(stdexec::just(QPointer&lt;const ObjectTracker&gt;{std::addressof(object_tracker_)}),\n                                    stdexec::just(std::move(query))) |\n                  stdexec::continues_on(qthread_as_scheduler(QCoreApplication::instance()-&gt;thread())) |\n                  stdexec::then([](auto &amp;&amp;tracker, auto &amp;&amp;query) -&gt; Result&lt;ObjectReference&gt; {\n                      if (tracker)\n                      {\n                          return tracker-&gt;find_object_by_query(query);\n                      }\n                      return make_error_result(ErrorCode::failed_precondition,\n                                               \"ObjectTracker was already destroyed. Probably now in shutdown.\");\n                  }));\n    co_return obj_info;\n}\n\nAsyncResult&lt;QtProbeHandler::PropertyMap&gt; QtProbeHandler::fetch_properties(ObjectId object_id,\n                                                                          std::vector&lt;std::string&gt; properties)\n{\n    auto obj_result = object_tracker_.get_object_by_id(object_id);\n    if (not obj_result.has_value())\n    {\n        co_return std::unexpected{std::move(obj_result.error())};\n    }\n    auto collected_properties =\n        co_await (stdexec::just(QPointer&lt;QObject&gt;{obj_result.value()}) |\n                  stdexec::continues_on(qthread_as_scheduler(obj_result.value()-&gt;thread())) |\n                  stdexec::then([](auto &amp;&amp;object) { return ObjectMeta::from_qobject(object); }) |\n                  stdexec::then([properties](auto &amp;&amp;object_meta) -&gt; Result&lt;QtProbeHandler::PropertyMap&gt; {\n                      if (object_meta.meta_object == nullptr)\n                      {\n                          return make_error_result(ErrorCode::failed_precondition, \"Could not get a QMetaObject\");\n                      }\n                      return collect_properties(object_meta, properties);\n                  }));\n    co_return collected_properties;\n}\n\nAsyncResult&lt;void&gt; QtProbeHandler::set_property(ObjectId object_id, std::string property, entt::meta_any value)\n{\n    auto obj_result = object_tracker_.get_object_by_id(object_id);\n    if (not obj_result.has_value())\n    {\n        co_return std::unexpected{std::move(obj_result.error())};\n    }\n    const auto result = co_await (\n        stdexec::just(QPointer&lt;QObject&gt;{obj_result.value()}) |\n        stdexec::continues_on(qthread_as_scheduler(obj_result.value()-&gt;thread())) |\n        stdexec::then([](auto &amp;&amp;object) { return ObjectMeta::from_qobject(object); }) |\n        stdexec::then([property = std::move(property), value = std::move(value)](auto &amp;&amp;object_meta) -&gt; Result&lt;void&gt; {\n            return write_property(object_meta, property, value);\n        }));\n    co_return result;\n}\n\nAsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; QtProbeHandler::fetch_windows()\n{\n    std::vector&lt;ObjectReference&gt; windows;\n    for (auto &amp;&amp;obj : object_tracker_.top_level_views())\n    {\n        windows.emplace_back(ObjectReference{.object_id = to_object_id(obj),\n                                             .type_id = static_cast&lt;meta::TypeId&gt;(try_get_qt_meta_type(obj).id())});\n    }\n    co_return windows;\n}\n\nAsyncResult&lt;entt::meta_any&gt; QtProbeHandler::invoke_method(entt::meta_any object,\n                                                          std::string qualified_method_signature,\n                                                          std::vector&lt;entt::meta_any&gt; params)\n{\n    co_return co_await (\n        stdexec::when_all(stdexec::just(object), stdexec::just(qualified_method_signature), stdexec::just(params)) |\n        stdexec::continues_on(qthread_as_scheduler(QCoreApplication::instance()-&gt;thread())) |\n        stdexec::then([this](auto &amp;&amp;object, auto &amp;&amp;qualified_method_signature, auto &amp;&amp;params) {\n            return method_invoker_.invoke_method(object, qualified_method_signature, params);\n        }));\n}\n\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qt__probe__handler_8hpp/","title":"File qt_probe_handler.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; qt_probe_handler.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe/probe_handler.hpp&gt;</code></li> <li><code>#include \"method_invoker.hpp\"</code></li> </ul>"},{"location":"quite/qt__probe__handler_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/qt__probe__handler_8hpp/#classes","title":"Classes","text":"Type Name class QtProbeHandler <p>The documentation for this class was generated from the following file <code>libs/probeqt/qt_probe_handler.hpp</code></p>"},{"location":"quite/qt__probe__handler_8hpp_source/","title":"File qt_probe_handler.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; qt_probe_handler.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QObject&gt;\n#include &lt;quite/async_result.hpp&gt;\n#include &lt;quite/proto/probe/probe_handler.hpp&gt;\n#include \"method_invoker.hpp\"\n\nnamespace quite::probe\n{\nAsyncResult&lt;QImage&gt; take_snapshot_of_qobject(QObject *object);\n\nclass ObjectTracker;\nclass QtProbeHandler final : public proto::IProbeHandler\n{\n  public:\n    explicit QtProbeHandler(const ObjectTracker &amp;object_tracker);\n\n    AsyncResult&lt;entt::meta_any&gt; object_instance(ObjectId object_id) override;\n    AsyncResult&lt;ImageData&gt; take_snapshot(ObjectId object_id) override;\n    AsyncResult&lt;ObjectReference&gt; find_object(ObjectQuery query) override;\n    AsyncResult&lt;PropertyMap&gt; fetch_properties(ObjectId object_id, std::vector&lt;std::string&gt; properties) override;\n    AsyncResult&lt;void&gt; set_property(ObjectId object_id, std::string property, entt::meta_any value) override;\n    AsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; fetch_windows() override;\n    AsyncResult&lt;entt::meta_any&gt; invoke_method(entt::meta_any object,\n                                              std::string qualified_method_signature,\n                                              std::vector&lt;entt::meta_any&gt; params) override;\n\n  private:\n    const ObjectTracker &amp;object_tracker_;\n    MethodInvoker method_invoker_;\n};\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/qtstdexec_8h/","title":"File qtstdexec.h","text":"<p>FileList &gt; libs &gt; probeqt &gt; qtstdexec.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QAbstractEventDispatcher&gt;</code></li> <li><code>#include &lt;QMetaObject&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QThread&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;stdexec/concepts.hpp&gt;</code></li> <li><code>#include &lt;stdexec/execution.hpp&gt;</code></li> </ul>"},{"location":"quite/qtstdexec_8h/#namespaces","title":"Namespaces","text":"Type Name namespace quite"},{"location":"quite/qtstdexec_8h/#classes","title":"Classes","text":"Type Name class QObjectOperationState &lt;class Recv, class QObj, class Ret, Args&gt; class QObjectSender &lt;class QObj, class Ret, Args&gt; class QThreadOperationState &lt;class Recv&gt; class QThreadScheduler struct DefaultEnv class QThreadSender <p>The documentation for this class was generated from the following file <code>libs/probeqt/qtstdexec.h</code></p>"},{"location":"quite/qtstdexec_8h_source/","title":"File qtstdexec.h","text":"<p>File List &gt; libs &gt; probeqt &gt; qtstdexec.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;QAbstractEventDispatcher&gt;\n#include &lt;QMetaObject&gt;\n#include &lt;QObject&gt;\n#include &lt;QThread&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;stdexec/concepts.hpp&gt;\n#include &lt;stdexec/execution.hpp&gt;\n\nnamespace quite\n{\n\ntemplate &lt;class Recv&gt;\nclass QThreadOperationState;\n\nclass QThreadScheduler\n{\n  public:\n    explicit QThreadScheduler(QThread *thread)\n        : thread_(thread)\n    {}\n\n    QThread *thread()\n    {\n        return thread_;\n    }\n\n    struct DefaultEnv\n    {\n        QThread *thread;\n        template &lt;typename CPO&gt;\n        auto query(stdexec::get_completion_scheduler_t&lt;CPO&gt;) const noexcept\n        {\n            return QThreadScheduler{thread};\n        }\n    };\n\n    DefaultEnv query(stdexec::get_env_t) noexcept\n    {\n        return {thread_};\n    }\n\n    auto schedule() const noexcept\n    {\n        return QThreadSender{thread_};\n    }\n\n    class QThreadSender\n    {\n      public:\n        using is_sender = void;\n        using completion_signatures =\n            stdexec::completion_signatures&lt;stdexec::set_value_t(), stdexec::set_error_t(std::exception_ptr)&gt;;\n\n        explicit QThreadSender(QThread *thread)\n            : thread_(thread)\n        {}\n\n        QThread *thread()\n        {\n            return thread_;\n        }\n\n        DefaultEnv query(stdexec::get_env_t) const noexcept\n        {\n            return {thread_};\n        }\n\n        template &lt;class Recv&gt;\n        QThreadOperationState&lt;Recv&gt; connect(Recv &amp;&amp;receiver)\n        {\n            return QThreadOperationState&lt;Recv&gt;(std::forward&lt;Recv&gt;(receiver), thread());\n        }\n\n      private:\n        QThread *thread_;\n    };\n\n    bool operator==(const QThreadScheduler &amp;b) const noexcept = default;\n\n  private:\n    QThread *thread_ = nullptr;\n};\n\ninline QThreadScheduler qthread_as_scheduler(QThread *thread)\n{\n    return QThreadScheduler(thread);\n}\n\ninline QThreadScheduler qthread_as_scheduler(QThread &amp;thread)\n{\n    return QThreadScheduler(&amp;thread);\n}\n\ntemplate &lt;class Recv&gt;\nclass QThreadOperationState\n{\n  public:\n    using operation_state_concept = stdexec::operation_state_t;\n    Q_DISABLE_COPY_MOVE(QThreadOperationState);\n    QThreadOperationState(Recv &amp;&amp;receiver, QThread *thread)\n        : receiver_{std::move(receiver)}\n        , thread_{thread}\n    {}\n\n    ~QThreadOperationState() = default;\n\n    void start() noexcept\n    {\n        QMetaObject::invokeMethod(\n            thread_-&gt;eventDispatcher(), [this]() { stdexec::set_value(std::move(receiver_)); }, Qt::QueuedConnection);\n    }\n\n  private:\n    Recv receiver_;\n    QThread *thread_;\n};\n\ntemplate &lt;class Recv, class QObj, class Ret, class... Args&gt;\nclass QObjectOperationState;\n\ntemplate &lt;class QObj, class Ret, class... Args&gt;\nclass QObjectSender\n{\n    struct DefaultEnv\n    {\n        QThread *thread;\n        template &lt;typename CPO&gt;\n        auto query(stdexec::get_completion_scheduler_t&lt;CPO&gt; /*cpo*/) const noexcept\n        {\n            return QThreadScheduler{thread};\n        }\n    };\n\n    DefaultEnv query([[maybe_unused]] stdexec::get_env_t env) noexcept\n    {\n        return {obj_-&gt;thread()};\n    }\n\n  public:\n    using is_sender = void;\n    using completion_signatures = stdexec::completion_signatures&lt;stdexec::set_value_t(Args...),\n                                                                 stdexec::set_error_t(std::exception_ptr),\n                                                                 stdexec::set_stopped_t()&gt;;\n\n    using MemberPointer = Ret (QObj::*)(Args...);\n    QObjectSender(QObj *obj, MemberPointer ptr)\n        : obj_(obj)\n        , ptr_(ptr)\n    {}\n\n    QObj *object()\n    {\n        return obj_;\n    }\n\n    MemberPointer member_ptr()\n    {\n        return ptr_;\n    }\n\n    template &lt;class Recv&gt;\n    QObjectOperationState&lt;Recv, QObj, Ret, Args...&gt; connect(Recv &amp;&amp;receiver)\n    {\n        return QObjectOperationState&lt;Recv, QObj, Ret, Args...&gt;(std::forward&lt;Recv&gt;(receiver), obj_, ptr_);\n    }\n\n  private:\n    QObj *obj_;\n    MemberPointer ptr_;\n};\n\ntemplate &lt;class Recv, class QObj, class Ret, class... Args&gt;\nclass QObjectOperationState\n{\n  public:\n    using operation_state_concept = stdexec::operation_state_t;\n    using m_ptr_type = Ret (QObj::*)(Args...);\n\n    QObjectOperationState(Recv &amp;&amp;receiver, QObj *obj, m_ptr_type ptr)\n        : receiver_(std::move(receiver))\n        , obj_(obj)\n        , ptr_(ptr)\n    {}\n\n  private:\n    struct StopCallback\n    {\n        QObjectOperationState *self;\n\n        void operator()() const noexcept\n        {\n            self-&gt;stop_callback_.reset();\n            QObject::disconnect(self-&gt;connection_);\n            if (not self-&gt;completed_.test_and_set(std::memory_order_acq_rel))\n            {\n                QMetaObject::invokeMethod(\n                    self-&gt;obj_-&gt;thread()-&gt;eventDispatcher(),\n                    [this]() { stdexec::set_stopped(std::move(self-&gt;receiver_)); },\n                    Qt::QueuedConnection);\n            }\n        }\n    };\n\n  private:\n    using stop_token_type = stdexec::stop_token_of_t&lt;stdexec::env_of_t&lt;Recv&gt;&gt;;\n    using stop_callback_type = typename stop_token_type::template callback_type&lt;StopCallback&gt;;\n\n  public:\n    void start() noexcept\n    {\n        stop_callback_.emplace(stdexec::get_stop_token(stdexec::get_env(receiver_)), StopCallback{this});\n        connection_ = QObject::connect(\n            obj_,\n            ptr_,\n            obj_,\n            [this](Args... args) {\n                QObject::disconnect(connection_);\n                stop_callback_.reset();\n                if (!completed_.test_and_set(std::memory_order_acq_rel))\n                {\n                    QMetaObject::invokeMethod(\n                        obj_,\n                        [this, &amp;args...] { stdexec::set_value(std::move(receiver_), std::forward&lt;Args&gt;(args)...); },\n                        Qt::QueuedConnection);\n                }\n            },\n            Qt::SingleShotConnection);\n    }\n\n  private:\n    Recv receiver_;\n    QObj *obj_;\n    m_ptr_type ptr_;\n    QMetaObject::Connection connection_;\n    std::atomic_flag completed_{false};\n    std::optional&lt;stop_callback_type&gt; stop_callback_;\n};\n\ntemplate &lt;class QObj, class Ret, class... Args&gt;\ninline QObjectSender&lt;QObj, Ret, Args...&gt; qobject_as_sender(QObj *obj, Ret (QObj::*ptr)(Args...))\n{\n    return QObjectSender&lt;QObj, Ret, Args...&gt;(obj, ptr);\n}\n\ntemplate &lt;class QObj, class Ret, class... Args&gt;\ninline auto qobject_as_tuple_sender(QObj *obj, Ret (QObj::*ptr)(Args...))\n{\n    return QObjectSender&lt;QObj, Ret, Args...&gt;(obj, ptr) |\n           stdexec::then([](Args... args) { return std::tuple&lt;std::remove_cvref_t&lt;Args&gt;...&gt;(std::move(args)...); });\n}\n\n} // namespace quite\n</code></pre>"},{"location":"quite/to__object__id_8hpp/","title":"File to_object_id.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; to_object_id.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> </ul>"},{"location":"quite/to__object__id_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/to_object_id.hpp</code></p>"},{"location":"quite/to__object__id_8hpp_source/","title":"File to_object_id.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; to_object_id.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/value/object_id.hpp&gt;\n\nclass QObject;\nnamespace quite::probe\n{\nconstexpr ObjectId to_object_id(const QObject *obj)\n{\n    return reinterpret_cast&lt;std::uintptr_t&gt;(obj);\n}\n\nconstexpr QObject *from_object_id(ObjectId obj_id)\n{\n    return reinterpret_cast&lt;QObject *&gt;(obj_id);\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/value__converters_8cpp/","title":"File value_converters.cpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; value_converters.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"value_converters.hpp\"</code></li> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QMetaType&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QQmlListProperty&gt;</code></li> <li><code>#include &lt;QQmlListReference&gt;</code></li> <li><code>#include &lt;QQuickItem&gt;</code></li> <li><code>#include &lt;entt/meta/container.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/factory.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;private/qquickanchors_p_p.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/value/generic_value_class.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"meta_qt_containers.hpp\"</code></li> </ul>"},{"location":"quite/value__converters_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe"},{"location":"quite/value__converters_8cpp/#macros","title":"Macros","text":"Type Name define REGISTER_QT_TYPES_FUNCTION (TypeName, TypeId, Type) <code>register\\_type&amp;lt;Type&amp;gt;(value\\_registry, #Type);</code>"},{"location":"quite/value__converters_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"quite/value__converters_8cpp/#define-register_qt_types_function","title":"define REGISTER_QT_TYPES_FUNCTION","text":"<pre><code>#define REGISTER_QT_TYPES_FUNCTION (\n    TypeName,\n    TypeId,\n    Type\n) `register_type&lt;Type&gt;(value_registry, #Type);`\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/probeqt/value_converters.cpp</code></p>"},{"location":"quite/value__converters_8cpp_source/","title":"File value_converters.cpp","text":"<p>File List &gt; libs &gt; probeqt &gt; value_converters.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"value_converters.hpp\"\n#include &lt;QColor&gt;\n#include &lt;QList&gt;\n#include &lt;QMetaType&gt;\n#include &lt;QObject&gt;\n#include &lt;QQmlListProperty&gt;\n#include &lt;QQmlListReference&gt;\n#include &lt;QQuickItem&gt;\n#include &lt;entt/meta/container.hpp&gt;\n#include &lt;entt/meta/factory.hpp&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;private/qquickanchors_p_p.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/value/generic_value_class.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"meta_qt_containers.hpp\"\n\nDEFINE_LOGGER(value_converters)\nusing namespace entt::literals;\nnamespace quite::probe\n{\nnamespace\n{\ntemplate &lt;typename T&gt;\nvoid register_type(ValueRegistry &amp;value_registry, entt::hashed_string name)\n{\n    auto &amp;meta_ctx = value_registry.context();\n    auto &amp;&amp;type = entt::meta_factory&lt;T&gt;(meta_ctx) //\n                      .type(name.value())\n                      .template custom&lt;QMetaType&gt;(QMetaType::fromType&lt;T&gt;());\n    if constexpr (not std::is_void_v&lt;T&gt;)\n    {\n        type.template conv&lt;[](auto &amp;&amp;value) { return QVariant::fromValue&lt;T&gt;(std::forward&lt;decltype(value)&gt;(value)); }&gt;();\n    }\n}\n} // namespace\n#define REGISTER_QT_TYPES_FUNCTION(TypeName, TypeId, Type) register_type&lt;Type&gt;(value_registry, #Type);\n\nvoid register_converters(ValueRegistry &amp;value_registry)\n{\n    auto &amp;meta_ctx = value_registry.context();\n    entt::meta_factory&lt;QList&lt;QObject *&gt;&gt;(meta_ctx)\n        .type(\"QObjectList\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QObjectList&gt;());\n\n    QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(REGISTER_QT_TYPES_FUNCTION);\n\n    entt::meta_factory&lt;std::string&gt;(meta_ctx) //\n        .type(\"std::string\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;std::string&gt;())\n        .conv&lt;[](auto &amp;&amp;str) { return QString::fromStdString(str); }&gt;()\n        .conv&lt;[](auto &amp;&amp;value) {\n            return QVariant::fromValue&lt;QString&gt;(QString::fromStdString(std::forward&lt;decltype(value)&gt;(value)));\n        }&gt;();\n\n    entt::meta_factory&lt;QString&gt;(meta_ctx) //\n        .type(\"QString\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QString&gt;())\n        .conv&lt;&amp;QString::toStdString&gt;()\n        .conv&lt;[](auto &amp;&amp;value) { return QVariant::fromValue&lt;QString&gt;(std::forward&lt;decltype(value)&gt;(value)); }&gt;();\n\n    entt::meta_factory&lt;QRect&gt;(meta_ctx)\n        .type(\"QRect\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QRect&gt;())\n        .data&lt;&amp;QRect::setX, &amp;QRect::x&gt;(value_registry.named_property(\"x\"))\n        .data&lt;&amp;QRect::setY, &amp;QRect::y&gt;(value_registry.named_property(\"y\"))\n        .data&lt;&amp;QRect::setWidth, &amp;QRect::width&gt;(value_registry.named_property(\"width\"))\n        .data&lt;&amp;QRect::setHeight, &amp;QRect::height&gt;(value_registry.named_property(\"height\"));\n\n    entt::meta_factory&lt;QRectF&gt;(meta_ctx)\n        .type(\"QRectF\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QRectF&gt;())\n        .data&lt;&amp;QRectF::setX, &amp;QRectF::x&gt;(value_registry.named_property(\"x\"))\n        .data&lt;&amp;QRectF::setY, &amp;QRectF::y&gt;(value_registry.named_property(\"y\"))\n        .data&lt;&amp;QRectF::setWidth, &amp;QRectF::width&gt;(value_registry.named_property(\"width\"))\n        .data&lt;&amp;QRectF::setHeight, &amp;QRectF::height&gt;(value_registry.named_property(\"height\"));\n\n    entt::meta_factory&lt;QPoint&gt;(meta_ctx)\n        .type(\"QPoint\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QPoint&gt;())\n        .data&lt;&amp;QPoint::setX, &amp;QPoint::x&gt;(value_registry.named_property(\"x\"))\n        .data&lt;&amp;QPoint::setY, &amp;QPoint::y&gt;(value_registry.named_property(\"y\"));\n\n    entt::meta_factory&lt;QPointF&gt;(meta_ctx)\n        .type(\"QPointF\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QPointF&gt;())\n        .data&lt;&amp;QPointF::setX, &amp;QPointF::x&gt;(value_registry.named_property(\"x\"))\n        .data&lt;&amp;QPointF::setY, &amp;QPointF::y&gt;(value_registry.named_property(\"y\"));\n\n    entt::meta_factory&lt;QUrl&gt;(meta_ctx) //\n        .type(\"QUrl\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QUrl&gt;())\n        .data&lt;nullptr, [](const QUrl &amp;url) { return url.url(); }&gt;(value_registry.named_property(\"url\"))\n        .data&lt;nullptr, [](const QUrl &amp;url) { return url.toDisplayString(); }&gt;(\n            value_registry.named_property(\"displayString\"));\n\n    entt::meta_factory&lt;QColor&gt;(meta_ctx) //\n        .type(\"QColor\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QColor&gt;())\n        .data&lt;nullptr, [](const QColor &amp;color) { return color.name(); }&gt;(value_registry.named_property(\"name\"))\n        .data&lt;&amp;QColor::setAlpha, &amp;QColor::alpha&gt;(value_registry.named_property(\"alpha\"))\n        .data&lt;&amp;QColor::setRed, &amp;QColor::red&gt;(value_registry.named_property(\"red\"))\n        .data&lt;&amp;QColor::setGreen, &amp;QColor::green&gt;(value_registry.named_property(\"green\"))\n        .data&lt;&amp;QColor::setBlue, &amp;QColor::blue&gt;(value_registry.named_property(\"blue\"));\n\n    entt::meta_factory&lt;QQuickAnchorLine&gt;(meta_ctx) //\n        .type(\"QQuickAnchorLine\"_hs)\n        .custom&lt;QMetaType&gt;(QMetaType::fromType&lt;QQuickAnchorLine&gt;())\n        .data&lt;&amp;QQuickAnchorLine::item&gt;(value_registry.named_property(\"item\"));\n\n    entt::meta_factory&lt;QVariant&gt;(meta_ctx).type(\"QVariant\"_hs);\n}\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/value__converters_8hpp/","title":"File value_converters.hpp","text":"<p>FileList &gt; libs &gt; probeqt &gt; value_converters.hpp</p> <p>Go to the source code of this file</p>"},{"location":"quite/value__converters_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace probe <p>The documentation for this class was generated from the following file <code>libs/probeqt/value_converters.hpp</code></p>"},{"location":"quite/value__converters_8hpp_source/","title":"File value_converters.hpp","text":"<p>File List &gt; libs &gt; probeqt &gt; value_converters.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\nnamespace quite\n{\nclass ValueRegistry;\n}\nnamespace quite::probe\n{\nvoid register_converters(ValueRegistry &amp;value_registry);\n} // namespace quite::probe\n</code></pre>"},{"location":"quite/dir_256d27db1e44b9b04d67f4c92d3fc698/","title":"Dir libs/protocol","text":"<p>FileList &gt; libs &gt; protocol</p>"},{"location":"quite/dir_256d27db1e44b9b04d67f4c92d3fc698/#directories","title":"Directories","text":"Type Name dir include dir src dir tests <p>The documentation for this class was generated from the following file <code>libs/protocol/</code></p>"},{"location":"quite/dir_5926395dd2a1a1e5a7c03e8f9928f69e/","title":"Dir libs/protocol/include","text":"<p>FileList &gt; include</p>"},{"location":"quite/dir_5926395dd2a1a1e5a7c03e8f9928f69e/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/protocol/include/</code></p>"},{"location":"quite/dir_69811da4b5ffa6c48780c3c2aaa473c8/","title":"Dir libs/protocol/include/quite","text":"<p>FileList &gt; include &gt; quite</p>"},{"location":"quite/dir_69811da4b5ffa6c48780c3c2aaa473c8/#directories","title":"Directories","text":"Type Name dir proto <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/</code></p>"},{"location":"quite/dir_e84ba8046b88057ef61cdc53860835dc/","title":"Dir libs/protocol/include/quite/proto","text":"<p>FileList &gt; include &gt; quite &gt; proto</p>"},{"location":"quite/dir_e84ba8046b88057ef61cdc53860835dc/#directories","title":"Directories","text":"Type Name dir client dir probe <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/</code></p>"},{"location":"quite/dir_cf009ea199fe2cc3ab30b0598ff08e34/","title":"Dir libs/protocol/include/quite/proto/client","text":"<p>FileList &gt; client</p>"},{"location":"quite/dir_cf009ea199fe2cc3ab30b0598ff08e34/#files","title":"Files","text":"Type Name file client.hpp file probe_client.hpp file probe_service.hpp file value_converter.hpp <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/</code></p>"},{"location":"quite/client_8hpp/","title":"File client.hpp","text":"<p>FileList &gt; client &gt; client.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;quite/asio_config.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/client_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/client_8hpp/#classes","title":"Classes","text":"Type Name class Client <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/client.hpp</code></p>"},{"location":"quite/client_8hpp_source/","title":"File client.hpp","text":"<p>File List &gt; client &gt; client.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;quite/asio_config.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"quite/quite_protocol_export.hpp\"\n\nnamespace quite::proto\n{\nclass IValueConverter;\nclass ProbeClient;\nclass QUITE_PROTOCOL_EXPORT Client final\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(Client);\n    explicit Client(entt::locator&lt;ValueRegistry&gt;::node_type value_registry);\n    ~Client();\n    std::shared_ptr&lt;ProbeClient&gt; create_probe_client(std::shared_ptr&lt;IValueConverter&gt; value_converter,\n                                                     std::string connection_url);\n\n  private:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__client_8hpp/","title":"File probe_client.hpp","text":"<p>FileList &gt; client &gt; probe_client.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/injectors/mouse_injector.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> <li><code>#include \"probe_service.hpp\"</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/probe__client_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__client_8hpp/#classes","title":"Classes","text":"Type Name class ProbeClient <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/probe_client.hpp</code></p>"},{"location":"quite/probe__client_8hpp_source/","title":"File probe_client.hpp","text":"<p>File List &gt; client &gt; probe_client.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/injectors/mouse_injector.hpp&gt;\n#include &lt;quite/meta/meta_registry.hpp&gt;\n#include \"probe_service.hpp\"\n#include \"quite/quite_protocol_export.hpp\"\n\nnamespace quite::proto\n{\nclass QUITE_PROTOCOL_EXPORT ProbeClient\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(ProbeClient);\n    ProbeClient();\n    virtual ~ProbeClient();\n\n    virtual IProbeService &amp;probe_service() = 0;\n    virtual core::IMouseInjector &amp;mouse_injector() = 0;\n    virtual meta::MetaRegistry &amp;meta_registry() = 0;\n    virtual AsyncResult&lt;void&gt; wait_for_connected(std::chrono::seconds timeout) = 0;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__service_8hpp/","title":"File probe_service.hpp","text":"<p>FileList &gt; client &gt; probe_service.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include &lt;quite/image.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/probe__service_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__service_8hpp/#classes","title":"Classes","text":"Type Name class IProbeService <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/probe_service.hpp</code></p>"},{"location":"quite/probe__service_8hpp_source/","title":"File probe_service.hpp","text":"<p>File List &gt; client &gt; probe_service.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/async_result.hpp&gt;\n#include &lt;quite/image.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"quite/quite_protocol_export.hpp\"\nnamespace quite::proto\n{\nclass QUITE_PROTOCOL_EXPORT IProbeService\n{\n  public:\n    virtual ~IProbeService() = default;\n    virtual AsyncResult&lt;Image&gt; take_snapshot(ObjectId id) = 0;\n    virtual AsyncResult&lt;ObjectReference&gt; find_object(ObjectQuery serach_query) = 0;\n    virtual AsyncResult&lt;std::unordered_map&lt;std::string, entt::meta_any&gt;&gt; get_object_properties(\n        ObjectId object_id, std::vector&lt;std::string&gt; properties) = 0;\n    virtual AsyncResult&lt;void&gt; set_object_property(ObjectId object_id, std::string property, entt::meta_any value) = 0;\n    virtual AsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; query_top_level_views() = 0;\n    virtual AsyncResult&lt;entt::meta_any&gt; invoke_method(ObjectId id,\n                                                      std::string method_name,\n                                                      std::vector&lt;entt::meta_any&gt; parameters) = 0;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/value__converter_8hpp/","title":"File value_converter.hpp","text":"<p>FileList &gt; client &gt; value_converter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/value__converter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/value__converter_8hpp/#classes","title":"Classes","text":"Type Name class IValueConverter <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/client/value_converter.hpp</code></p>"},{"location":"quite/value__converter_8hpp_source/","title":"File value_converter.hpp","text":"<p>File List &gt; client &gt; value_converter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include \"quite/quite_protocol_export.hpp\"\nnamespace quite::proto\n{\nclass QUITE_PROTOCOL_EXPORT IValueConverter\n{\n  public:\n    virtual ~IValueConverter() = default;\n    virtual entt::meta_any from(ObjectReference ref) const = 0;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/dir_b0223a4951d67b698dfb269e1d467abc/","title":"Dir libs/protocol/include/quite/proto/probe","text":"<p>FileList &gt; include &gt; quite &gt; proto &gt; probe</p>"},{"location":"quite/dir_b0223a4951d67b698dfb269e1d467abc/#files","title":"Files","text":"Type Name file probe_handler.hpp file server.hpp <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/</code></p>"},{"location":"quite/probe__handler_8hpp/","title":"File probe_handler.hpp","text":"<p>FileList &gt; include &gt; quite &gt; proto &gt; probe &gt; probe_handler.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/container/dense_map.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;quite/async_result.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_id.hpp&gt;</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/probe__handler_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__handler_8hpp/#classes","title":"Classes","text":"Type Name class IProbeHandler struct ImageData <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/probe_handler.hpp</code></p>"},{"location":"quite/probe__handler_8hpp_source/","title":"File probe_handler.hpp","text":"<p>File List &gt; include &gt; quite &gt; proto &gt; probe &gt; probe_handler.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/container/dense_map.hpp&gt;\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;quite/async_result.hpp&gt;\n#include &lt;quite/value/object_id.hpp&gt;\n#include \"quite/quite_protocol_export.hpp\"\n\nnamespace quite\n{\nstruct ObjectQuery;\n}\nnamespace quite::proto\n{\nclass QUITE_PROTOCOL_EXPORT IProbeHandler\n{\n  public:\n    struct ImageData\n    {\n        std::uint32_t width;\n        std::uint32_t height;\n        std::vector&lt;std::uint8_t&gt; image_data;\n    };\n    using PropertyMap = entt::dense_map&lt;std::string, entt::meta_any&gt;;\n\n    virtual ~IProbeHandler() = default;\n    virtual AsyncResult&lt;entt::meta_any&gt; object_instance(ObjectId object_id) = 0;\n    virtual AsyncResult&lt;ImageData&gt; take_snapshot(ObjectId object_id) = 0;\n    virtual AsyncResult&lt;ObjectReference&gt; find_object(ObjectQuery query) = 0;\n    virtual AsyncResult&lt;PropertyMap&gt; fetch_properties(ObjectId object_id, std::vector&lt;std::string&gt; properties) = 0;\n    virtual AsyncResult&lt;void&gt; set_property(ObjectId object_id, std::string property, entt::meta_any value) = 0;\n    virtual AsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; fetch_windows() = 0;\n    virtual AsyncResult&lt;entt::meta_any&gt; invoke_method(entt::meta_any object,\n                                                      std::string qualified_method_signature,\n                                                      std::vector&lt;entt::meta_any&gt; params) = 0;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/protocol_2include_2quite_2proto_2probe_2server_8hpp/","title":"File server.hpp","text":"<p>FileList &gt; include &gt; quite &gt; proto &gt; probe &gt; server.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include &lt;quite/service_handle.hpp&gt;</code></li> <li><code>#include \"quite/quite_protocol_export.hpp\"</code></li> </ul>"},{"location":"quite/protocol_2include_2quite_2proto_2probe_2server_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace core namespace meta namespace proto"},{"location":"quite/protocol_2include_2quite_2proto_2probe_2server_8hpp/#classes","title":"Classes","text":"Type Name class Server <p>The documentation for this class was generated from the following file <code>libs/protocol/include/quite/proto/probe/server.hpp</code></p>"},{"location":"quite/protocol_2include_2quite_2proto_2probe_2server_8hpp_source/","title":"File server.hpp","text":"<p>File List &gt; include &gt; quite &gt; proto &gt; probe &gt; server.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include &lt;quite/service_handle.hpp&gt;\n#include \"quite/quite_protocol_export.hpp\"\nnamespace quite\n{\nclass ValueRegistry;\n}\nnamespace quite::core\n{\nclass IMouseInjector;\n}\nnamespace quite::meta\n{\nclass MetaRegistry;\n}\n\nnamespace quite::proto\n{\nclass IProbeHandler;\n\nclass QUITE_PROTOCOL_EXPORT Server final\n{\n  public:\n    QUITE_DISABLE_COPY(Server);\n    Server(std::string server_address,\n           ServiceHandle&lt;IProbeHandler&gt; probe_handler,\n           ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector,\n           ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry,\n           ServiceHandle&lt;ValueRegistry&gt; value_registry);\n    Server(Server &amp;&amp;server) noexcept;\n    Server &amp;operator=(Server &amp;&amp;server) noexcept;\n    ~Server();\n\n  private:\n    class Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/dir_62c749a433f68b441b7c0425b5469d66/","title":"Dir libs/protocol/src","text":"<p>FileList &gt; libs &gt; protocol &gt; src</p>"},{"location":"quite/dir_62c749a433f68b441b7c0425b5469d66/#files","title":"Files","text":"Type Name file error_helper.cpp file error_helper.hpp file meta_converters.cpp file meta_converters.hpp file value.cpp file value.hpp"},{"location":"quite/dir_62c749a433f68b441b7c0425b5469d66/#directories","title":"Directories","text":"Type Name dir client dir probe <p>The documentation for this class was generated from the following file <code>libs/protocol/src/</code></p>"},{"location":"quite/error__helper_8cpp/","title":"File error_helper.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; error_helper.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error_helper.hpp\"</code></li> </ul>"},{"location":"quite/error__helper_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/error_helper.cpp</code></p>"},{"location":"quite/error__helper_8cpp_source/","title":"File error_helper.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; error_helper.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"error_helper.hpp\"\nnamespace quite::proto\n{\ngrpc::Status result2grpc_status(const Error &amp;error)\n{\n    const grpc::StatusCode code = [code = error.code]() {\n        switch (code)\n        {\n        case ErrorCode::unknown:\n            return grpc::StatusCode::UNKNOWN;\n        case ErrorCode::cancelled:\n            return grpc::StatusCode::CANCELLED;\n        case ErrorCode::invalid_argument:\n            return grpc::StatusCode::INVALID_ARGUMENT;\n        case ErrorCode::deadline_exceeded:\n            return grpc::StatusCode::DEADLINE_EXCEEDED;\n        case ErrorCode::not_found:\n            return grpc::StatusCode::NOT_FOUND;\n        case ErrorCode::failed_precondition:\n            return grpc::StatusCode::FAILED_PRECONDITION;\n        case ErrorCode::aborted:\n            return grpc::StatusCode::ABORTED;\n        case ErrorCode::unimplemented:\n            return grpc::StatusCode::UNIMPLEMENTED;\n        case ErrorCode::unavailable:\n            return grpc::StatusCode::UNAVAILABLE;\n        }\n        return grpc::StatusCode::UNKNOWN;\n    }();\n    return grpc::Status{code, error.message};\n}\n\nError grpc_status2result(const grpc::Status &amp;error)\n{\n    const ErrorCode code = [code = error.error_code()]() {\n        switch (code)\n        {\n        case grpc::CANCELLED:\n            return ErrorCode::cancelled;\n        case grpc::INVALID_ARGUMENT:\n            return ErrorCode::invalid_argument;\n        case grpc::DEADLINE_EXCEEDED:\n            return ErrorCode::deadline_exceeded;\n        case grpc::NOT_FOUND:\n        case grpc::RESOURCE_EXHAUSTED:\n            return ErrorCode::not_found;\n        case grpc::ALREADY_EXISTS:\n        case grpc::PERMISSION_DENIED:\n        case grpc::FAILED_PRECONDITION:\n        case grpc::OUT_OF_RANGE:\n            return ErrorCode::failed_precondition;\n        case grpc::UNAUTHENTICATED:\n        case grpc::ABORTED:\n            return ErrorCode::aborted;\n        case grpc::UNIMPLEMENTED:\n            return ErrorCode::unimplemented;\n        case grpc::UNAVAILABLE:\n            return ErrorCode::unavailable;\n        case grpc::OK:\n        case grpc::DATA_LOSS:\n        case grpc::UNKNOWN:\n        case grpc::INTERNAL:\n        case grpc::DO_NOT_USE:\n            return ErrorCode::unknown;\n        }\n        return ErrorCode::unknown;\n    }();\n\n    return Error{\n        .code = code,\n        .message = error.error_message(),\n    };\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/error__helper_8hpp/","title":"File error_helper.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; error_helper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;grpcpp/support/status.h&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> </ul>"},{"location":"quite/error__helper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/error_helper.hpp</code></p>"},{"location":"quite/error__helper_8hpp_source/","title":"File error_helper.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; error_helper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;grpcpp/support/status.h&gt;\n#include &lt;quite/error.hpp&gt;\n\nnamespace quite::proto\n{\ngrpc::Status result2grpc_status(const Error &amp;error);\nError grpc_status2result(const grpc::Status &amp;error);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/dir_5522d6aca5c3fb454e911c5582f2e576/","title":"Dir libs/protocol/src/client","text":"<p>FileList &gt; client</p>"},{"location":"quite/dir_5522d6aca5c3fb454e911c5582f2e576/#files","title":"Files","text":"Type Name file client.cpp file configure_client_context.cpp file configure_client_context.hpp file grpc_manager.cpp file grpc_manager.hpp file meta_registry_impl.cpp file meta_registry_impl.hpp file mouse_injector_impl.cpp file mouse_injector_impl.hpp file probe_client.cpp file probe_client_impl.cpp file probe_client_impl.hpp file probe_service_impl.cpp file probe_service_impl.hpp <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/</code></p>"},{"location":"quite/client_8cpp/","title":"File client.cpp","text":"<p>FileList &gt; client &gt; client.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/proto/client/client.hpp\"</code></li> <li><code>#include \"grpc_manager.hpp\"</code></li> <li><code>#include \"probe_client_impl.hpp\"</code></li> <li><code>#include \"quite/proto/client/value_converter.hpp\"</code></li> </ul>"},{"location":"quite/client_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/client_8cpp/#classes","title":"Classes","text":"Type Name struct Impl <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/client.cpp</code></p>"},{"location":"quite/client_8cpp_source/","title":"File client.cpp","text":"<p>File List &gt; client &gt; client.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/proto/client/client.hpp\"\n#include \"grpc_manager.hpp\"\n#include \"probe_client_impl.hpp\"\n#include \"quite/proto/client/value_converter.hpp\"\n\nnamespace quite::proto\n{\nstruct Client::Impl\n{\n    GrpcManager grpc_;\n};\n\nClient::Client(entt::locator&lt;ValueRegistry&gt;::node_type value_registry)\n    : impl_{std::make_unique&lt;Impl&gt;()}\n{\n    entt::locator&lt;ValueRegistry&gt;::reset(std::move(value_registry));\n}\n\nClient::~Client() = default;\n\nstd::shared_ptr&lt;ProbeClient&gt; Client::create_probe_client(std::shared_ptr&lt;IValueConverter&gt; value_converter,\n                                                         std::string connection_url)\n{\n    return std::make_shared&lt;ProbeClientImpl&gt;(impl_-&gt;grpc_, std::move(connection_url), std::move(value_converter));\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/configure__client__context_8cpp/","title":"File configure_client_context.cpp","text":"<p>FileList &gt; client &gt; configure_client_context.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"configure_client_context.hpp\"</code></li> </ul>"},{"location":"quite/configure__client__context_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/configure_client_context.cpp</code></p>"},{"location":"quite/configure__client__context_8cpp_source/","title":"File configure_client_context.cpp","text":"<p>File List &gt; client &gt; configure_client_context.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"configure_client_context.hpp\"\n\nnamespace quite::proto\n{\nvoid configure_client_context(grpc::ClientContext &amp;client_context)\n{\n    client_context.set_deadline(std::chrono::system_clock::now() + std::chrono::seconds{10});\n    client_context.set_wait_for_ready(true);\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/configure__client__context_8hpp/","title":"File configure_client_context.hpp","text":"<p>FileList &gt; client &gt; configure_client_context.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/client_rpc.hpp&gt;</code></li> </ul>"},{"location":"quite/configure__client__context_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/configure_client_context.hpp</code></p>"},{"location":"quite/configure__client__context_8hpp_source/","title":"File configure_client_context.hpp","text":"<p>File List &gt; client &gt; configure_client_context.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/client_rpc.hpp&gt;\n\nnamespace quite::proto\n{\nvoid configure_client_context(grpc::ClientContext &amp;client_context);\n}\n</code></pre>"},{"location":"quite/grpc__manager_8cpp/","title":"File grpc_manager.cpp","text":"<p>FileList &gt; client &gt; grpc_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grpc_manager.hpp\"</code></li> <li><code>#include &lt;agrpc/asio_grpc.hpp&gt;</code></li> </ul>"},{"location":"quite/grpc__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/grpc_manager.cpp</code></p>"},{"location":"quite/grpc__manager_8cpp_source/","title":"File grpc_manager.cpp","text":"<p>File List &gt; client &gt; grpc_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grpc_manager.hpp\"\n#include &lt;agrpc/asio_grpc.hpp&gt;\nnamespace quite::proto\n{\nGrpcManager::GrpcManager()\n    : grpc_context_{std::make_shared&lt;agrpc::GrpcContext&gt;()}\n    , grpc_thread_{[grpc_context = grpc_context_]() {\n        grpc_context-&gt;work_started();\n        grpc_context-&gt;run();\n    }}\n{}\n\nGrpcManager::~GrpcManager()\n{\n    grpc_context_-&gt;stop();\n};\n\nstd::shared_ptr&lt;agrpc::GrpcContext&gt; GrpcManager::context()\n{\n    return grpc_context_;\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/grpc__manager_8hpp/","title":"File grpc_manager.hpp","text":"<p>FileList &gt; client &gt; grpc_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> </ul>"},{"location":"quite/grpc__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/grpc__manager_8hpp/#classes","title":"Classes","text":"Type Name class GrpcManager <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/grpc_manager.hpp</code></p>"},{"location":"quite/grpc__manager_8hpp_source/","title":"File grpc_manager.hpp","text":"<p>File List &gt; client &gt; grpc_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n\nnamespace quite::proto\n{\nclass GrpcManager final\n{\n  public:\n    QUITE_DISABLE_COPY_MOVE(GrpcManager);\n    GrpcManager();\n    ~GrpcManager();\n\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; context();\n\n  private:\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context_;\n    std::jthread grpc_thread_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/meta__registry__impl_8cpp/","title":"File meta_registry_impl.cpp","text":"<p>FileList &gt; client &gt; meta_registry_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"meta_registry_impl.hpp\"</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"configure_client_context.hpp\"</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"meta_converters.hpp\"</code></li> </ul>"},{"location":"quite/meta__registry__impl_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/meta__registry__impl_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOGGER (meta_registry)"},{"location":"quite/meta__registry__impl_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/meta__registry__impl_8cpp/#function-define_logger","title":"function DEFINE_LOGGER","text":"<pre><code>DEFINE_LOGGER (\n    meta_registry\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/meta_registry_impl.cpp</code></p>"},{"location":"quite/meta__registry__impl_8cpp_source/","title":"File meta_registry_impl.cpp","text":"<p>File List &gt; client &gt; meta_registry_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"meta_registry_impl.hpp\"\n#include &lt;quite/logger.hpp&gt;\n#include \"configure_client_context.hpp\"\n#include \"error_helper.hpp\"\n#include \"meta_converters.hpp\"\n\nDEFINE_LOGGER(meta_registry);\n\nnamespace quite::proto\n{\n\nMetaRegistryImpl::MetaRegistryImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context,\n                                   MetaService::Stub &amp;meta_service_stub)\n    : grpc_context_{std::move(grpc_context)}\n    , meta_service_stub_{meta_service_stub}\n{}\n\nAsyncResult&lt;meta::Type&gt; MetaRegistryImpl::lookup_type(meta::TypeId type_id)\n{\n    LOG_DEBUG(meta_registry(), \"lookup type for '{}'\", type_id);\n\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::MetaService::Stub::PrepareAsyncFindType&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_type_id(type_id);\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, meta_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    if (not response.has_type())\n    {\n        co_return make_error_result(ErrorCode::failed_precondition,\n                                    fmt::format(\"Got no meta type for type '{}'\", type_id));\n    }\n\n    auto &amp;&amp;meta_type = response.type();\n    if (meta_type.has_primitive_type())\n    {\n        co_return from_protocol(meta_type.primitive_type());\n    }\n    if (meta_type.has_enum_type())\n    {\n        co_return from_protocol(meta_type.enum_type());\n    }\n    if (meta_type.has_list_type())\n    {\n        co_return from_protocol(meta_type.list_type());\n    }\n    if (meta_type.has_map_type())\n    {\n        co_return from_protocol(meta_type.map_type());\n    }\n    if (meta_type.has_object_type())\n    {\n        co_return from_protocol(meta_type.object_type());\n    }\n    co_return make_error_result(ErrorCode::failed_precondition,\n                                \"Got a probe response but couldn't map protocol meta type to internal type.\");\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/meta__registry__impl_8hpp/","title":"File meta_registry_impl.hpp","text":"<p>FileList &gt; client &gt; meta_registry_impl.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> <li><code>#include \"quite/proto/meta_service.grpc.pb.h\"</code></li> </ul>"},{"location":"quite/meta__registry__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/meta__registry__impl_8hpp/#classes","title":"Classes","text":"Type Name class MetaRegistryImpl <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/meta_registry_impl.hpp</code></p>"},{"location":"quite/meta__registry__impl_8hpp_source/","title":"File meta_registry_impl.hpp","text":"<p>File List &gt; client &gt; meta_registry_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;quite/meta/meta_registry.hpp&gt;\n#include \"quite/proto/meta_service.grpc.pb.h\"\n\nnamespace quite::proto\n{\nclass MetaRegistryImpl : public meta::MetaRegistry\n{\n  public:\n    explicit MetaRegistryImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context, MetaService::Stub &amp;meta_service_stub);\n    AsyncResult&lt;meta::Type&gt; lookup_type(meta::TypeId type_id) override;\n\n  private:\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context_;\n    MetaService::Stub &amp;meta_service_stub_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/mouse__injector__impl_8cpp/","title":"File mouse_injector_impl.cpp","text":"<p>FileList &gt; client &gt; mouse_injector_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"mouse_injector_impl.hpp\"</code></li> <li><code>#include \"configure_client_context.hpp\"</code></li> <li><code>#include \"error_helper.hpp\"</code></li> </ul>"},{"location":"quite/mouse__injector__impl_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/mouse_injector_impl.cpp</code></p>"},{"location":"quite/mouse__injector__impl_8cpp_source/","title":"File mouse_injector_impl.cpp","text":"<p>File List &gt; client &gt; mouse_injector_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"mouse_injector_impl.hpp\"\n#include \"configure_client_context.hpp\"\n#include \"error_helper.hpp\"\n\nnamespace quite::proto\n{\nMouseInjectorImpl::MouseInjectorImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context,\n                                     ProbeService::Stub &amp;probe_service_stub)\n    : grpc_context_{std::move(grpc_context)}\n    , probe_service_stub_{probe_service_stub}\n{}\n\nAsyncResult&lt;void&gt; MouseInjectorImpl::single_action(ObjectId target_id, core::MouseAction action)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncMouseAction&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_object_id(target_id);\n    request.set_mouse_action(::quite::proto::MouseAction::click);\n    request.mutable_relative_point()-&gt;set_x(static_cast&lt;float&gt;(action.position.x));\n    request.mutable_relative_point()-&gt;set_y(static_cast&lt;float&gt;(action.position.y));\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    co_return {};\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/mouse__injector__impl_8hpp/","title":"File mouse_injector_impl.hpp","text":"<p>FileList &gt; client &gt; mouse_injector_impl.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;quite/injectors/mouse_injector.hpp&gt;</code></li> <li><code>#include \"quite/proto/probe.grpc.pb.h\"</code></li> </ul>"},{"location":"quite/mouse__injector__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/mouse__injector__impl_8hpp/#classes","title":"Classes","text":"Type Name class MouseInjectorImpl <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/mouse_injector_impl.hpp</code></p>"},{"location":"quite/mouse__injector__impl_8hpp_source/","title":"File mouse_injector_impl.hpp","text":"<p>File List &gt; client &gt; mouse_injector_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;quite/injectors/mouse_injector.hpp&gt;\n#include \"quite/proto/probe.grpc.pb.h\"\n\nnamespace quite::proto\n{\nclass MouseInjectorImpl final : public core::IMouseInjector\n{\n  public:\n    explicit MouseInjectorImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context,\n                               ProbeService::Stub &amp;probe_service_stub);\n    AsyncResult&lt;void&gt; single_action(ObjectId target_id, core::MouseAction action) override;\n\n  private:\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context_;\n    ProbeService::Stub &amp;probe_service_stub_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__client_8cpp/","title":"File probe_client.cpp","text":"<p>FileList &gt; client &gt; probe_client.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/proto/client/probe_client.hpp\"</code></li> </ul>"},{"location":"quite/probe__client_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_client.cpp</code></p>"},{"location":"quite/probe__client_8cpp_source/","title":"File probe_client.cpp","text":"<p>File List &gt; client &gt; probe_client.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/proto/client/probe_client.hpp\"\nnamespace quite::proto\n{\nProbeClient::ProbeClient() = default;\n\nProbeClient::~ProbeClient() = default;\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__client__impl_8cpp/","title":"File probe_client_impl.cpp","text":"<p>FileList &gt; client &gt; probe_client_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"probe_client_impl.hpp\"</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;agrpc/notify_on_state_change.hpp&gt;</code></li> <li><code>#include &lt;asioexec/use_sender.hpp&gt;</code></li> <li><code>#include &lt;exec/repeat_effect_until.hpp&gt;</code></li> <li><code>#include &lt;exec/when_any.hpp&gt;</code></li> <li><code>#include &lt;grpcpp/create_channel.h&gt;</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> </ul>"},{"location":"quite/probe__client__impl_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_client_impl.cpp</code></p>"},{"location":"quite/probe__client__impl_8cpp_source/","title":"File probe_client_impl.cpp","text":"<p>File List &gt; client &gt; probe_client_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"probe_client_impl.hpp\"\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;agrpc/notify_on_state_change.hpp&gt;\n#include &lt;asioexec/use_sender.hpp&gt;\n#include &lt;exec/repeat_effect_until.hpp&gt;\n#include &lt;exec/when_any.hpp&gt;\n#include &lt;grpcpp/create_channel.h&gt;\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n\nDEFINE_LOGGER(probe_client)\n\nnamespace quite::proto\n{\nProbeClientImpl::ProbeClientImpl(GrpcManager &amp;grpc_manager,\n                                 std::string connection_url,\n                                 std::shared_ptr&lt;IValueConverter&gt; value_converter)\n    : grpc_context_{grpc_manager.context()}\n    , grpc_channel_{::grpc::CreateChannel(std::move(connection_url), ::grpc::InsecureChannelCredentials())}\n    , value_converter_{std::move(value_converter)}\n{}\n\nAsyncResult&lt;void&gt; ProbeClientImpl::wait_for_connected(std::chrono::seconds timeout)\n{\n    auto state = grpc_channel_-&gt;GetState(true);\n    if (state == grpc_connectivity_state::GRPC_CHANNEL_READY)\n    {\n        co_return {};\n    }\n\n    const auto deadline = std::chrono::system_clock::now() + timeout;\n    bool is_connected{false};\n    while (not is_connected)\n    {\n        const auto state_change_result = co_await stdexec::starts_on(\n            exec::inline_scheduler{},\n            agrpc::notify_on_state_change(*grpc_context_, *grpc_channel_, state, deadline, agrpc::use_sender) |\n                stdexec::then([this, &amp;state](bool state_changed) -&gt; Result&lt;bool&gt; {\n                    if (not state_changed)\n                    {\n                        return make_error_result(ErrorCode::deadline_exceeded,\n                                                 \"Could not get connection state in time.\");\n                    }\n                    state = grpc_channel_-&gt;GetState(true);\n                    LOG_DEBUG(probe_client(), \"state: {}\", static_cast&lt;int&gt;(state));\n                    if (state == grpc_connectivity_state::GRPC_CHANNEL_READY)\n                    {\n                        return true;\n                    }\n                    if (state == grpc_connectivity_state::GRPC_CHANNEL_SHUTDOWN)\n                    {\n                        return make_error_result(ErrorCode::cancelled,\n                                                 \"Channel had an unrecoverable error or was shutdown.\");\n                    }\n                    return false;\n                }));\n        if (state_change_result.has_value())\n        {\n            is_connected = state_change_result.value();\n        }\n        else\n        {\n            co_return std::unexpected{state_change_result.error()};\n        }\n    }\n    co_return {};\n}\n\nIProbeService &amp;ProbeClientImpl::probe_service()\n{\n    return probe_service_;\n}\n\ncore::IMouseInjector &amp;ProbeClientImpl::mouse_injector()\n{\n    return mouse_injector_;\n}\n\nmeta::MetaRegistry &amp;ProbeClientImpl::meta_registry()\n{\n    return meta_registry_;\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__client__impl_8hpp/","title":"File probe_client_impl.hpp","text":"<p>FileList &gt; client &gt; probe_client_impl.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;grpcpp/channel.h&gt;</code></li> <li><code>#include \"grpc_manager.hpp\"</code></li> <li><code>#include \"meta_registry_impl.hpp\"</code></li> <li><code>#include \"mouse_injector_impl.hpp\"</code></li> <li><code>#include \"probe_service_impl.hpp\"</code></li> <li><code>#include \"quite/proto/client/probe_client.hpp\"</code></li> <li><code>#include \"quite/proto/client/value_converter.hpp\"</code></li> <li><code>#include \"quite/proto/meta_service.grpc.pb.h\"</code></li> <li><code>#include \"quite/proto/probe.grpc.pb.h\"</code></li> </ul>"},{"location":"quite/probe__client__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__client__impl_8hpp/#classes","title":"Classes","text":"Type Name class ProbeClientImpl <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_client_impl.hpp</code></p>"},{"location":"quite/probe__client__impl_8hpp_source/","title":"File probe_client_impl.hpp","text":"<p>File List &gt; client &gt; probe_client_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;grpcpp/channel.h&gt;\n#include \"grpc_manager.hpp\"\n#include \"meta_registry_impl.hpp\"\n#include \"mouse_injector_impl.hpp\"\n#include \"probe_service_impl.hpp\"\n#include \"quite/proto/client/probe_client.hpp\"\n#include \"quite/proto/client/value_converter.hpp\"\n#include \"quite/proto/meta_service.grpc.pb.h\"\n#include \"quite/proto/probe.grpc.pb.h\"\nnamespace quite::proto\n{\nclass ProbeClientImpl final : public ProbeClient\n{\n  public:\n    ProbeClientImpl(GrpcManager &amp;grpc_manager,\n                    std::string connection_url,\n                    std::shared_ptr&lt;IValueConverter&gt; value_converter);\n    AsyncResult&lt;void&gt; wait_for_connected(std::chrono::seconds timeout) override;\n    IProbeService &amp;probe_service() override;\n    core::IMouseInjector &amp;mouse_injector() override;\n    meta::MetaRegistry &amp;meta_registry() override;\n\n  private:\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context_;\n    std::shared_ptr&lt;grpc::Channel&gt; grpc_channel_;\n    std::shared_ptr&lt;IValueConverter&gt; value_converter_;\n    ProbeService::Stub probe_service_stub_{grpc_channel_};\n    MetaService::Stub meta_service_stub_{grpc_channel_};\n    ProbeServiceImpl probe_service_{grpc_context_, probe_service_stub_, value_converter_};\n    MetaRegistryImpl meta_registry_{grpc_context_, meta_service_stub_};\n    MouseInjectorImpl mouse_injector_{grpc_context_, probe_service_stub_};\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__service__impl_8cpp/","title":"File probe_service_impl.cpp","text":"<p>FileList &gt; client &gt; probe_service_impl.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"probe_service_impl.hpp\"</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"configure_client_context.hpp\"</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"value.hpp\"</code></li> </ul>"},{"location":"quite/probe__service__impl_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_service_impl.cpp</code></p>"},{"location":"quite/probe__service__impl_8cpp_source/","title":"File probe_service_impl.cpp","text":"<p>File List &gt; client &gt; probe_service_impl.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"probe_service_impl.hpp\"\n#include &lt;quite/logger.hpp&gt;\n#include \"configure_client_context.hpp\"\n#include \"error_helper.hpp\"\n#include \"value.hpp\"\n\nDEFINE_LOGGER(grpc_probe)\n\nnamespace quite::proto\n{\nnamespace\n{\nvoid write_query(proto::ObjectSearchQuery &amp;proto_query, const ObjectQuery &amp;query)\n{\n    if (query.container != nullptr)\n    {\n        write_query(*proto_query.mutable_parent(), *query.container);\n    }\n    proto_query.set_type_name(query.type_name);\n    for (auto &amp;&amp;[key, value] : query.properties)\n    {\n        proto_query.mutable_properties()-&gt;insert({key, create_value(entt::locator&lt;ValueRegistry&gt;::value(), value)});\n    }\n}\n} // namespace\n\nProbeServiceImpl::ProbeServiceImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context,\n                                   ProbeService::Stub &amp;probe_service_stub,\n                                   std::shared_ptr&lt;IValueConverter&gt; value_converter)\n    : grpc_context_{std::move(grpc_context)}\n    , probe_service_stub_{probe_service_stub}\n    , value_converter_{std::move(value_converter)}\n{}\n\nAsyncResult&lt;Image&gt; ProbeServiceImpl::take_snapshot(ObjectId id)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncCreateScreenshot&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_object_id(id);\n    RPC rpc{*grpc_context_};\n\n    co_await rpc.start(probe_service_stub_, request, agrpc::use_sender);\n\n    bool do_read{true};\n    quite::proto::ImageMetadata meta_data;\n    std::vector&lt;std::byte&gt; image_data;\n    while (do_read)\n    {\n        RPC::Response response;\n        do_read = co_await rpc.read(response, agrpc::use_sender);\n        const auto data_size = response.data().size();\n        LOG_DEBUG(grpc_probe(), \"got snapshot chunk. Size={}. Has more to read={}\", data_size, do_read);\n        const auto data_view = std::as_bytes(std::span{response.data().data(), data_size});\n        std::copy(data_view.begin(), data_view.end(), std::back_inserter(image_data));\n        if (response.has_metadata())\n        {\n            meta_data = response.metadata();\n        }\n    }\n    const auto status = co_await rpc.finish(agrpc::use_sender);\n    LOG_DEBUG(grpc_probe(), \"snapshot finished with status={}\", status.ok());\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    LOG_DEBUG(grpc_probe(), \"got final snapshot. Size={}\", image_data.size());\n    co_return Image{std::move(image_data), meta_data.width(), meta_data.height(), 4};\n}\n\nAsyncResult&lt;ObjectReference&gt; ProbeServiceImpl::find_object(ObjectQuery serach_query)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncFindObject&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    auto &amp;&amp;proto_query = request.mutable_query();\n\n    write_query(*proto_query, serach_query);\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    co_return ObjectReference{.object_id = response.object_id(), .type_id = response.type_id()};\n}\n\nAsyncResult&lt;std::unordered_map&lt;std::string, entt::meta_any&gt;&gt; ProbeServiceImpl::get_object_properties(\n    ObjectId object_id, std::vector&lt;std::string&gt; properties)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncGetObjectProperties&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_object_id(object_id);\n    request.mutable_property_names()-&gt;Reserve(static_cast&lt;int&gt;(properties.size()));\n    for (auto property_name : properties)\n    {\n        request.mutable_property_names()-&gt;Add(std::string{property_name});\n    }\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected{grpc_status2result(status)};\n    }\n\n    std::unordered_map&lt;std::string, entt::meta_any&gt; responses;\n    for (auto &amp;&amp;[k, v] : response.property_values())\n    {\n        responses.emplace(k, convert_value(entt::locator&lt;ValueRegistry&gt;::value(), *value_converter_, v));\n    }\n    co_return responses;\n}\n\nAsyncResult&lt;void&gt; ProbeServiceImpl::set_object_property(ObjectId object_id, std::string property, entt::meta_any value)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncSetObjectProperty&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_object_id(object_id);\n    request.set_property(std::move(property));\n    *request.mutable_value() = create_value(entt::locator&lt;ValueRegistry&gt;::value(), value);\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected{grpc_status2result(status)};\n    }\n    co_return {};\n}\n\nAsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; ProbeServiceImpl::query_top_level_views()\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncGetViews&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    std::vector&lt;ObjectReference&gt; objects;\n    for (auto &amp;&amp;object : response.object())\n    {\n        objects.emplace_back(ObjectReference{.object_id = object.object_id(), .type_id = object.type_id()});\n    }\n    co_return objects;\n}\n\nAsyncResult&lt;entt::meta_any&gt; ProbeServiceImpl::invoke_method(ObjectId id,\n                                                            std::string method_name,\n                                                            std::vector&lt;entt::meta_any&gt; parameters)\n{\n    using RPC = agrpc::ClientRPC&lt;&amp;proto::ProbeService::Stub::PrepareAsyncInvokeMethod&gt;;\n    grpc::ClientContext client_context;\n    configure_client_context(client_context);\n\n    RPC::Request request;\n    request.set_object_id(id);\n    auto *call = request.mutable_method_call();\n    call-&gt;set_method_name(std::move(method_name));\n    for (auto &amp;&amp;p : parameters)\n    {\n        *call-&gt;add_argument() = create_value(entt::locator&lt;ValueRegistry&gt;::value(), p);\n    }\n\n    RPC::Response response;\n    const auto status = co_await RPC::request(*grpc_context_, probe_service_stub_, client_context, request, response);\n    if (not status.ok())\n    {\n        co_return std::unexpected(grpc_status2result(status));\n    }\n    if (response.return_value().has_value())\n    {\n        co_return convert_value(\n            entt::locator&lt;ValueRegistry&gt;::value(), *value_converter_, response.return_value().value());\n    }\n    co_return entt::meta_any{std::in_place_type&lt;void&gt;};\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__service__impl_8hpp/","title":"File probe_service_impl.hpp","text":"<p>FileList &gt; client &gt; probe_service_impl.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include \"quite/proto/client/probe_service.hpp\"</code></li> <li><code>#include \"quite/proto/client/value_converter.hpp\"</code></li> <li><code>#include \"quite/proto/probe.grpc.pb.h\"</code></li> </ul>"},{"location":"quite/probe__service__impl_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__service__impl_8hpp/#classes","title":"Classes","text":"Type Name class ProbeServiceImpl <p>The documentation for this class was generated from the following file <code>libs/protocol/src/client/probe_service_impl.hpp</code></p>"},{"location":"quite/probe__service__impl_8hpp_source/","title":"File probe_service_impl.hpp","text":"<p>File List &gt; client &gt; probe_service_impl.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include \"quite/proto/client/probe_service.hpp\"\n#include \"quite/proto/client/value_converter.hpp\"\n#include \"quite/proto/probe.grpc.pb.h\"\n\nnamespace quite::proto\n{\nclass ProbeServiceImpl final : public IProbeService\n{\n  public:\n    explicit ProbeServiceImpl(std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context,\n                              ProbeService::Stub &amp;probe_service_stub,\n                              std::shared_ptr&lt;IValueConverter&gt; value_converter);\n\n    AsyncResult&lt;Image&gt; take_snapshot(ObjectId id) override;\n    AsyncResult&lt;ObjectReference&gt; find_object(ObjectQuery serach_query) override;\n    AsyncResult&lt;std::unordered_map&lt;std::string, entt::meta_any&gt;&gt; get_object_properties(\n        ObjectId object_id, std::vector&lt;std::string&gt; properties) override;\n    AsyncResult&lt;void&gt; set_object_property(ObjectId object_id, std::string property, entt::meta_any value) override;\n    AsyncResult&lt;std::vector&lt;ObjectReference&gt;&gt; query_top_level_views() override;\n    AsyncResult&lt;entt::meta_any&gt; invoke_method(ObjectId id,\n                                              std::string method_name,\n                                              std::vector&lt;entt::meta_any&gt; parameters) override;\n\n  private:\n    std::shared_ptr&lt;agrpc::GrpcContext&gt; grpc_context_;\n    ProbeService::Stub &amp;probe_service_stub_;\n    std::shared_ptr&lt;IValueConverter&gt; value_converter_;\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/dir_8a7b54f280cdd6b46c67f9938f379d86/","title":"Dir libs/protocol/src/probe","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe</p>"},{"location":"quite/dir_8a7b54f280cdd6b46c67f9938f379d86/#files","title":"Files","text":"Type Name file probe_handler_handle.hpp file probe_value_converter.hpp file rpc_fetch_windows.cpp file rpc_fetch_windows.hpp file rpc_find_object.cpp file rpc_find_object.hpp file rpc_invoke_method.cpp file rpc_invoke_method.hpp file rpc_meta_find_type.cpp file rpc_meta_find_type.hpp file rpc_mouse_injection.cpp file rpc_mouse_injection.hpp file rpc_object_properties.cpp file rpc_object_properties.hpp file rpc_set_object_property.cpp file rpc_set_object_property.hpp file rpc_snapshot.cpp file rpc_snapshot.hpp file server.cpp <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/</code></p>"},{"location":"quite/probe__handler__handle_8hpp/","title":"File probe_handler_handle.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; probe_handler_handle.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/service_handle.hpp&gt;</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> </ul>"},{"location":"quite/probe__handler__handle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/probe_handler_handle.hpp</code></p>"},{"location":"quite/probe__handler__handle_8hpp_source/","title":"File probe_handler_handle.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; probe_handler_handle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/service_handle.hpp&gt;\n#include \"quite/proto/probe/probe_handler.hpp\"\nnamespace quite::proto\n{\nclass IProbeHandler;\nusing ProbeHandlerHandle = ServiceHandle&lt;IProbeHandler&gt;;\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/probe__value__converter_8hpp/","title":"File probe_value_converter.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; probe_value_converter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/proto/client/value_converter.hpp\"</code></li> </ul>"},{"location":"quite/probe__value__converter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/probe__value__converter_8hpp/#classes","title":"Classes","text":"Type Name class ProbeValueConverter <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/probe_value_converter.hpp</code></p>"},{"location":"quite/probe__value__converter_8hpp_source/","title":"File probe_value_converter.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; probe_value_converter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"quite/proto/client/value_converter.hpp\"\nnamespace quite::proto\n{\nclass ProbeValueConverter final : public IValueConverter\n{\n    entt::meta_any from(ObjectReference ref) const override\n    {\n        return entt::forward_as_meta(std::move(ref));\n    }\n};\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__fetch__windows_8cpp/","title":"File rpc_fetch_windows.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_fetch_windows.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_fetch_windows.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> </ul>"},{"location":"quite/rpc__fetch__windows_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_fetch_windows.cpp</code></p>"},{"location":"quite/rpc__fetch__windows_8cpp_source/","title":"File rpc_fetch_windows.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_fetch_windows.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_fetch_windows.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"quite/proto/probe/probe_handler.hpp\"\n\nnamespace quite::proto\n{\nexec::task&lt;void&gt; GetViewsRpcHandler::operator()(GetViewsRPC &amp;rpc, const GetViewsRPC::Request &amp;request) const\n{\n    auto windows_result = co_await probe_handler-&gt;fetch_windows();\n    if (not windows_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(windows_result.error()));\n        co_return;\n    }\n\n    GetViewsRPC::Response response;\n    for (auto &amp;&amp;obj : windows_result.value())\n    {\n        auto &amp;&amp;proto_obj = response.add_object();\n        proto_obj-&gt;set_type_id(obj.type_id);\n        proto_obj-&gt;set_object_id(obj.type_id);\n    }\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;GetViewsRPC, GetViewsRpcHandler&gt; make_rpc_fetch_windows(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler)\n{\n    return agrpc::register_sender_rpc_handler&lt;GetViewsRPC&gt;(\n        grpc_context, service, GetViewsRpcHandler{std::move(probe_handler)});\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__fetch__windows_8hpp/","title":"File rpc_fetch_windows.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_fetch_windows.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"probe_handler_handle.hpp\"</code></li> </ul>"},{"location":"quite/rpc__fetch__windows_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__fetch__windows_8hpp/#classes","title":"Classes","text":"Type Name struct GetViewsRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_fetch_windows.hpp</code></p>"},{"location":"quite/rpc__fetch__windows_8hpp_source/","title":"File rpc_fetch_windows.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_fetch_windows.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"probe_handler_handle.hpp\"\n\nnamespace quite::proto\n{\nusing GetViewsRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetViews&gt;;\nstruct GetViewsRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    exec::task&lt;void&gt; operator()(GetViewsRPC &amp;rpc, const GetViewsRPC::Request &amp;request) const;\n};\n\nagrpc::detail::RPCHandlerSender&lt;GetViewsRPC, GetViewsRpcHandler&gt; make_rpc_fetch_windows(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__find__object_8cpp/","title":"File rpc_find_object.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_find_object.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_find_object.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"probe_value_converter.hpp\"</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> <li><code>#include \"value.hpp\"</code></li> </ul>"},{"location":"quite/rpc__find__object_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_find_object.cpp</code></p>"},{"location":"quite/rpc__find__object_8cpp_source/","title":"File rpc_find_object.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_find_object.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_find_object.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;fmt/format.h&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"probe_value_converter.hpp\"\n#include \"quite/proto/probe/probe_handler.hpp\"\n#include \"value.hpp\"\n\nnamespace quite::proto\n{\nnamespace\n{\nObjectQuery::PropertyMap convert_properties(const ValueRegistry &amp;value_registry,\n                                            const ::google::protobuf::Map&lt;std::string, Value&gt; &amp;proto_properties)\n{\n    ObjectQuery::PropertyMap properties;\n    for (auto &amp;&amp;prop : proto_properties)\n    {\n        properties.emplace(prop.first, convert_value(value_registry, ProbeValueConverter{}, prop.second));\n    }\n    return properties;\n}\n} // namespace\n\nexec::task&lt;void&gt; FindObjectRpcHandler::operator()(FindObjectRPC &amp;rpc, const FindObjectRPC::Request &amp;request)\n{\n    ObjectQuery object_query;\n    object_query.properties = convert_properties(*value_registry, request.query().properties());\n    object_query.type_name = request.query().has_type_name() ? request.query().type_name() : \"\";\n    ObjectQuery *child = &amp;object_query;\n    const proto::ObjectSearchQuery *parent{&amp;request.query()};\n    while (parent-&gt;has_parent())\n    {\n        parent = &amp;request.query().parent();\n        child-&gt;container = std::make_shared&lt;ObjectQuery&gt;();\n        child-&gt;container-&gt;properties = convert_properties(*value_registry, parent-&gt;properties());\n        child = child-&gt;container.get();\n    }\n\n    auto find_result = co_await probe_handler-&gt;find_object(std::move(object_query));\n    if (not find_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(find_result.error()));\n        co_return;\n    }\n\n    FindObjectRPC::Response response{};\n    response.set_object_id(find_result-&gt;object_id);\n    response.set_type_id(find_result-&gt;type_id);\n\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;FindObjectRPC, FindObjectRpcHandler&gt; make_rpc_find_object(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry)\n{\n    return agrpc::register_sender_rpc_handler&lt;FindObjectRPC&gt;(\n        grpc_context, service, FindObjectRpcHandler{std::move(probe_handler), std::move(value_registry)});\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__find__object_8hpp/","title":"File rpc_find_object.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_find_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"probe_handler_handle.hpp\"</code></li> </ul>"},{"location":"quite/rpc__find__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__find__object_8hpp/#classes","title":"Classes","text":"Type Name struct FindObjectRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_find_object.hpp</code></p>"},{"location":"quite/rpc__find__object_8hpp_source/","title":"File rpc_find_object.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_find_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"probe_handler_handle.hpp\"\n\nnamespace quite::proto\n{\nusing FindObjectRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestFindObject&gt;;\nstruct FindObjectRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    ServiceHandle&lt;ValueRegistry&gt; value_registry;\n    exec::task&lt;void&gt; operator()(FindObjectRPC &amp;rpc, const FindObjectRPC::Request &amp;request);\n};\n\nagrpc::detail::RPCHandlerSender&lt;FindObjectRPC, FindObjectRpcHandler&gt; make_rpc_find_object(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__invoke__method_8cpp/","title":"File rpc_invoke_method.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_invoke_method.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_invoke_method.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"probe_value_converter.hpp\"</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> <li><code>#include \"value.hpp\"</code></li> </ul>"},{"location":"quite/rpc__invoke__method_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_invoke_method.cpp</code></p>"},{"location":"quite/rpc__invoke__method_8cpp_source/","title":"File rpc_invoke_method.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_invoke_method.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_invoke_method.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;fmt/core.h&gt;\n#include \"error_helper.hpp\"\n#include \"probe_value_converter.hpp\"\n#include \"quite/proto/probe/probe_handler.hpp\"\n#include \"value.hpp\"\n\nnamespace quite::proto\n{\n\nexec::task&lt;void&gt; InvokeMethodRpcHandler::operator()(InvokeMethodRPC &amp;rpc, const InvokeMethodRPC::Request &amp;request) const\n{\n    if (not request.has_method_call())\n    {\n        co_await rpc.finish_with_error(\n            grpc::Status{grpc::StatusCode::FAILED_PRECONDITION, \"Can't invoke a method without a passed method.\"});\n        co_return;\n    }\n    auto root_object = co_await probe_handler-&gt;object_instance(request.object_id());\n    if (not root_object.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(root_object.error()));\n        co_return;\n    }\n\n    std::vector&lt;entt::meta_any&gt; params;\n    std::ranges::transform(request.method_call().argument(), std::back_inserter(params), [this](auto &amp;&amp;arg) {\n        return convert_value(*value_registry, ProbeValueConverter{}, arg);\n    });\n    auto invoke_result =\n        co_await probe_handler-&gt;invoke_method(*root_object, request.method_call().method_name(), std::move(params));\n    if (not invoke_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(invoke_result.error()));\n        co_return;\n    }\n    InvokeMethodRPC::Response response;\n    if (invoke_result-&gt;type().info() == entt::type_id&lt;void&gt;())\n    {\n        co_await rpc.finish(response, grpc::Status::OK);\n        co_return;\n    }\n    *response.mutable_return_value()-&gt;mutable_value() = create_value(*value_registry, *invoke_result);\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;InvokeMethodRPC, InvokeMethodRpcHandler&gt; make_rpc_invoke_method(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry)\n{\n    return agrpc::register_sender_rpc_handler&lt;InvokeMethodRPC&gt;(\n        grpc_context, service, InvokeMethodRpcHandler{std::move(probe_handler), std::move(value_registry)});\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__invoke__method_8hpp/","title":"File rpc_invoke_method.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_invoke_method.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"probe_handler_handle.hpp\"</code></li> <li><code>#include \"quite/value/value_registry.hpp\"</code></li> </ul>"},{"location":"quite/rpc__invoke__method_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__invoke__method_8hpp/#classes","title":"Classes","text":"Type Name struct InvokeMethodRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_invoke_method.hpp</code></p>"},{"location":"quite/rpc__invoke__method_8hpp_source/","title":"File rpc_invoke_method.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_invoke_method.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"probe_handler_handle.hpp\"\n#include \"quite/value/value_registry.hpp\"\n\nnamespace quite::proto\n{\nusing InvokeMethodRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestInvokeMethod&gt;;\nstruct InvokeMethodRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    ServiceHandle&lt;ValueRegistry&gt; value_registry;\n    exec::task&lt;void&gt; operator()(InvokeMethodRPC &amp;, const InvokeMethodRPC::Request &amp;) const;\n};\n\nagrpc::detail::RPCHandlerSender&lt;InvokeMethodRPC, InvokeMethodRpcHandler&gt; make_rpc_invoke_method(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__meta__find__type_8cpp/","title":"File rpc_meta_find_type.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_meta_find_type.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_meta_find_type.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"meta_converters.hpp\"</code></li> </ul>"},{"location":"quite/rpc__meta__find__type_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_meta_find_type.cpp</code></p>"},{"location":"quite/rpc__meta__find__type_8cpp_source/","title":"File rpc_meta_find_type.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_meta_find_type.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_meta_find_type.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;fmt/format.h&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/meta/meta_registry.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"meta_converters.hpp\"\n\nDEFINE_LOGGER(rpc_get_meta_object)\n\nnamespace quite::proto\n{\nexec::task&lt;void&gt; GetMetaObjectRpcHandler::operator()(FindTypeRPC &amp;rpc, const FindTypeRPC::Request &amp;request)\n{\n    LOG_TRACE_L1(rpc_get_meta_object(), \"START GetMetaObjectRpcHandler {}\", request.type_id());\n    FindTypeRPC::Response response;\n\n    auto result = co_await meta_registry-&gt;lookup_type(request.type_id());\n    if (not result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(result.error()));\n        co_return;\n    }\n    to_protocol(*result, *response.mutable_type());\n    co_await rpc.finish(response, grpc::Status::OK);\n    co_return;\n}\n\nagrpc::detail::RPCHandlerSender&lt;FindTypeRPC, GetMetaObjectRpcHandler&gt; make_rpc_meta_find_type(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::MetaService::AsyncService &amp;service,\n    ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry)\n{\n    return agrpc::register_sender_rpc_handler&lt;FindTypeRPC&gt;(\n        grpc_context, service, GetMetaObjectRpcHandler{std::move(meta_registry)});\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__meta__find__type_8hpp/","title":"File rpc_meta_find_type.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_meta_find_type.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/meta/meta_registry.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/meta_service.grpc.pb.h&gt;</code></li> <li><code>#include &lt;quite/service_handle.hpp&gt;</code></li> </ul>"},{"location":"quite/rpc__meta__find__type_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__meta__find__type_8hpp/#classes","title":"Classes","text":"Type Name struct GetMetaObjectRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_meta_find_type.hpp</code></p>"},{"location":"quite/rpc__meta__find__type_8hpp_source/","title":"File rpc_meta_find_type.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_meta_find_type.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/meta/meta_registry.hpp&gt;\n#include &lt;quite/proto/meta_service.grpc.pb.h&gt;\n#include &lt;quite/service_handle.hpp&gt;\n\nnamespace quite::proto\n{\nusing FindTypeRPC = agrpc::ServerRPC&lt;&amp;quite::proto::MetaService::AsyncService::RequestFindType&gt;;\nstruct GetMetaObjectRpcHandler\n{\n    ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry;\n    exec::task&lt;void&gt; operator()(FindTypeRPC &amp;rpc, const FindTypeRPC::Request &amp;request);\n};\n\nagrpc::detail::RPCHandlerSender&lt;FindTypeRPC, GetMetaObjectRpcHandler&gt; make_rpc_meta_find_type(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::MetaService::AsyncService &amp;service,\n    ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__mouse__injection_8cpp/","title":"File rpc_mouse_injection.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_mouse_injection.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_mouse_injection.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> <li><code>#include &lt;quite/injectors/mouse_injector.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> </ul>"},{"location":"quite/rpc__mouse__injection_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_mouse_injection.cpp</code></p>"},{"location":"quite/rpc__mouse__injection_8cpp_source/","title":"File rpc_mouse_injection.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_mouse_injection.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_mouse_injection.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;fmt/format.h&gt;\n#include &lt;quite/injectors/mouse_injector.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"error_helper.hpp\"\n\nDEFINE_LOGGER(rpc_mouse_action_logger)\nnamespace\n{\nquite::core::MouseAction mouse_action_from_request(const quite::proto::MouseActionRPC::Request &amp;request)\n{\n    return quite::core::MouseAction{\n        .position = {request.relative_point().x(), request.relative_point().y()},\n        .button =\n            [btn = request.mouse_button()]() {\n                switch (btn)\n                {\n                case quite::proto::left_button:\n                    return quite::core::MouseButton::left;\n                case quite::proto::right_button:\n                    return quite::core::MouseButton::right;\n                case quite::proto::middle_button:\n                    return quite::core::MouseButton::middle;\n                case quite::proto::MouseButton_INT_MIN_SENTINEL_DO_NOT_USE_:\n                case quite::proto::MouseButton_INT_MAX_SENTINEL_DO_NOT_USE_:\n                    break;\n                }\n                return quite::core::MouseButton::none;\n            }(),\n        .trigger =\n            [trigger = request.mouse_action()]() {\n                switch (trigger)\n                {\n                case quite::proto::none:\n                    return quite::core::MouseTrigger::none;\n                case quite::proto::click:\n                    return quite::core::MouseTrigger::click;\n                case quite::proto::double_click:\n                    return quite::core::MouseTrigger::double_click;\n                case quite::proto::press:\n                    return quite::core::MouseTrigger::press;\n                case quite::proto::release:\n                    return quite::core::MouseTrigger::release;\n                case quite::proto::move:\n                    return quite::core::MouseTrigger::move;\n                case quite::proto::MouseAction_INT_MIN_SENTINEL_DO_NOT_USE_:\n                case quite::proto::MouseAction_INT_MAX_SENTINEL_DO_NOT_USE_:\n                    break;\n                }\n                return quite::core::MouseTrigger::none;\n            }(),\n        .modifier =\n            [modifier = request.modifier_key()]() {\n                switch (modifier)\n                {\n                case quite::proto::no_mod:\n                    return quite::core::KeyboardModifier::none;\n                case quite::proto::shift:\n                    return quite::core::KeyboardModifier::shift;\n                case quite::proto::crtl:\n                    return quite::core::KeyboardModifier::control;\n                case quite::proto::alt:\n                    return quite::core::KeyboardModifier::alt;\n                case quite::proto::meta:\n                    return quite::core::KeyboardModifier::meta;\n                case quite::proto::keypad:\n                case quite::proto::KeyboardModifierKey_INT_MIN_SENTINEL_DO_NOT_USE_:\n                case quite::proto::KeyboardModifierKey_INT_MAX_SENTINEL_DO_NOT_USE_:\n                    break;\n                }\n                return quite::core::KeyboardModifier::none;\n            }(),\n    };\n}\n} // namespace\nnamespace quite::proto\n{\nexec::task&lt;void&gt; MouseActionRpcHandler::operator()(MouseActionRPC &amp;rpc, const MouseActionRPC::Request &amp;request) const\n{\n    LOG_TRACE_L1(rpc_mouse_action_logger(), \"START RequestMouseAction={}\", request.object_id());\n\n    const auto action = mouse_action_from_request(request);\n\n    const auto invoke_result = co_await mouse_injector-&gt;single_action(request.object_id(), action);\n    if (not invoke_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(invoke_result.error()));\n        co_return;\n    }\n    MouseActionRPC::Response response{};\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;MouseActionRPC, MouseActionRpcHandler&gt; make_rpc_mouse_injection(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector)\n{\n    return agrpc::register_sender_rpc_handler&lt;MouseActionRPC&gt;(\n        grpc_context, service, MouseActionRpcHandler{std::move(mouse_injector)});\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__mouse__injection_8hpp/","title":"File rpc_mouse_injection.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_mouse_injection.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"quite/injectors/mouse_injector.hpp\"</code></li> <li><code>#include \"quite/service_handle.hpp\"</code></li> </ul>"},{"location":"quite/rpc__mouse__injection_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__mouse__injection_8hpp/#classes","title":"Classes","text":"Type Name struct MouseActionRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_mouse_injection.hpp</code></p>"},{"location":"quite/rpc__mouse__injection_8hpp_source/","title":"File rpc_mouse_injection.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_mouse_injection.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"quite/injectors/mouse_injector.hpp\"\n#include \"quite/service_handle.hpp\"\nnamespace quite::proto\n{\nusing MouseActionRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestMouseAction&gt;;\nstruct MouseActionRpcHandler\n{\n    ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector;\n    exec::task&lt;void&gt; operator()(MouseActionRPC &amp;, const MouseActionRPC::Request &amp;) const;\n};\n\nagrpc::detail::RPCHandlerSender&lt;MouseActionRPC, MouseActionRpcHandler&gt; make_rpc_mouse_injection(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__object__properties_8cpp/","title":"File rpc_object_properties.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_object_properties.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_object_properties.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> <li><code>#include \"value.hpp\"</code></li> </ul>"},{"location":"quite/rpc__object__properties_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_object_properties.cpp</code></p>"},{"location":"quite/rpc__object__properties_8cpp_source/","title":"File rpc_object_properties.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_object_properties.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_object_properties.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"quite/proto/probe/probe_handler.hpp\"\n#include \"value.hpp\"\n\nDEFINE_LOGGER(rpc_get_object_properties)\n\nnamespace quite::proto\n{\n\nexec::task&lt;void&gt; GetObjectPropertiesRpcHandler::operator()(GetObjectPropertiesRPC &amp;rpc,\n                                                           const GetObjectPropertiesRPC::Request &amp;request)\n{\n    LOG_DEBUG(rpc_get_object_properties(), \"START RequestGetObjectProperty={}\", request.object_id());\n    std::vector&lt;std::string&gt; property_names;\n    property_names.reserve(request.property_names_size());\n    std::move(request.property_names().begin(), request.property_names().end(), std::back_inserter(property_names));\n    const auto properties_result =\n        co_await probe_handler-&gt;fetch_properties(request.object_id(), std::move(property_names));\n    if (not properties_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(properties_result.error()));\n        co_return;\n    }\n\n    GetObjectPropertiesRPC::Response response;\n    for (auto &amp;&amp;[key, value] : *properties_result)\n    {\n        response.mutable_property_values()-&gt;insert({key, create_value(*value_registry, value)});\n    }\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;GetObjectPropertiesRPC, GetObjectPropertiesRpcHandler&gt; make_rpc_fetch_object_properties(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry)\n{\n    return agrpc::register_sender_rpc_handler&lt;GetObjectPropertiesRPC&gt;(\n        grpc_context, service, GetObjectPropertiesRpcHandler{std::move(probe_handler), std::move(value_registry)});\n}\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__object__properties_8hpp/","title":"File rpc_object_properties.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_object_properties.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"probe/probe_handler_handle.hpp\"</code></li> <li><code>#include \"quite/value/value_registry.hpp\"</code></li> </ul>"},{"location":"quite/rpc__object__properties_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__object__properties_8hpp/#classes","title":"Classes","text":"Type Name struct GetObjectPropertiesRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_object_properties.hpp</code></p>"},{"location":"quite/rpc__object__properties_8hpp_source/","title":"File rpc_object_properties.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_object_properties.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"probe/probe_handler_handle.hpp\"\n#include \"quite/value/value_registry.hpp\"\n\nnamespace quite::proto\n{\nusing GetObjectPropertiesRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestGetObjectProperties&gt;;\nstruct GetObjectPropertiesRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    ServiceHandle&lt;ValueRegistry&gt; value_registry;\n    exec::task&lt;void&gt; operator()(GetObjectPropertiesRPC &amp;rpc, const GetObjectPropertiesRPC::Request &amp;request);\n};\n\nagrpc::detail::RPCHandlerSender&lt;GetObjectPropertiesRPC, GetObjectPropertiesRpcHandler&gt; make_rpc_fetch_object_properties(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__set__object__property_8cpp/","title":"File rpc_set_object_property.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_set_object_property.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_set_object_property.hpp\"</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"probe_value_converter.hpp\"</code></li> <li><code>#include \"value.hpp\"</code></li> </ul>"},{"location":"quite/rpc__set__object__property_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_set_object_property.cpp</code></p>"},{"location":"quite/rpc__set__object__property_8cpp_source/","title":"File rpc_set_object_property.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_set_object_property.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_set_object_property.hpp\"\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"probe_value_converter.hpp\"\n#include \"value.hpp\"\n\nDEFINE_LOGGER(rpc_set_object_properties)\n\nnamespace quite::proto\n{\nexec::task&lt;void&gt; SetObjectPropertyRpcHandler::operator()(SetObjectPropertyRPC &amp;rpc,\n                                                         const SetObjectPropertyRPC::Request &amp;request)\n{\n    LOG_DEBUG(rpc_set_object_properties(), \"START SetObjectProperty={}\", request.object_id());\n\n    const auto write_result =\n        co_await probe_handler-&gt;set_property(request.object_id(),\n                                             request.property(),\n                                             convert_value(*value_registry, ProbeValueConverter{}, request.value()));\n    if (not write_result.has_value())\n    {\n        co_await rpc.finish_with_error(result2grpc_status(write_result.error()));\n        co_return;\n    }\n\n    SetObjectPropertyRPC::Response response;\n    co_await rpc.finish(response, grpc::Status::OK);\n}\n\nagrpc::detail::RPCHandlerSender&lt;SetObjectPropertyRPC, SetObjectPropertyRpcHandler&gt; make_rpc_set_object_property(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry)\n{\n    return agrpc::register_sender_rpc_handler&lt;SetObjectPropertyRPC&gt;(\n        grpc_context, service, SetObjectPropertyRpcHandler{std::move(probe_handler), std::move(value_registry)});\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__set__object__property_8hpp/","title":"File rpc_set_object_property.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_set_object_property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/grpc_context.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"probe/probe_handler_handle.hpp\"</code></li> <li><code>#include \"quite/value/value_registry.hpp\"</code></li> </ul>"},{"location":"quite/rpc__set__object__property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__set__object__property_8hpp/#classes","title":"Classes","text":"Type Name struct SetObjectPropertyRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_set_object_property.hpp</code></p>"},{"location":"quite/rpc__set__object__property_8hpp_source/","title":"File rpc_set_object_property.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_set_object_property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/grpc_context.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"probe/probe_handler_handle.hpp\"\n#include \"quite/value/value_registry.hpp\"\n\nnamespace quite::proto\n{\nusing SetObjectPropertyRPC = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestSetObjectProperty&gt;;\nstruct SetObjectPropertyRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    ServiceHandle&lt;ValueRegistry&gt; value_registry;\n    exec::task&lt;void&gt; operator()(SetObjectPropertyRPC &amp;rpc, const SetObjectPropertyRPC::Request &amp;request);\n};\n\nagrpc::detail::RPCHandlerSender&lt;SetObjectPropertyRPC, SetObjectPropertyRpcHandler&gt; make_rpc_set_object_property(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler,\n    ServiceHandle&lt;ValueRegistry&gt; value_registry);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__snapshot_8cpp/","title":"File rpc_snapshot.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_snapshot.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rpc_snapshot.hpp\"</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;entt/locator/locator.hpp&gt;</code></li> <li><code>#include \"error_helper.hpp\"</code></li> <li><code>#include \"quite/proto/probe/probe_handler.hpp\"</code></li> </ul>"},{"location":"quite/rpc__snapshot_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_snapshot.cpp</code></p>"},{"location":"quite/rpc__snapshot_8cpp_source/","title":"File rpc_snapshot.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_snapshot.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"rpc_snapshot.hpp\"\n#include &lt;ranges&gt;\n#include &lt;agrpc/register_sender_rpc_handler.hpp&gt;\n#include &lt;entt/locator/locator.hpp&gt;\n#include \"error_helper.hpp\"\n#include \"quite/proto/probe/probe_handler.hpp\"\n\nnamespace quite::proto\n{\n\nexec::task&lt;void&gt; SnapshotRpcHandler::operator()(RpcSnapshot &amp;rpc, const RpcSnapshot::Request &amp;request) const\n{\n    auto result = co_await probe_handler-&gt;take_snapshot(request.object_id());\n    if (not result.has_value())\n    {\n        co_await rpc.finish(result2grpc_status(result.error()));\n        co_return;\n    }\n    constexpr std::int64_t k4Mb = 4'000'000;\n    auto &amp;image = *result;\n    RpcSnapshot::Response response;\n    response.mutable_metadata()-&gt;set_width(image.width);\n    response.mutable_metadata()-&gt;set_height(image.height);\n    const auto blocks = image.image_data | std::views::chunk(k4Mb);\n    for (auto &amp;&amp;block : blocks)\n    {\n        response.mutable_data()-&gt;reserve(block.size());\n        std::ranges::copy(block, std::back_inserter(*response.mutable_data()));\n\n        const auto written = co_await rpc.write(response);\n        if (not written)\n        {\n            co_await rpc.finish(grpc::Status::CANCELLED);\n            co_return;\n        }\n        response.mutable_data()-&gt;clear();\n    }\n    co_await rpc.finish(grpc::Status::OK);\n    co_return;\n}\n\nagrpc::detail::RPCHandlerSender&lt;RpcSnapshot, SnapshotRpcHandler&gt; make_rpc_snapshot(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler)\n{\n    return agrpc::register_sender_rpc_handler&lt;RpcSnapshot&gt;(\n        grpc_context, service, SnapshotRpcHandler{std::move(probe_handler)});\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/rpc__snapshot_8hpp/","title":"File rpc_snapshot.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_snapshot.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;</code></li> <li><code>#include &lt;agrpc/server_rpc.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"probe_handler_handle.hpp\"</code></li> </ul>"},{"location":"quite/rpc__snapshot_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/rpc__snapshot_8hpp/#classes","title":"Classes","text":"Type Name struct SnapshotRpcHandler <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/rpc_snapshot.hpp</code></p>"},{"location":"quite/rpc__snapshot_8hpp_source/","title":"File rpc_snapshot.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; rpc_snapshot.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;agrpc/detail/register_sender_rpc_handler.hpp&gt;\n#include &lt;agrpc/server_rpc.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"probe_handler_handle.hpp\"\n\nnamespace quite::proto\n{\nusing RpcSnapshot = agrpc::ServerRPC&lt;&amp;quite::proto::ProbeService::AsyncService::RequestCreateScreenshot&gt;;\nstruct SnapshotRpcHandler\n{\n    ProbeHandlerHandle probe_handler;\n    exec::task&lt;void&gt; operator()(RpcSnapshot &amp;rpc, const RpcSnapshot::Request &amp;request) const;\n};\n\nagrpc::detail::RPCHandlerSender&lt;RpcSnapshot, SnapshotRpcHandler&gt; make_rpc_snapshot(\n    agrpc::GrpcContext &amp;grpc_context,\n    quite::proto::ProbeService::AsyncService &amp;service,\n    ProbeHandlerHandle probe_handler);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/protocol_2src_2probe_2server_8cpp/","title":"File server.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; probe &gt; server.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/proto/probe/server.hpp\"</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;exec/env.hpp&gt;</code></li> <li><code>#include &lt;exec/finally.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/health.grpc.pb.h&gt;</code></li> <li><code>#include &lt;quite/proto/meta_service.grpc.pb.h&gt;</code></li> <li><code>#include &lt;quite/proto/probe.grpc.pb.h&gt;</code></li> <li><code>#include \"rpc_fetch_windows.hpp\"</code></li> <li><code>#include \"rpc_find_object.hpp\"</code></li> <li><code>#include \"rpc_invoke_method.hpp\"</code></li> <li><code>#include \"rpc_meta_find_type.hpp\"</code></li> <li><code>#include \"rpc_mouse_injection.hpp\"</code></li> <li><code>#include \"rpc_object_properties.hpp\"</code></li> <li><code>#include \"rpc_set_object_property.hpp\"</code></li> <li><code>#include \"rpc_snapshot.hpp\"</code></li> <li><code>#include &lt;grpc++/server_builder.h&gt;</code></li> <li><code>#include &lt;agrpc/health_check_service.hpp&gt;</code></li> </ul>"},{"location":"quite/protocol_2src_2probe_2server_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/protocol_2src_2probe_2server_8cpp/#classes","title":"Classes","text":"Type Name class Impl"},{"location":"quite/protocol_2src_2probe_2server_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOGGER (grpc_server_log)"},{"location":"quite/protocol_2src_2probe_2server_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/protocol_2src_2probe_2server_8cpp/#function-define_logger","title":"function DEFINE_LOGGER","text":"<pre><code>DEFINE_LOGGER (\n    grpc_server_log\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/src/probe/server.cpp</code></p>"},{"location":"quite/protocol_2src_2probe_2server_8cpp_source/","title":"File server.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; probe &gt; server.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/proto/probe/server.hpp\"\n#include &lt;thread&gt;\n#include &lt;exec/env.hpp&gt;\n#include &lt;exec/finally.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/proto/health.grpc.pb.h&gt;\n#include &lt;quite/proto/meta_service.grpc.pb.h&gt;\n#include &lt;quite/proto/probe.grpc.pb.h&gt;\n#include \"rpc_fetch_windows.hpp\"\n#include \"rpc_find_object.hpp\"\n#include \"rpc_invoke_method.hpp\"\n#include \"rpc_meta_find_type.hpp\"\n#include \"rpc_mouse_injection.hpp\"\n#include \"rpc_object_properties.hpp\"\n#include \"rpc_set_object_property.hpp\"\n#include \"rpc_snapshot.hpp\"\n#include &lt;grpc++/server_builder.h&gt;\n// needs to be after health.grpc.pb.h\n#include &lt;agrpc/health_check_service.hpp&gt;\n\nDEFINE_LOGGER(grpc_server_log);\n\nnamespace quite::proto\n{\nclass Server::Impl\n{\n    stdexec::inplace_stop_source ssource_;\n    ServiceHandle&lt;IProbeHandler&gt; probe_handler_;\n    ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector_;\n    ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry_;\n    ServiceHandle&lt;ValueRegistry&gt; value_registry_;\n    grpc::ServerBuilder builder_;\n    std::unique_ptr&lt;grpc::Server&gt; grpc_server_; // server has to be destroyed after grpc_context_\n    agrpc::GrpcContext grpc_context_{builder_.AddCompletionQueue()};\n    std::jthread grpc_runner_;\n\n  public:\n    Impl(std::string server_address,\n         ServiceHandle&lt;IProbeHandler&gt; probe_handler,\n         ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector,\n         ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry,\n         ServiceHandle&lt;ValueRegistry&gt; value_registry)\n        : probe_handler_{std::move(probe_handler)}\n        , mouse_injector_{std::move(mouse_injector)}\n        , meta_registry_{std::move(meta_registry)}\n        , value_registry_{std::move(value_registry)}\n        , grpc_runner_{[this, server_address = std::move(server_address)]() {\n            run_server_until_stopped(std::move(server_address));\n        }}\n    {}\n\n    ~Impl()\n    {\n        // wait for the grpc context to be running at least once otherwise we have race conditions in the\n        // initialization.\n        stdexec::sync_wait(stdexec::schedule(grpc_context_.get_scheduler()) | stdexec::then([this] {\n                               // LOG_DEBUG(grpc_server_log(), \"Shutting grpc server down...\");\n                               ssource_.request_stop();\n                               grpc_server_-&gt;Shutdown(std::chrono::system_clock::now() + std::chrono::seconds{10});\n                           }) |\n                           stdexec::then([this] { grpc_server_-&gt;Wait(); }));\n    }\n\n  private:\n    void run_server_until_stopped(std::string server_address)\n    {\n\n        builder_.AddListeningPort(server_address, grpc::InsecureServerCredentials());\n\n        ProbeService::AsyncService object_service;\n        MetaService::AsyncService meta_service;\n\n        builder_.RegisterService(std::addressof(object_service));\n        builder_.RegisterService(std::addressof(meta_service));\n        agrpc::add_health_check_service(builder_);\n\n        grpc_server_ = builder_.BuildAndStart();\n\n        agrpc::start_health_check_service(*grpc_server_, grpc_context_);\n\n        stdexec::sender auto rpc_snapshot = make_rpc_snapshot(grpc_context_, object_service, probe_handler_);\n        stdexec::sender auto rpc_find_object =\n            make_rpc_find_object(grpc_context_, object_service, probe_handler_, value_registry_);\n        stdexec::sender auto rpc_fetch_object_properties =\n            make_rpc_fetch_object_properties(grpc_context_, object_service, probe_handler_, value_registry_);\n        stdexec::sender auto rpc_set_object_property =\n            make_rpc_set_object_property(grpc_context_, object_service, probe_handler_, value_registry_);\n        stdexec::sender auto rpc_fetch_windows = make_rpc_fetch_windows(grpc_context_, object_service, probe_handler_);\n        stdexec::sender auto rpc_invoke_method =\n            make_rpc_invoke_method(grpc_context_, object_service, probe_handler_, value_registry_);\n        stdexec::sender auto rpc_mouse_injection =\n            make_rpc_mouse_injection(grpc_context_, object_service, mouse_injector_);\n        stdexec::sender auto rpc_meta_find_type = make_rpc_meta_find_type(grpc_context_, meta_service, meta_registry_);\n\n        auto stop_token_env = stdexec::write_env(stdexec::prop{stdexec::get_stop_token, ssource_.get_token()});\n        stdexec::sender auto all_snd = stdexec::when_all(std::move(rpc_snapshot) | stop_token_env,\n                                                         std::move(rpc_find_object) | stop_token_env,\n                                                         std::move(rpc_fetch_object_properties) | stop_token_env,\n                                                         std::move(rpc_set_object_property) | stop_token_env,\n                                                         std::move(rpc_fetch_windows) | stop_token_env,\n                                                         std::move(rpc_invoke_method) | stop_token_env,\n                                                         std::move(rpc_mouse_injection) | stop_token_env,\n                                                         std::move(rpc_meta_find_type) | stop_token_env);\n\n        stdexec::start_detached(stdexec::starts_on(grpc_context_.get_scheduler(), stdexec::just()) |\n                                stdexec::then([&amp;] { LOG_DEBUG(grpc_server_log(), \"grpc context running!\"); }));\n\n        grpc_context_.work_started();\n        stdexec::sync_wait(stdexec::when_all(\n            exec::finally(stdexec::starts_on(exec::inline_scheduler{}, stdexec::when_all(std::move(all_snd))),\n                          stdexec::then(stdexec::just(),\n                                        [&amp;] {\n                                            grpc_context_.work_finished();\n                                            // LOG_DEBUG(grpc_server_log(), \"grpc context finished work.\");\n                                        })),\n            stdexec::then(stdexec::just(), [&amp;] {\n                LOG_DEBUG(grpc_server_log(), \"Starting grpc context...\");\n                grpc_context_.run();\n                // LOG_DEBUG(grpc_server_log(), \"grpc context finished\");\n            })));\n\n        // LOG_DEBUG(grpc_server_log(), \"grpc thread finished\");\n    }\n};\n\nServer::Server(std::string server_address,\n               ServiceHandle&lt;IProbeHandler&gt; probe_handler,\n               ServiceHandle&lt;core::IMouseInjector&gt; mouse_injector,\n               ServiceHandle&lt;meta::MetaRegistry&gt; meta_registry,\n               ServiceHandle&lt;ValueRegistry&gt; value_registry)\n    : impl_{std::make_unique&lt;Impl&gt;(std::move(server_address),\n                                   std::move(probe_handler),\n                                   std::move(mouse_injector),\n                                   std::move(meta_registry),\n                                   std::move(value_registry))}\n{}\n\nServer::Server(Server &amp;&amp;server) noexcept\n    : impl_{std::move(server.impl_)}\n{}\n\nServer &amp;Server::operator=(Server &amp;&amp;server) noexcept\n{\n    impl_ = std::move(server.impl_);\n    return *this;\n}\n\nServer::~Server() = default;\n\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/meta__converters_8cpp/","title":"File meta_converters.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; meta_converters.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"meta_converters.hpp\"</code></li> <li><code>#include &lt;ranges&gt;</code></li> </ul>"},{"location":"quite/meta__converters_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto"},{"location":"quite/meta__converters_8cpp/#classes","title":"Classes","text":"Type Name struct ProtocolVisitor <p>The documentation for this class was generated from the following file <code>libs/protocol/src/meta_converters.cpp</code></p>"},{"location":"quite/meta__converters_8cpp_source/","title":"File meta_converters.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; meta_converters.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"meta_converters.hpp\"\n#include &lt;ranges&gt;\n\nnamespace quite::proto\n{\nnamespace\n{\nmeta::Method transform_method(const MetaMethod &amp;method)\n{\n    auto m = meta::Method{.name = method.name(), .return_type = method.return_type_id()};\n    std::ranges::copy(method.parameter_types() | std::views::transform([](auto &amp;&amp;name_type_id_pair) {\n                          return meta::Property{.name = name_type_id_pair.first, .type = name_type_id_pair.second};\n                      }),\n                      std::back_inserter(m.parameters));\n    return m;\n}\n} // namespace\n\nmeta::PrimitiveType from_protocol(const MetaPrimitiveType &amp;type)\n{\n    switch (type)\n    {\n    case MetaPrimitiveType::unknown:\n        return meta::PrimitiveType::type_unknown;\n    case MetaPrimitiveType::void_:\n        return meta::PrimitiveType::type_void;\n    case MetaPrimitiveType::int_:\n        return meta::PrimitiveType::type_int;\n    case MetaPrimitiveType::uint:\n        return meta::PrimitiveType::type_uint;\n    case MetaPrimitiveType::float_:\n        return meta::PrimitiveType::type_float;\n    case MetaPrimitiveType::double_:\n        return meta::PrimitiveType::type_double;\n    case MetaPrimitiveType::bool_:\n        return meta::PrimitiveType::type_bool;\n    case MetaPrimitiveType::string:\n        return meta::PrimitiveType::type_string;\n    case MetaPrimitiveType::MetaPrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_:\n    case MetaPrimitiveType::MetaPrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_:\n        break;\n    }\n    return meta::PrimitiveType::type_unknown;\n}\n\nmeta::ListType from_protocol(const MetaListType &amp;type)\n{\n    return meta::ListType{.id = type.type_id(), .name = type.name(), .value_type = type.value_type_id()};\n}\n\nmeta::MapType from_protocol(const MetaMapType &amp;type)\n{\n    return meta::MapType{\n        .id = type.type_id(), .name = type.name(), .key_type = type.key_type_id(), .value_type = type.value_type_id()};\n}\n\nmeta::ObjectTypePtr from_protocol(const MetaObjectType &amp;type)\n{\n    auto obj = std::make_unique&lt;meta::ObjectType&gt;();\n    obj-&gt;id = type.type_id();\n    obj-&gt;name = type.name();\n    std::ranges::copy(type.properties() | std::views::transform([](auto &amp;&amp;meta_prop) {\n                          return meta::Property{.name = meta_prop.name(), .type = meta_prop.type_id()};\n                      }),\n                      std::back_inserter(obj-&gt;properties));\n\n    std::ranges::copy(type.constructors() | std::views::transform(transform_method),\n                      std::back_inserter(obj-&gt;constructors));\n\n    std::ranges::copy(type.methods() | std::views::transform(transform_method), std::back_inserter(obj-&gt;methods));\n\n    return obj;\n}\n\nmeta::EnumTypePtr from_protocol(const MetaEnumType &amp;type)\n{\n    auto meta_enum = std::make_unique&lt;meta::EnumType&gt;();\n    meta_enum-&gt;id = type.type_id();\n    meta_enum-&gt;name = type.name();\n    for (auto &amp;&amp;[name, value] : type.name_value())\n    {\n        meta_enum-&gt;values.emplace(name, value);\n    }\n    return meta_enum;\n}\n\nstruct ProtocolVisitor\n{\n    MetaType &amp;proto;\n\n    void operator()(const meta::PrimitiveType &amp;meta)\n    {\n        switch (meta)\n        {\n        case meta::PrimitiveType::type_unknown:\n            proto.set_primitive_type(MetaPrimitiveType::unknown);\n            break;\n        case meta::PrimitiveType::type_void:\n            proto.set_primitive_type(MetaPrimitiveType::void_);\n            break;\n        case meta::PrimitiveType::type_int:\n            proto.set_primitive_type(MetaPrimitiveType::int_);\n            break;\n        case meta::PrimitiveType::type_uint:\n            proto.set_primitive_type(MetaPrimitiveType::uint);\n            break;\n        case meta::PrimitiveType::type_float:\n            proto.set_primitive_type(MetaPrimitiveType::float_);\n            break;\n        case meta::PrimitiveType::type_double:\n            proto.set_primitive_type(MetaPrimitiveType::double_);\n            break;\n        case meta::PrimitiveType::type_bool:\n            proto.set_primitive_type(MetaPrimitiveType::bool_);\n            break;\n        case meta::PrimitiveType::type_string:\n            proto.set_primitive_type(MetaPrimitiveType::string);\n            break;\n        }\n    }\n\n    void operator()(const meta::ListType &amp;meta)\n    {\n        auto &amp;&amp;list = proto.mutable_list_type();\n        list-&gt;set_type_id(meta.id);\n        list-&gt;set_value_type_id(meta.value_type);\n        list-&gt;set_name(meta.name);\n    }\n\n    void operator()(const meta::MapType &amp;meta)\n    {\n        auto &amp;&amp;map = proto.mutable_map_type();\n        map-&gt;set_name(meta.name);\n        map-&gt;set_type_id(meta.id);\n        map-&gt;set_key_type_id(meta.key_type);\n        map-&gt;set_value_type_id(meta.value_type);\n    }\n\n    void operator()(const meta::EnumTypePtr &amp;meta)\n    {\n        auto &amp;&amp;enum_entry = proto.mutable_enum_type();\n        enum_entry-&gt;set_name(meta-&gt;name);\n        enum_entry-&gt;set_type_id(meta-&gt;id);\n        for (auto &amp;&amp;[name, value] : meta-&gt;values)\n        {\n            enum_entry-&gt;mutable_name_value()-&gt;insert({name, static_cast&lt;std::uint64_t&gt;(value)});\n        }\n    }\n\n    void operator()(const meta::ObjectTypePtr &amp;meta)\n    {\n        auto &amp;&amp;object = proto.mutable_object_type();\n        object-&gt;set_type_id(meta-&gt;id);\n        object-&gt;set_name(meta-&gt;name);\n        for (auto &amp;&amp;x : meta-&gt;properties)\n        {\n            object-&gt;add_properties()-&gt;set_name(x.name);\n        }\n        std::ranges::for_each(\n            meta-&gt;properties,\n            [](auto &amp;&amp;property_pack) {\n                auto &amp;&amp;[proto, meta] = property_pack;\n                proto-&gt;set_name(meta.name);\n                proto-&gt;set_type_id(meta.type);\n            },\n            [&amp;object](auto &amp;&amp;prop) { return std::tuple{object-&gt;add_properties(), prop}; });\n\n        auto add_method = [](std::tuple&lt;MetaMethod *, const meta::Method &amp;&gt; method_meta_pack) {\n            auto &amp;&amp;[method, meta] = method_meta_pack;\n            method-&gt;set_name(meta.name);\n            method-&gt;set_return_type_id(meta.return_type);\n            std::ranges::for_each(\n                meta.parameters,\n                [&amp;method](auto &amp;&amp;param) { method-&gt;mutable_parameter_types()-&gt;insert({param.name, param.type}); },\n                [](auto &amp;&amp;property) { return property; });\n        };\n\n        std::ranges::for_each(meta-&gt;methods, add_method, [&amp;object](auto &amp;&amp;method) {\n            return std::tuple&lt;MetaMethod *, const meta::Method &amp;&gt;{object-&gt;add_methods(), method};\n        });\n\n        std::ranges::for_each(meta-&gt;constructors, add_method, [&amp;object](auto &amp;&amp;method) {\n            return std::tuple&lt;MetaMethod *, const meta::Method &amp;&gt;{object-&gt;add_constructors(), method};\n        });\n    }\n};\n\nvoid to_protocol(const meta::Type &amp;type, MetaType &amp;proto)\n{\n    std::visit(ProtocolVisitor{proto}, type);\n}\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/meta__converters_8hpp/","title":"File meta_converters.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; meta_converters.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/meta/meta_types.hpp&gt;</code></li> <li><code>#include \"quite/proto/meta.pb.h\"</code></li> </ul>"},{"location":"quite/meta__converters_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/meta_converters.hpp</code></p>"},{"location":"quite/meta__converters_8hpp_source/","title":"File meta_converters.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; meta_converters.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/meta/meta_types.hpp&gt;\n#include \"quite/proto/meta.pb.h\"\nnamespace quite::proto\n{\nmeta::PrimitiveType from_protocol(const MetaPrimitiveType &amp;type);\nmeta::ListType from_protocol(const MetaListType &amp;type);\nmeta::MapType from_protocol(const MetaMapType &amp;type);\nmeta::ObjectTypePtr from_protocol(const MetaObjectType &amp;type);\nmeta::EnumTypePtr from_protocol(const MetaEnumType &amp;type);\n\nvoid to_protocol(const meta::Type &amp;type, MetaType &amp;proto);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/value_8cpp/","title":"File value.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; value.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"value.hpp\"</code></li> <li><code>#include &lt;ranges&gt;</code></li> <li><code>#include &lt;entt/core/hashed_string.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/container.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/resolve.hpp&gt;</code></li> <li><code>#include &lt;entt/meta/utility.hpp&gt;</code></li> <li><code>#include \"quite/value/generic_value_class.hpp\"</code></li> <li><code>#include \"quite/value/object_id.hpp\"</code></li> </ul>"},{"location":"quite/value_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/value.cpp</code></p>"},{"location":"quite/value_8cpp_source/","title":"File value.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; value.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"value.hpp\"\n#include &lt;ranges&gt;\n#include &lt;entt/core/hashed_string.hpp&gt;\n#include &lt;entt/meta/container.hpp&gt;\n#include &lt;entt/meta/resolve.hpp&gt;\n#include &lt;entt/meta/utility.hpp&gt;\n#include \"quite/value/generic_value_class.hpp\"\n#include \"quite/value/object_id.hpp\"\n\nusing namespace entt::literals;\n\nnamespace quite::proto\n{\nnamespace\n{\nvoid convert_class(const ValueRegistry &amp;value_registry, Value &amp;value, const entt::meta_any &amp;any);\nvoid convert_string(Value &amp;value, const entt::meta_any &amp;any);\nvoid convert_arithmetic(Value &amp;value, const entt::meta_any &amp;any);\nvoid convert_object_ptr(Value &amp;value, const entt::meta_any &amp;any);\nvoid convert_sequence_container(const ValueRegistry &amp;value_registry, Value &amp;value, const entt::meta_any &amp;any);\n} // namespace\n\nValue create_value(const ValueRegistry &amp;value_registry, const entt::meta_any &amp;any)\n{\n    Value value;\n    const auto type = any.type();\n\n    if (type.is_class() and not type.is_pointer_like())\n    {\n        const auto string_type = entt::resolve&lt;std::string&gt;();\n        if (type.can_convert(string_type))\n        {\n            convert_string(value, any);\n        }\n        else\n        {\n            convert_class(value_registry, value, any);\n        }\n    }\n    else if (type.is_arithmetic())\n    {\n        convert_arithmetic(value, any);\n    }\n    else if (type.is_pointer() or type.is_pointer_like())\n    {\n        convert_object_ptr(value, any);\n    }\n    else if (type.is_sequence_container())\n    {\n        convert_sequence_container(value_registry, value, any);\n    }\n    return value;\n}\n\nentt::meta_any convert_value(const ValueRegistry &amp;value_registry, const IValueConverter &amp;converter, const Value &amp;value)\n{\n    if (value.has_bool_val())\n    {\n        return entt::forward_as_meta(value_registry.context(), value.bool_val());\n    }\n    if (value.has_int_val())\n    {\n        return entt::forward_as_meta(value_registry.context(), value.uint_val());\n    }\n    if (value.has_uint_val())\n    {\n        return entt::forward_as_meta(value_registry.context(), value.uint_val());\n    }\n    if (value.has_double_val())\n    {\n        return entt::forward_as_meta(value_registry.context(), value.double_val());\n    }\n    if (value.has_string_val())\n    {\n        return entt::forward_as_meta(value_registry.context(), std::string{value.string_val()});\n    }\n    if (value.has_object_val())\n    {\n        auto type_id = entt::resolve(value.type_id());\n        if (type_id)\n        {\n            constexpr bool kDontTransferOwnership{false};\n            return type_id.from_void(reinterpret_cast&lt;void *&gt;(value.object_val().object_id()), kDontTransferOwnership);\n        }\n        return converter.from(ObjectReference{.object_id = value.object_val().object_id(), .type_id = value.type_id()});\n    }\n    if (value.has_array_val())\n    {\n        std::vector&lt;entt::meta_any&gt; array;\n        std::ranges::copy(std::views::transform(value.array_val().value(),\n                                                [&amp;value_registry, &amp;converter](auto &amp;&amp;value) {\n                                                    return convert_value(value_registry, converter, value);\n                                                }),\n                          std::back_inserter(array));\n        return entt::forward_as_meta(std::move(array));\n    }\n    if (value.has_class_val())\n    {\n        GenericClass generic;\n        for (auto &amp;&amp;member : value.class_val().value())\n        {\n            generic.properties.emplace(member.name(), convert_value(value_registry, converter, member.value()));\n        }\n        return entt::forward_as_meta(std::move(generic));\n    }\n    return entt::meta_any{};\n}\n\nnamespace\n{\nvoid convert_class(const ValueRegistry &amp;value_registry, Value &amp;value, const entt::meta_any &amp;any)\n{\n    const auto type = any.type();\n\n    auto *class_value = value.mutable_class_val();\n    if (type.info() == entt::type_id&lt;GenericClass&gt;())\n    {\n        const auto &amp;properties = any.cast&lt;GenericClass&gt;().properties;\n        for (auto &amp;&amp;[name, value] : properties)\n        {\n            auto &amp;&amp;class_member = class_value-&gt;add_value();\n            class_member-&gt;set_name(name);\n            *class_member-&gt;mutable_value() = create_value(value_registry, value);\n        }\n    }\n    else\n    {\n        for (auto &amp;&amp;data_member : type.data())\n        {\n            auto it = value_registry.property_names().find(data_member.first);\n            if (it == value_registry.property_names().end())\n            {\n                continue;\n            }\n            auto &amp;&amp;class_member = class_value-&gt;add_value();\n            class_member-&gt;set_name(it-&gt;second);\n            *class_member-&gt;mutable_value() = create_value(value_registry, data_member.second.get(any));\n        }\n    }\n}\n\nvoid convert_arithmetic(Value &amp;value, const entt::meta_any &amp;any)\n{\n    const auto type = any.type();\n    if (type.info() == entt::type_id&lt;bool&gt;())\n    {\n        value.set_bool_val(any.cast&lt;bool&gt;());\n    }\n    else if (type.is_integral())\n    {\n        if (type.is_signed())\n        {\n            const auto casted_value = any.allow_cast&lt;std::int64_t&gt;();\n            value.set_int_val(casted_value.cast&lt;std::int64_t&gt;());\n        }\n        else\n        {\n            const auto casted_value = any.allow_cast&lt;std::uint64_t&gt;();\n            value.set_uint_val(casted_value.cast&lt;std::uint64_t&gt;());\n        }\n    }\n    else\n    {\n        const auto casted_value = any.allow_cast&lt;double&gt;();\n        value.set_double_val(casted_value.cast&lt;double&gt;());\n    }\n}\n\nvoid convert_string(Value &amp;value, const entt::meta_any &amp;any)\n{\n    const auto string_any = any.allow_cast&lt;std::string&gt;();\n    value.set_string_val(string_any.cast&lt;std::string&gt;());\n}\n\nvoid convert_object_ptr(Value &amp;value, const entt::meta_any &amp;any)\n{\n    const auto containing_value = *any;\n    value.mutable_object_val()-&gt;set_object_id(reinterpret_cast&lt;std::uint64_t&gt;(containing_value.base().data()));\n}\n\nvoid convert_sequence_container(const ValueRegistry &amp;value_registry, Value &amp;value, const entt::meta_any &amp;any)\n{\n    auto &amp;&amp;array = value.mutable_array_val();\n    for (auto &amp;&amp;el : any.as_sequence_container())\n    {\n        *array-&gt;add_value() = create_value(value_registry, el);\n    }\n}\n} // namespace\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/value_8hpp/","title":"File value.hpp","text":"<p>FileList &gt; libs &gt; protocol &gt; src &gt; value.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;entt/meta/meta.hpp&gt;</code></li> <li><code>#include &lt;quite/value/value_registry.hpp&gt;</code></li> <li><code>#include \"quite/proto/client/value_converter.hpp\"</code></li> <li><code>#include \"quite/proto/types.pb.h\"</code></li> </ul>"},{"location":"quite/value_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace proto <p>The documentation for this class was generated from the following file <code>libs/protocol/src/value.hpp</code></p>"},{"location":"quite/value_8hpp_source/","title":"File value.hpp","text":"<p>File List &gt; libs &gt; protocol &gt; src &gt; value.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;entt/meta/meta.hpp&gt;\n#include &lt;quite/value/value_registry.hpp&gt;\n#include \"quite/proto/client/value_converter.hpp\"\n#include \"quite/proto/types.pb.h\"\n\nnamespace quite::proto\n{\nValue create_value(const ValueRegistry &amp;value_registry, const entt::meta_any &amp;type);\nentt::meta_any convert_value(const ValueRegistry &amp;value_registry, const IValueConverter &amp;converter, const Value &amp;value);\n} // namespace quite::proto\n</code></pre>"},{"location":"quite/dir_0600a918fa506c296d39916ce5da6191/","title":"Dir libs/protocol/tests","text":"<p>FileList &gt; libs &gt; protocol &gt; tests</p>"},{"location":"quite/dir_0600a918fa506c296d39916ce5da6191/#files","title":"Files","text":"Type Name file main.cpp file test_server.cpp <p>The documentation for this class was generated from the following file <code>libs/protocol/tests/</code></p>"},{"location":"quite/protocol_2tests_2main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; tests &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> </ul>"},{"location":"quite/protocol_2tests_2main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"quite/protocol_2tests_2main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/protocol_2tests_2main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/tests/main.cpp</code></p>"},{"location":"quite/protocol_2tests_2main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; tests &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;boost/ut.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n\nint main(int argc, char *argv[])\n{\n    quite::setup_logger();\n    return static_cast&lt;int&gt;(\n        boost::ut::cfg&lt;&gt;.run({.report_errors = true, .argc = argc, .argv = const_cast&lt;const char **&gt;(argv)}));\n}\n</code></pre>"},{"location":"quite/test__server_8cpp/","title":"File test_server.cpp","text":"<p>FileList &gt; libs &gt; protocol &gt; tests &gt; test_server.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;boost/ut.hpp&gt;</code></li> <li><code>#include &lt;quite/proto/probe/server.hpp&gt;</code></li> </ul>"},{"location":"quite/test__server_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name suite&lt;\"protocol server\"&gt; _   = <code>/* multi line expression */</code>"},{"location":"quite/test__server_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"quite/test__server_8cpp/#variable-_","title":"variable _","text":"<pre><code>suite&lt;\"protocol server\"&gt; _;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/protocol/tests/test_server.cpp</code></p>"},{"location":"quite/test__server_8cpp_source/","title":"File test_server.cpp","text":"<p>File List &gt; libs &gt; protocol &gt; tests &gt; test_server.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;thread&gt;\n#include &lt;boost/ut.hpp&gt;\n#include &lt;quite/proto/probe/server.hpp&gt;\nusing namespace boost::ut;\nusing namespace std::literals::string_view_literals;\n\nstatic suite&lt;\"protocol server\"&gt; _ = [] { // NOLINT\n    \"shutdown instant\"_test = [] {\n        // This test is to ensure that the server can be created and destroyed without issues.\n        for (int i = 0; i &lt; 1000; ++i)\n        {\n            quite::proto::Server server{\"unix:///tmp/grpc_probe.sock\", {}, {}, {}, {}};\n        }\n    };\n    \"shutdown delayed\"_test = [] {\n        quite::proto::Server server{\"unix:///tmp/grpc_probe.sock\", {}, {}, {}, {}};\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    };\n};\n</code></pre>"},{"location":"quite/dir_5dc041d31cf4c8a741744373481e730f/","title":"Dir libs/testing","text":"<p>FileList &gt; libs &gt; testing</p>"},{"location":"quite/dir_5dc041d31cf4c8a741744373481e730f/#directories","title":"Directories","text":"Type Name dir include dir src <p>The documentation for this class was generated from the following file <code>libs/testing/</code></p>"},{"location":"quite/dir_0e3ab90749f7b4be0e4eb22d010aec3d/","title":"Dir libs/testing/include","text":"<p>FileList &gt; include</p>"},{"location":"quite/dir_0e3ab90749f7b4be0e4eb22d010aec3d/#directories","title":"Directories","text":"Type Name dir quite <p>The documentation for this class was generated from the following file <code>libs/testing/include/</code></p>"},{"location":"quite/dir_4b2197acd3cfc200796c46ec50ed103f/","title":"Dir libs/testing/include/quite","text":"<p>FileList &gt; include &gt; quite</p>"},{"location":"quite/dir_4b2197acd3cfc200796c46ec50ed103f/#directories","title":"Directories","text":"Type Name dir test <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/</code></p>"},{"location":"quite/dir_e2259a6ae36431ad829e5c40f57eb4d8/","title":"Dir libs/testing/include/quite/test","text":"<p>FileList &gt; include &gt; quite &gt; test</p>"},{"location":"quite/dir_e2259a6ae36431ad829e5c40f57eb4d8/#files","title":"Files","text":"Type Name file exceptions.hpp file expect.hpp file probe.hpp file probe_manager.hpp file property.hpp file remote_object.hpp <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/</code></p>"},{"location":"quite/exceptions_8hpp/","title":"File exceptions.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; exceptions.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;quite/error.hpp&gt;</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> </ul>"},{"location":"quite/exceptions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test"},{"location":"quite/exceptions_8hpp/#classes","title":"Classes","text":"Type Name class RemoteException <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/exceptions.hpp</code></p>"},{"location":"quite/exceptions_8hpp_source/","title":"File exceptions.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; exceptions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;stdexcept&gt;\n#include &lt;quite/error.hpp&gt;\n#include \"quite/quite_test_export.hpp\"\n\nnamespace quite::test\n{\nclass QUITE_TEST_EXPORT RemoteException : public std::runtime_error\n{\n  public:\n    explicit RemoteException(const Error &amp;error);\n};\n} // namespace quite::test\n</code></pre>"},{"location":"quite/expect_8hpp/","title":"File expect.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; expect.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> <li><code>#include \"remote_object.hpp\"</code></li> </ul>"},{"location":"quite/expect_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test"},{"location":"quite/expect_8hpp/#classes","title":"Classes","text":"Type Name struct IExpectBuilder <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/expect.hpp</code></p>"},{"location":"quite/expect_8hpp_source/","title":"File expect.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; expect.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include \"quite/quite_test_export.hpp\"\n#include \"remote_object.hpp\"\n\nnamespace quite::test\n{\nstruct QUITE_TEST_EXPORT IExpectBuilder\n{\n    virtual ~IExpectBuilder() = default;\n    virtual bool to_have_screenshot(const std::string &amp;name) = 0;\n};\n\n[[nodiscard]] QUITE_TEST_EXPORT std::unique_ptr&lt;IExpectBuilder&gt; expect(RemoteObject remote_object);\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2include_2quite_2test_2probe_8hpp/","title":"File probe.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; probe.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;quite/client/probe_handle.hpp&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> <li><code>#include \"remote_object.hpp\"</code></li> </ul>"},{"location":"quite/testing_2include_2quite_2test_2probe_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test"},{"location":"quite/testing_2include_2quite_2test_2probe_8hpp/#classes","title":"Classes","text":"Type Name class Probe <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/probe.hpp</code></p>"},{"location":"quite/testing_2include_2quite_2test_2probe_8hpp_source/","title":"File probe.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; probe.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;quite/client/probe_handle.hpp&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include \"quite/quite_test_export.hpp\"\n#include \"remote_object.hpp\"\n\nnamespace quite\n{\nclass ObjectQuery;\n\nnamespace test\n{\nclass ProbeManager;\nclass QUITE_TEST_EXPORT Probe\n{\n  public:\n    QUITE_DISABLE_COPY(Probe);\n    Probe(Probe &amp;&amp;) noexcept;\n    Probe &amp;operator=(Probe &amp;&amp;) noexcept;\n    ~Probe();\n\n    RemoteObject find_object(ObjectQuery query);\n    RemoteObject try_find_object(ObjectQuery query, std::chrono::milliseconds timeout);\n    void wait_for_connected(std::chrono::seconds timeout);\n    void exit();\n\n  private:\n    friend ProbeManager;\n    explicit Probe(client::ProbeHandle handle);\n\n  private:\n    client::ProbeHandle handle_;\n};\n} // namespace test\n} // namespace quite\n</code></pre>"},{"location":"quite/testing_2include_2quite_2test_2probe__manager_8hpp/","title":"File probe_manager.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; probe_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;quite/disable_copy_move.hpp&gt;</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> </ul>"},{"location":"quite/testing_2include_2quite_2test_2probe__manager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client namespace manager namespace test"},{"location":"quite/testing_2include_2quite_2test_2probe__manager_8hpp/#classes","title":"Classes","text":"Type Name class ProbeManager <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/probe_manager.hpp</code></p>"},{"location":"quite/testing_2include_2quite_2test_2probe__manager_8hpp_source/","title":"File probe_manager.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; probe_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;quite/disable_copy_move.hpp&gt;\n#include \"quite/quite_test_export.hpp\"\n\nnamespace quite\n{\nnamespace client\n{\nclass ProbeManager;\n}\nnamespace manager\n{\nclass ProcessManager;\n}\n\nnamespace test\n{\nclass Probe;\nclass QUITE_TEST_EXPORT ProbeManager\n{\n  public:\n    QUITE_DISABLE_COPY(ProbeManager);\n\n    ProbeManager();\n    ProbeManager(ProbeManager &amp;&amp;) noexcept = default;\n    ProbeManager &amp;operator=(ProbeManager &amp;&amp;) noexcept = default;\n    ~ProbeManager();\n    quite::test::Probe launch_probe_application(std::string name,\n                                                const std::string &amp;path_to_application,\n                                                const std::vector&lt;std::string&gt; &amp;args = {});\n    quite::test::Probe connect_to_probe(std::string name);\n\n  private:\n    std::unique_ptr&lt;manager::ProcessManager&gt; local_;\n    std::unique_ptr&lt;client::ProbeManager&gt; probe_;\n};\n} // namespace test\n} // namespace quite\n</code></pre>"},{"location":"quite/testing_2include_2quite_2test_2property_8hpp/","title":"File property.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; property.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> </ul>"},{"location":"quite/testing_2include_2quite_2test_2property_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client namespace test"},{"location":"quite/testing_2include_2quite_2test_2property_8hpp/#classes","title":"Classes","text":"Type Name class Property <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/property.hpp</code></p>"},{"location":"quite/testing_2include_2quite_2test_2property_8hpp_source/","title":"File property.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; property.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;variant&gt;\n#include \"quite/quite_test_export.hpp\"\n\nnamespace quite::client\n{\nclass Property;\n}\n\nnamespace quite::test\n{\nclass RemoteObject;\n\nclass QUITE_TEST_EXPORT Property final\n{\n  public:\n    explicit Property(std::shared_ptr&lt;client::Property&gt; property);\n\n    using Value = std::variant&lt;bool, std::uint64_t, std::int64_t, double, std::string, RemoteObject&gt;;\n    Property::Value fetch();\n    Property::Value value() const;\n    Property::Value wait_for_value(Property::Value target_value, std::chrono::milliseconds timeout);\n\n    void write(Property::Value value);\n\n  private:\n    std::shared_ptr&lt;client::Property&gt; property_;\n};\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2include_2quite_2test_2remote__object_8hpp/","title":"File remote_object.hpp","text":"<p>FileList &gt; include &gt; quite &gt; test &gt; remote_object.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;quite/image.hpp&gt;</code></li> <li><code>#include \"property.hpp\"</code></li> <li><code>#include \"quite/quite_test_export.hpp\"</code></li> </ul>"},{"location":"quite/testing_2include_2quite_2test_2remote__object_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace client namespace test"},{"location":"quite/testing_2include_2quite_2test_2remote__object_8hpp/#classes","title":"Classes","text":"Type Name class RemoteObject <p>The documentation for this class was generated from the following file <code>libs/testing/include/quite/test/remote_object.hpp</code></p>"},{"location":"quite/testing_2include_2quite_2test_2remote__object_8hpp_source/","title":"File remote_object.hpp","text":"<p>File List &gt; include &gt; quite &gt; test &gt; remote_object.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;memory&gt;\n#include &lt;quite/image.hpp&gt;\n#include \"property.hpp\"\n#include \"quite/quite_test_export.hpp\"\n\nnamespace quite\n{\nnamespace client\n{\nclass RemoteObject;\n}\n\nnamespace test\n{\nclass QUITE_TEST_EXPORT RemoteObject\n{\n  public:\n    explicit RemoteObject(std::shared_ptr&lt;client::RemoteObject&gt; object);\n\n    void mouse_action();\n    void invoke_method(std::string method_name);\n    [[nodiscard]] Image take_snapshot();\n    [[nodiscard]] Property property(std::string name);\n\n    [[nodiscard]] bool operator==(const RemoteObject &amp;rhs) const;\n\n    std::shared_ptr&lt;client::RemoteObject&gt; underlying_object();\n\n  private:\n    std::shared_ptr&lt;client::RemoteObject&gt; object_;\n};\n} // namespace test\n} // namespace quite\n</code></pre>"},{"location":"quite/dir_398cbba213cb2cd7b6578e890cc57257/","title":"Dir libs/testing/src","text":"<p>FileList &gt; libs &gt; testing &gt; src</p>"},{"location":"quite/dir_398cbba213cb2cd7b6578e890cc57257/#files","title":"Files","text":"Type Name file exceptions.cpp file expect.cpp file expect_screenshot.cpp file expect_screenshot.hpp file probe.cpp file probe_manager.cpp file property.cpp file remote_object.cpp file throw_unexpected.hpp <p>The documentation for this class was generated from the following file <code>libs/testing/src/</code></p>"},{"location":"quite/exceptions_8cpp/","title":"File exceptions.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; exceptions.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/exceptions.hpp\"</code></li> </ul>"},{"location":"quite/exceptions_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/exceptions.cpp</code></p>"},{"location":"quite/exceptions_8cpp_source/","title":"File exceptions.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; exceptions.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/exceptions.hpp\"\nnamespace quite::test\n{\nRemoteException::RemoteException(const Error &amp;error)\n    : std::runtime_error{error.message}\n{}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/expect_8cpp/","title":"File expect.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; expect.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/expect.hpp\"</code></li> <li><code>#include \"expect_screenshot.hpp\"</code></li> </ul>"},{"location":"quite/expect_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test"},{"location":"quite/expect_8cpp/#classes","title":"Classes","text":"Type Name class RemoteObjectExpect <p>The documentation for this class was generated from the following file <code>libs/testing/src/expect.cpp</code></p>"},{"location":"quite/expect_8cpp_source/","title":"File expect.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; expect.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/expect.hpp\"\n#include \"expect_screenshot.hpp\"\nnamespace quite::test\n{\n\nclass RemoteObjectExpect : public IExpectBuilder\n{\n  public:\n    RemoteObjectExpect(RemoteObject remote_object)\n        : obj_{remote_object}\n    {}\n\n    bool to_have_screenshot(const std::string &amp;name) override\n    {\n        if (has_screenshot_expect(name))\n        {\n            return verify_screenshot_expect(obj_, name);\n        }\n        create_screenshot_expect(obj_, name);\n        return true;\n    };\n\n  private:\n    RemoteObject obj_;\n};\n\nstd::unique_ptr&lt;IExpectBuilder&gt; expect(RemoteObject remote_object)\n{\n    return std::make_unique&lt;RemoteObjectExpect&gt;(remote_object);\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/expect__screenshot_8cpp/","title":"File expect_screenshot.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; expect_screenshot.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"expect_screenshot.hpp\"</code></li> <li><code>#include &lt;quite/client/testing/verification_point.hpp&gt;</code></li> <li><code>#include \"throw_unexpected.hpp\"</code></li> </ul>"},{"location":"quite/expect__screenshot_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/expect_screenshot.cpp</code></p>"},{"location":"quite/expect__screenshot_8cpp_source/","title":"File expect_screenshot.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; expect_screenshot.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"expect_screenshot.hpp\"\n#include &lt;quite/client/testing/verification_point.hpp&gt;\n#include \"throw_unexpected.hpp\"\n\nnamespace quite::test\n{\nbool has_screenshot_expect(const std::string &amp;name)\n{\n    return testing::has_verification_point(name);\n}\n\nvoid create_screenshot_expect(RemoteObject obj, const std::string &amp;name)\n{\n    const auto [success] =\n        stdexec::sync_wait(testing::create_verification_point(obj.underlying_object(), name)).value();\n    throw_unexpected(success);\n}\n\nbool verify_screenshot_expect(RemoteObject obj, const std::string &amp;name)\n{\n    const auto [success] =\n        stdexec::sync_wait(testing::verify_verification_point(obj.underlying_object(), name)).value();\n    throw_unexpected(success);\n    return success.value();\n}\n\n} // namespace quite::test\n</code></pre>"},{"location":"quite/expect__screenshot_8hpp/","title":"File expect_screenshot.hpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; expect_screenshot.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/remote_object.hpp\"</code></li> </ul>"},{"location":"quite/expect__screenshot_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/expect_screenshot.hpp</code></p>"},{"location":"quite/expect__screenshot_8hpp_source/","title":"File expect_screenshot.hpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; expect_screenshot.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"quite/test/remote_object.hpp\"\nnamespace quite::test\n{\n\nbool has_screenshot_expect(const std::string &amp;name);\nvoid create_screenshot_expect(RemoteObject obj, const std::string &amp;name);\n[[nodiscard]] bool verify_screenshot_expect(RemoteObject obj, const std::string &amp;name);\n\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2src_2probe_8cpp/","title":"File probe.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; probe.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/probe.hpp\"</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;asioexec/use_sender.hpp&gt;</code></li> <li><code>#include &lt;exec/repeat_effect_until.hpp&gt;</code></li> <li><code>#include &lt;exec/task.hpp&gt;</code></li> <li><code>#include &lt;exec/when_any.hpp&gt;</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/client/quite.hpp&gt;</code></li> <li><code>#include &lt;quite/client/remote_object.hpp&gt;</code></li> <li><code>#include &lt;quite/value/object_query.hpp&gt;</code></li> <li><code>#include \"quite/client/probe.hpp\"</code></li> <li><code>#include \"throw_unexpected.hpp\"</code></li> </ul>"},{"location":"quite/testing_2src_2probe_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/probe.cpp</code></p>"},{"location":"quite/testing_2src_2probe_8cpp_source/","title":"File probe.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; probe.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/probe.hpp\"\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;asioexec/use_sender.hpp&gt;\n#include &lt;exec/repeat_effect_until.hpp&gt;\n#include &lt;exec/task.hpp&gt;\n#include &lt;exec/when_any.hpp&gt;\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/client/quite.hpp&gt;\n#include &lt;quite/client/remote_object.hpp&gt;\n#include &lt;quite/value/object_query.hpp&gt;\n#include \"quite/client/probe.hpp\"\n#include \"throw_unexpected.hpp\"\n\nnamespace quite::test\n{\nProbe::~Probe() = default;\n\nProbe::Probe(Probe &amp;&amp;) noexcept = default;\n\nProbe &amp;Probe::operator=(Probe &amp;&amp;) noexcept = default;\n\nProbe::Probe(client::ProbeHandle handle)\n    : handle_{std::move(handle)}\n{}\n\nvoid Probe::wait_for_connected(std::chrono::seconds timeout)\n{\n    const auto [started_result] = stdexec::sync_wait(handle_-&gt;wait_for_started(timeout)).value();\n    throw_unexpected(started_result);\n}\n\nRemoteObject Probe::find_object(ObjectQuery query)\n{\n    auto [obj] = stdexec::sync_wait(handle_-&gt;find_object(std::move(query))).value();\n    throw_unexpected(obj);\n    return RemoteObject{std::move(*obj)};\n}\n\nRemoteObject Probe::try_find_object(ObjectQuery query, std::chrono::milliseconds timeout)\n{\n    Result&lt;client::RemoteObjectPtr&gt; found_object;\n    stdexec::sender auto find_obj_snd =\n        stdexec::when_all(stdexec::just(handle_), stdexec::just(std::move(query))) |\n        stdexec::continues_on(client::asio_context().get_scheduler()) |\n        stdexec::let_value([](auto handle, auto &amp;&amp;query) { return handle-&gt;find_object(query); }) |\n        stdexec::then([&amp;found_object](auto &amp;&amp;result) {\n            found_object = std::forward&lt;decltype(result)&gt;(result);\n            return found_object.has_value();\n        }) |\n        exec::repeat_effect_until();\n\n    boost::asio::steady_timer timer{get_executor(), timeout};\n    stdexec::sender auto timeout_snd =\n        timer.async_wait(asioexec::use_sender) | stdexec::then([&amp;found_object](auto &amp;&amp;...) {\n            found_object = quite::make_error_result(ErrorCode::deadline_exceeded, \"Could not find object in time.\");\n        });\n    stdexec::sender auto wait_snd = exec::when_any(std::move(find_obj_snd), std::move(timeout_snd));\n    stdexec::sync_wait(std::move(wait_snd));\n    throw_unexpected(found_object);\n    return RemoteObject{std::move(*found_object)};\n}\n\nvoid Probe::exit()\n{\n    stdexec::sync_wait(handle_-&gt;exit());\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2src_2probe__manager_8cpp/","title":"File probe_manager.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; probe_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/probe_manager.hpp\"</code></li> <li><code>#include &lt;quite/asio_context.hpp&gt;</code></li> <li><code>#include &lt;quite/client/probe_manager.hpp&gt;</code></li> <li><code>#include &lt;quite/manager/process_manager.hpp&gt;</code></li> <li><code>#include &lt;quite/setup_logger.hpp&gt;</code></li> <li><code>#include \"quite/test/probe.hpp\"</code></li> </ul>"},{"location":"quite/testing_2src_2probe__manager_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/probe_manager.cpp</code></p>"},{"location":"quite/testing_2src_2probe__manager_8cpp_source/","title":"File probe_manager.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; probe_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/probe_manager.hpp\"\n#include &lt;quite/asio_context.hpp&gt;\n#include &lt;quite/client/probe_manager.hpp&gt;\n#include &lt;quite/manager/process_manager.hpp&gt;\n#include &lt;quite/setup_logger.hpp&gt;\n#include \"quite/test/probe.hpp\"\n\nnamespace quite::test\n{\nProbeManager::ProbeManager()\n    : local_{std::make_unique&lt;manager::ProcessManager&gt;(quite::get_executor())}\n    , probe_{std::make_unique&lt;client::ProbeManager&gt;()}\n{}\n\nProbeManager::~ProbeManager() = default;\n\nProbe ProbeManager::launch_probe_application(std::string name,\n                                             const std::string &amp;path_to_application,\n                                             const std::vector&lt;std::string&gt; &amp;args)\n{\n    auto [process] =\n        stdexec::sync_wait(local_-&gt;launch_application({std::move(name)}, path_to_application, args)).value();\n    auto probe_result = process.and_then([&amp;](auto &amp;&amp;handle) -&gt; Result&lt;Probe&gt; {\n        auto probe_handle = probe_-&gt;connect(std::forward&lt;decltype(handle)&gt;(handle), \"unix:///tmp/grpc_probe.sock\");\n        return Probe{std::move(probe_handle)};\n    });\n    if (probe_result.has_value())\n    {\n        return std::move(probe_result.value());\n    }\n    return Probe{probe_-&gt;connect(local_-&gt;noop_process(), \"unknown\")};\n}\n\nquite::test::Probe ProbeManager::connect_to_probe(std::string name)\n{\n    auto probe_handle = probe_-&gt;connect(local_-&gt;noop_process(), \"unix:///tmp/grpc_probe.sock\");\n    return Probe{std::move(probe_handle)};\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2src_2property_8cpp/","title":"File property.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; property.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/property.hpp\"</code></li> <li><code>#include &lt;boost/asio/steady_timer.hpp&gt;</code></li> <li><code>#include &lt;asioexec/use_sender.hpp&gt;</code></li> <li><code>#include &lt;exec/repeat_effect_until.hpp&gt;</code></li> <li><code>#include &lt;exec/when_any.hpp&gt;</code></li> <li><code>#include &lt;quite/client/property.hpp&gt;</code></li> <li><code>#include &lt;quite/client/quite.hpp&gt;</code></li> <li><code>#include &lt;quite/logger.hpp&gt;</code></li> <li><code>#include &lt;quite/meta_any_formatter.hpp&gt;</code></li> <li><code>#include \"quite/asio_context.hpp\"</code></li> <li><code>#include \"quite/client/remote_object.hpp\"</code></li> <li><code>#include \"quite/test/remote_object.hpp\"</code></li> <li><code>#include \"quite/value/object_id.hpp\"</code></li> <li><code>#include \"throw_unexpected.hpp\"</code></li> </ul>"},{"location":"quite/testing_2src_2property_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test"},{"location":"quite/testing_2src_2property_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOGGER (test_property)"},{"location":"quite/testing_2src_2property_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"quite/testing_2src_2property_8cpp/#function-define_logger","title":"function DEFINE_LOGGER","text":"<pre><code>DEFINE_LOGGER (\n    test_property\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libs/testing/src/property.cpp</code></p>"},{"location":"quite/testing_2src_2property_8cpp_source/","title":"File property.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; property.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/property.hpp\"\n#include &lt;boost/asio/steady_timer.hpp&gt;\n#include &lt;asioexec/use_sender.hpp&gt;\n#include &lt;exec/repeat_effect_until.hpp&gt;\n#include &lt;exec/when_any.hpp&gt;\n#include &lt;quite/client/property.hpp&gt;\n#include &lt;quite/client/quite.hpp&gt;\n#include &lt;quite/logger.hpp&gt;\n#include &lt;quite/meta_any_formatter.hpp&gt;\n#include \"quite/asio_context.hpp\"\n#include \"quite/client/remote_object.hpp\"\n#include \"quite/test/remote_object.hpp\"\n#include \"quite/value/object_id.hpp\"\n#include \"throw_unexpected.hpp\"\n\nDEFINE_LOGGER(test_property);\n\nnamespace quite::test\n{\nnamespace\n{\ntemplate &lt;class... Ts&gt;\nstruct overloads : Ts...\n{\n    using Ts::operator()...;\n};\n\nProperty::Value convert_any(const entt::meta_any &amp;value)\n{\n    LOG_INFO(test_property(), \"CONVERT ANY:{}\", fmt::format(\"{}\", value));\n    const auto type = value.type();\n\n    if (type.is_arithmetic())\n    {\n        if (type.info() == entt::type_id&lt;bool&gt;())\n        {\n            return value.cast&lt;bool&gt;();\n        }\n        if (type.is_integral())\n        {\n            if (type.is_signed())\n            {\n                return value.allow_cast&lt;std::int64_t&gt;().cast&lt;int64_t&gt;();\n            }\n            return value.allow_cast&lt;std::uint64_t&gt;().cast&lt;uint64_t&gt;();\n        }\n        return value.allow_cast&lt;double&gt;().cast&lt;double&gt;();\n    }\n\n    if (type.is_pointer_like())\n    {\n        if (type.info() == entt::type_id&lt;client::RemoteObjectPtr&gt;())\n        {\n            return RemoteObject{value.cast&lt;client::RemoteObjectPtr&gt;()};\n        }\n    }\n\n    if (type.is_class())\n    {\n        if (type.info() == entt::type_id&lt;std::string&gt;())\n        {\n            return value.cast&lt;std::string&gt;();\n        }\n    }\n\n    return {};\n}\n\nentt::meta_any convert_any(Property::Value value)\n{\n    return std::visit(overloads{[](bool value) { return entt::meta_any{value}; },\n                                [](std::uint64_t value) { return entt::meta_any{value}; },\n                                [](std::int64_t value) { return entt::meta_any{value}; },\n                                [](double value) { return entt::meta_any{value}; },\n                                [](std::string value) { return entt::meta_any{std::move(value)}; },\n                                [](RemoteObject value) {\n                                    return entt::meta_any{\n                                        ObjectReference{.object_id = value.underlying_object()-&gt;id()}};\n                                }},\n                      std::move(value));\n}\n} // namespace\nProperty::Property(std::shared_ptr&lt;client::Property&gt; property)\n    : property_{std::move(property)}\n{}\n\nProperty::Value Property::fetch()\n{\n    const auto [result] = stdexec::sync_wait(property_-&gt;read()).value();\n    throw_unexpected(result);\n    return convert_any(result.value());\n}\n\nProperty::Value Property::value() const\n{\n    auto &amp;&amp;value = property_-&gt;value();\n    throw_unexpected(value);\n    return convert_any(*value);\n}\n\nvoid Property::write(Property::Value value)\n{\n    const auto [write_result] = stdexec::sync_wait(property_-&gt;write(convert_any(std::move(value)))).value();\n    throw_unexpected(write_result);\n}\n\nProperty::Value Property::wait_for_value(Property::Value target_value, std::chrono::milliseconds timeout)\n{\n    Property::Value return_value{};\n\n    boost::asio::steady_timer timeout_timer{get_executor(), timeout};\n\n    stdexec::sender auto fetch_value_snd =\n        stdexec::schedule(client::asio_context().get_scheduler()) |\n        stdexec::let_value([this]() { return property_-&gt;read(); }) |\n        stdexec::then([&amp;return_value, &amp;target_value](auto &amp;&amp;possible_value) -&gt; bool {\n            if (not possible_value.has_value())\n            {\n                return false;\n            }\n            return_value = convert_any(possible_value.value());\n            return return_value == target_value;\n        }) |\n        stdexec::let_value([](bool finished) -&gt; exec::task&lt;bool&gt; {\n            if (not finished)\n            {\n                boost::asio::steady_timer retry_timer{get_executor(), std::chrono::milliseconds{100}};\n                co_await retry_timer.async_wait(asioexec::use_sender);\n            }\n            co_return finished;\n        }) |\n        exec::repeat_effect_until();\n\n    stdexec::sender auto timeout_snd = timeout_timer.async_wait(asioexec::use_sender);\n    stdexec::sender auto wait_snd = exec::when_any(std::move(fetch_value_snd), std::move(timeout_snd));\n    stdexec::sync_wait(std::move(wait_snd));\n\n    return return_value;\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/testing_2src_2remote__object_8cpp/","title":"File remote_object.cpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; remote_object.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"quite/test/remote_object.hpp\"</code></li> <li><code>#include &lt;quite/client/remote_object.hpp&gt;</code></li> <li><code>#include \"quite/test/property.hpp\"</code></li> <li><code>#include \"throw_unexpected.hpp\"</code></li> </ul>"},{"location":"quite/testing_2src_2remote__object_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/remote_object.cpp</code></p>"},{"location":"quite/testing_2src_2remote__object_8cpp_source/","title":"File remote_object.cpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; remote_object.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"quite/test/remote_object.hpp\"\n#include &lt;quite/client/remote_object.hpp&gt;\n#include \"quite/test/property.hpp\"\n#include \"throw_unexpected.hpp\"\n\nnamespace quite::test\n{\n\nRemoteObject::RemoteObject(std::shared_ptr&lt;client::RemoteObject&gt; object)\n    : object_{std::move(object)}\n{}\n\nvoid RemoteObject::mouse_action()\n{\n    const auto [action_result] = stdexec::sync_wait(object_-&gt;mouse_action()).value();\n    throw_unexpected(action_result);\n}\n\nImage RemoteObject::take_snapshot()\n{\n    auto [snapshot] = stdexec::sync_wait(object_-&gt;take_snapshot()).value();\n    throw_unexpected(snapshot);\n    return std::move(snapshot.value());\n}\n\nvoid RemoteObject::invoke_method(std::string method_name)\n{\n    const auto [invoke_result] = stdexec::sync_wait(object_-&gt;invoke_method(std::move(method_name))).value();\n    throw_unexpected(invoke_result);\n}\n\nProperty RemoteObject::property(std::string name)\n{\n    auto [result] = stdexec::sync_wait(object_-&gt;property(std::move(name))).value();\n    throw_unexpected(result);\n    return Property{std::move(result.value())};\n}\n\nstd::shared_ptr&lt;client::RemoteObject&gt; RemoteObject::underlying_object()\n{\n    return object_;\n}\n\nbool RemoteObject::operator==(const RemoteObject &amp;rhs) const\n{\n    return this-&gt;object_ == rhs.object_;\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/throw__unexpected_8hpp/","title":"File throw_unexpected.hpp","text":"<p>FileList &gt; libs &gt; testing &gt; src &gt; throw_unexpected.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;quite/result.hpp&gt;</code></li> <li><code>#include \"quite/test/exceptions.hpp\"</code></li> </ul>"},{"location":"quite/throw__unexpected_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace quite namespace test <p>The documentation for this class was generated from the following file <code>libs/testing/src/throw_unexpected.hpp</code></p>"},{"location":"quite/throw__unexpected_8hpp_source/","title":"File throw_unexpected.hpp","text":"<p>File List &gt; libs &gt; testing &gt; src &gt; throw_unexpected.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;quite/result.hpp&gt;\n#include \"quite/test/exceptions.hpp\"\nnamespace quite::test\n{\ntemplate &lt;typename T&gt;\nconstexpr void throw_unexpected(const Result&lt;T&gt; &amp;result)\n{\n    if (not result.has_value())\n    {\n        throw RemoteException{result.error()};\n    }\n}\n} // namespace quite::test\n</code></pre>"},{"location":"quite/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace anonymous namespace{libs/core/src/meta/meta_types.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/object_tracker.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/main.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/test_method_invoker.cpp} </li> <li>namespace anonymous namespace{libs/probeqt/tests/test_property_collector.cpp} </li> <li>namespace anonymous namespace{libs/protocol/src/probe/rpc_mouse_injection.cpp} </li> <li>namespace ut </li> <li>namespace entt </li> <li>namespace literals </li> <li>namespace formatter fmt </li> <li>namespace quite <ul> <li>namespace client </li> <li>namespace core </li> <li>namespace manager </li> <li>namespace meta </li> <li>namespace probe </li> <li>namespace proto </li> <li>namespace test </li> <li>namespace testing </li> </ul> </li> <li>namespace quite </li> <li>namespace client </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace probe </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace proto </li> <li>namespace test </li> <li>namespace std </li> <li>namespace string_view_literals </li> </ul>"},{"location":"quite/classes/","title":"Class Index","text":""},{"location":"quite/classes/#b","title":"b","text":"<ul> <li>BasicProbe (quite::client)</li> <li>BasicProcessManager (quite::manager)</li> </ul>"},{"location":"quite/classes/#c","title":"c","text":"<ul> <li>Client (quite::proto)</li> <li>Context (quite)</li> </ul>"},{"location":"quite/classes/#d","title":"d","text":"<ul> <li>DefaultEnv (quite::QThreadScheduler)</li> <li>DefaultEnv</li> </ul>"},{"location":"quite/classes/#e","title":"e","text":"<ul> <li>EnumType (quite::meta)</li> <li>Error (quite)</li> </ul>"},{"location":"quite/classes/#f","title":"f","text":"<ul> <li>FindObjectRpcHandler (quite::proto)</li> <li>fmt</li> <li>formatter&lt; entt::meta_any &gt; (fmt)</li> </ul>"},{"location":"quite/classes/#g","title":"g","text":"<ul> <li>GenericClass (quite)</li> <li>GetMetaObjectRpcHandler (quite::proto)</li> <li>GetObjectPropertiesRpcHandler (quite::proto)</li> <li>GetViewsRpcHandler (quite::proto)</li> <li>GrpcManager (quite::proto)</li> <li>GrpcProbe (quite::client)</li> <li>GrpcProperty (quite::client)</li> <li>GrpcRemoteObject (quite::client)</li> <li>GrpcServer (quite)</li> <li>GrpcValueConverter (quite::client)</li> </ul>"},{"location":"quite/classes/#i","title":"i","text":"<ul> <li>IExpectBuilder (quite::test)</li> <li>Image (quite)</li> <li>ImageCompareResult (quite)</li> <li>ImageData (quite::proto::IProbeHandler)</li> <li>ImageView (quite)</li> <li>IMouseInjector (quite::core)</li> <li>Impl (quite::Image)</li> <li>Impl (quite::proto::Server)</li> <li>Impl (quite::client::ProbeManager)</li> <li>Impl (quite::manager::ProcessManager)</li> <li>Impl (quite::proto::Client)</li> <li>InvokeMethodRpcHandler (quite::proto)</li> <li>IProbeHandler (quite::proto)</li> <li>IProbeService (quite::proto)</li> <li>IValueConverter (quite::proto)</li> </ul>"},{"location":"quite/classes/#l","title":"l","text":"<ul> <li>ListType (quite::meta)</li> </ul>"},{"location":"quite/classes/#m","title":"m","text":"<ul> <li>MapType (quite::meta)</li> <li>meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; (entt)</li> <li>meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; (entt)</li> <li>meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; (entt)</li> <li>MetaAdapter (quite::probe)</li> <li>MetaRegistry (quite::meta)</li> <li>MetaRegistryImpl (quite::proto)</li> <li>Method (quite::meta)</li> <li>MethodInvoker (quite::probe)</li> <li>MouseAction (quite::core)</li> <li>MouseActionRpcHandler (quite::proto)</li> <li>MouseInjector (quite::probe)</li> <li>MouseInjectorImpl (quite::proto)</li> <li>MyCustomClass</li> </ul>"},{"location":"quite/classes/#n","title":"n","text":"<ul> <li>NoopProcess (quite::manager)</li> </ul>"},{"location":"quite/classes/#o","title":"o","text":"<ul> <li>ObjectMeta (quite)</li> <li>ObjectQuery (quite)</li> <li>ObjectQueryBuilder (quite)</li> <li>ObjectReference (quite)</li> <li>ObjectTracker (quite::probe)</li> <li>ObjectType (quite::meta)</li> </ul>"},{"location":"quite/classes/#p","title":"p","text":"<ul> <li>PixelCompareOptions (quite)</li> <li>Probe (quite::client)</li> <li>Probe (quite::test)</li> <li>ProbeClient (quite::proto)</li> <li>ProbeClientImpl (quite::proto)</li> <li>ProbeContext (quite::probe)</li> <li>ProbeHandle (quite::client)</li> <li>ProbeManager (quite::client)</li> <li>ProbeManager (quite::test)</li> <li>ProbeServiceImpl (quite::proto)</li> <li>ProbeValueConverter (quite::proto)</li> <li>Process (quite::manager)</li> <li>ProcessHandle (quite::manager)</li> <li>ProcessId (quite::manager)</li> <li>ProcessImpl (quite::manager)</li> <li>ProcessManager (quite::manager)</li> <li>ProcessManagerClient (quite::manager)</li> <li>Property (quite::client)</li> <li>Property (quite::test)</li> <li>Property (quite::meta)</li> <li>ProtocolVisitor (quite::proto)</li> </ul>"},{"location":"quite/classes/#q","title":"q","text":"<ul> <li>QObjectOperationState (quite)</li> <li>QObjectSender (quite)</li> <li>QThreadOperationState (quite)</li> <li>QThreadScheduler (quite)</li> <li>QThreadSender (quite::QThreadScheduler)</li> <li>QtMetaRegistry (quite::probe)</li> <li>QtProbeHandler (quite::probe)</li> </ul>"},{"location":"quite/classes/#r","title":"r","text":"<ul> <li>RemoteException (quite::test)</li> <li>RemoteObject (quite::client)</li> <li>RemoteObject (quite::test)</li> <li>RemoteObjectExpect (quite::test)</li> <li>RemoteProcessManager (quite::manager)</li> </ul>"},{"location":"quite/classes/#s","title":"s","text":"<ul> <li>Server (quite::manager)</li> <li>Server (quite::proto)</li> <li>ServiceHandle (quite)</li> <li>SetObjectPropertyRpcHandler (quite::proto)</li> <li>SnapshotRpcHandler (quite::proto)</li> <li>StopCallback</li> </ul>"},{"location":"quite/classes/#v","title":"v","text":"<ul> <li>ValueRegistry (quite)</li> <li>Vector2 (quite)</li> </ul>"},{"location":"quite/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class quite::Context </li> <li>class quite::Image </li> <li>class quite::Image::Impl </li> <li>class quite::ObjectQueryBuilder </li> <li>class quite::QObjectOperationState </li> <li>class quite::QObjectSender </li> <li>class quite::QThreadOperationState </li> <li>class quite::QThreadScheduler </li> <li>class quite::QThreadScheduler::QThreadSender </li> <li>class quite::ServiceHandle A lightweight handle for accessing shared service instances. </li> <li>class quite::ValueRegistry </li> <li>class quite::client::Probe <ul> <li>class quite::client::BasicProbe <ul> <li>class quite::client::GrpcProbe </li> </ul> </li> </ul> </li> <li>class quite::client::Property <ul> <li>class quite::client::GrpcProperty </li> </ul> </li> <li>class quite::client::RemoteObject <ul> <li>class quite::client::GrpcRemoteObject </li> </ul> </li> <li>class quite::proto::IValueConverter <ul> <li>class quite::client::GrpcValueConverter </li> <li>class quite::proto::ProbeValueConverter </li> </ul> </li> <li>class quite::client::ProbeHandle </li> <li>class quite::client::ProbeManager </li> <li>class quite::core::IMouseInjector <ul> <li>class quite::probe::MouseInjector </li> <li>class quite::proto::MouseInjectorImpl </li> </ul> </li> <li>class quite::manager::BasicProcessManager <ul> <li>class quite::manager::ProcessManager </li> <li>class quite::manager::RemoteProcessManager <ul> <li>class quite::manager::ProcessManagerClient </li> </ul> </li> </ul> </li> <li>class quite::manager::Process <ul> <li>class quite::manager::NoopProcess </li> <li>class quite::manager::ProcessImpl </li> </ul> </li> <li>class quite::manager::ProcessHandle </li> <li>class quite::manager::Server </li> <li>class quite::meta::MetaRegistry <ul> <li>class quite::probe::QtMetaRegistry </li> <li>class quite::proto::MetaRegistryImpl </li> </ul> </li> <li>class quite::probe::MetaAdapter </li> <li>class quite::probe::MethodInvoker </li> <li>class quite::probe::ProbeContext </li> <li>class quite::proto::IProbeHandler <ul> <li>class quite::probe::QtProbeHandler </li> </ul> </li> <li>class quite::proto::Client </li> <li>class quite::proto::GrpcManager </li> <li>class quite::proto::IProbeService <ul> <li>class quite::proto::ProbeServiceImpl </li> </ul> </li> <li>class quite::proto::ProbeClient <ul> <li>class quite::proto::ProbeClientImpl </li> </ul> </li> <li>class quite::proto::Server </li> <li>class quite::proto::Server::Impl </li> <li>class quite::test::Probe </li> <li>class quite::test::ProbeManager </li> <li>class quite::test::Property </li> <li>class quite::test::RemoteObject </li> <li>struct quite::test::IExpectBuilder <ul> <li>class quite::test::RemoteObjectExpect </li> </ul> </li> <li>struct quite::Error </li> <li>struct quite::GenericClass </li> <li>struct quite::GrpcServer </li> <li>struct quite::ImageCompareResult </li> <li>struct quite::ImageView </li> <li>struct quite::ObjectMeta </li> <li>struct quite::ObjectQuery </li> <li>struct quite::ObjectReference </li> <li>struct quite::PixelCompareOptions </li> <li>struct quite::QThreadScheduler::DefaultEnv </li> <li>struct quite::Vector2 </li> <li>struct quite::client::ProbeManager::Impl </li> <li>struct quite::core::MouseAction </li> <li>struct quite::manager::ProcessId </li> <li>struct quite::manager::ProcessManager::Impl </li> <li>struct quite::meta::EnumType </li> <li>struct quite::meta::ListType </li> <li>struct quite::meta::MapType </li> <li>struct quite::meta::Method </li> <li>struct quite::meta::ObjectType </li> <li>struct quite::meta::Property </li> <li>struct quite::proto::Client::Impl </li> <li>struct quite::proto::FindObjectRpcHandler </li> <li>struct quite::proto::GetMetaObjectRpcHandler </li> <li>struct quite::proto::GetObjectPropertiesRpcHandler </li> <li>struct quite::proto::GetViewsRpcHandler </li> <li>struct quite::proto::IProbeHandler::ImageData </li> <li>struct quite::proto::InvokeMethodRpcHandler </li> <li>struct quite::proto::MouseActionRpcHandler </li> <li>struct quite::proto::ProtocolVisitor </li> <li>struct quite::proto::SetObjectPropertyRpcHandler </li> <li>struct quite::proto::SnapshotRpcHandler </li> <li>struct quite::QObjectOperationState::StopCallback </li> <li>struct quite::QObjectSender::DefaultEnv </li> <li>class QObject <ul> <li>class MyCustomClass </li> <li>class quite::probe::ObjectTracker </li> </ul> </li> <li>class std::enable_shared_from_this&lt; GrpcRemoteObject &gt; <ul> <li>class quite::client::GrpcRemoteObject </li> </ul> </li> <li>class std::runtime_error <ul> <li>class quite::test::RemoteException </li> </ul> </li> <li>class basic_meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; <ul> <li>struct entt::meta_associative_container_traits&lt; QHash&lt; Args... &gt; &gt; </li> </ul> </li> <li>class basic_meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; <ul> <li>struct entt::meta_associative_container_traits&lt; QMap&lt; Args... &gt; &gt; </li> </ul> </li> <li>class basic_meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; <ul> <li>struct entt::meta_sequence_container_traits&lt; QList&lt; Args... &gt; &gt; </li> </ul> </li> <li>class formatter&lt; quite::ErrorCode &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::Error &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::Property &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::Method &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::ObjectType &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::MapType &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::ListType &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::EnumType &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::PrimitiveType &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::meta::Type &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class formatter&lt; quite::ObjectQuery &gt; fmt::formatter <ul> <li>struct fmt </li> </ul> </li> <li>class fmt::formatter&lt; std::string_view &gt; <ul> <li>struct fmt::formatter&lt; entt::meta_any &gt; </li> </ul> </li> </ul>"},{"location":"quite/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"quite/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"quite/class_members/","title":"Class Members","text":""},{"location":"quite/class_members/#a","title":"a","text":"<ul> <li>asio_context (quite::Context)</li> <li>alpha (quite::PixelCompareOptions)</li> <li>anti_aliased_color (quite::PixelCompareOptions)</li> <li>application (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>async_wait_exit (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>applications_ (quite::manager::ProcessManager::Impl)</li> <li>add_object (quite::probe::ObjectTracker)</li> </ul>"},{"location":"quite/class_members/#b","title":"b","text":"<ul> <li>backend_client (quite::Context)</li> <li>BasicProbe (quite::client::BasicProbe)</li> <li>button (quite::core::MouseAction)</li> <li>builder_ (quite::proto::Server::Impl)</li> </ul>"},{"location":"quite/class_members/#c","title":"c","text":"<ul> <li>Context (quite::Context)</li> <li>client_ (quite::Context, quite::client::GrpcProbe, quite::client::GrpcRemoteObject, quite::client::GrpcValueConverter)</li> <li>code (quite::Error)</li> <li>channels_ (quite::Image::Impl)</li> <li>channels (quite::ImageView)</li> <li>container (quite::ObjectQuery)</li> <li>completed_ (quite::QObjectOperationState)</li> <li>connection_ (quite::QObjectOperationState)</li> <li>completion_signatures (quite::QObjectSender, quite::QThreadScheduler::QThreadSender)</li> <li>connect (quite::QObjectSender, quite::QThreadScheduler::QThreadSender, quite::client::ProbeManager)</li> <li>context (quite::ValueRegistry, quite::proto::GrpcManager)</li> <li>context_ (quite::ValueRegistry)</li> <li>current_environment (quite::manager::ProcessManager, quite::manager::ProcessManagerClient)</li> <li>current_remote_environment (quite::manager::RemoteProcessManager)</li> <li>constructors (quite::meta::ObjectType)</li> <li>Client (quite::proto::Client)</li> <li>create_probe_client (quite::proto::Client)</li> <li>connect_to_probe (quite::test::ProbeManager)</li> </ul>"},{"location":"quite/class_members/#d","title":"d","text":"<ul> <li>data (quite::Image, quite::ImageView)</li> <li>diff (quite::ImageCompareResult)</li> <li>diff_image (quite::ImageCompareResult)</li> <li>diff_color (quite::PixelCompareOptions)</li> <li>diff_color_alt (quite::PixelCompareOptions)</li> <li>diff_mask (quite::PixelCompareOptions)</li> <li>dispatch_mouse_event (quite::probe::MouseInjector)</li> </ul>"},{"location":"quite/class_members/#e","title":"e","text":"<ul> <li>exit (quite::client::BasicProbe, quite::client::Probe, quite::test::Probe)</li> <li>Environment (quite::manager::BasicProcessManager)</li> <li>exit_code (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>executor_ (quite::manager::ProcessManager::Impl)</li> </ul>"},{"location":"quite/class_members/#f","title":"f","text":"<ul> <li>format (fmt::formatter&lt; entt::meta_any &gt;, fmt)</li> <li>from_qobject (quite::ObjectMeta)</li> <li>find_object (quite::client::GrpcProbe, quite::client::Probe, quite::probe::ObjectTracker, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::Probe)</li> <li>fetch_properties (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>fetch_property (quite::client::GrpcRemoteObject)</li> <li>from (quite::client::GrpcValueConverter, quite::proto::IValueConverter, quite::proto::ProbeValueConverter)</li> <li>find_executable (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>find_type_by_id (quite::probe::MetaAdapter)</li> <li>find_object_by_query (quite::probe::ObjectTracker)</li> <li>fetch_windows (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>fetch (quite::test::Property)</li> </ul>"},{"location":"quite/class_members/#g","title":"g","text":"<ul> <li>GrpcProbe (quite::client::GrpcProbe)</li> <li>get_views (quite::client::GrpcProbe, quite::client::Probe)</li> <li>GrpcProperty (quite::client::GrpcProperty)</li> <li>GrpcRemoteObject (quite::client::GrpcRemoteObject)</li> <li>get_object_by_id (quite::probe::ObjectTracker)</li> <li>grpc_ (quite::proto::Client::Impl)</li> <li>GrpcManager (quite::proto::GrpcManager)</li> <li>grpc_context_ (quite::proto::GrpcManager, quite::proto::MetaRegistryImpl, quite::proto::MouseInjectorImpl, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl, quite::proto::Server::Impl)</li> <li>grpc_thread_ (quite::proto::GrpcManager)</li> <li>get_object_properties (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> <li>grpc_channel_ (quite::proto::ProbeClientImpl)</li> <li>grpc_runner_ (quite::proto::Server::Impl)</li> <li>grpc_server_ (quite::proto::Server::Impl)</li> </ul>"},{"location":"quite/class_members/#h","title":"h","text":"<ul> <li>height_ (quite::Image::Impl)</li> <li>height (quite::ImageView, quite::proto::IProbeHandler::ImageData)</li> <li>handle_ (quite::test::Probe)</li> </ul>"},{"location":"quite/class_members/#i","title":"i","text":"<ul> <li>Instance (quite::Context)</li> <li>Image (quite::Image)</li> <li>impl_ (quite::Image, quite::client::ProbeManager, quite::manager::ProcessManager, quite::manager::Server, quite::proto::Client, quite::proto::Server)</li> <li>Impl (quite::Image::Impl, quite::proto::Server::Impl)</li> <li>image_data_ (quite::Image::Impl)</li> <li>is_sender (quite::QObjectSender, quite::QThreadScheduler::QThreadSender)</li> <li>invoke_method (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::MethodInvoker, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::RemoteObject)</li> <li>id (quite::client::RemoteObject, quite::meta::EnumType, quite::meta::ListType, quite::meta::MapType, quite::meta::ObjectType)</li> <li>id_ (quite::client::RemoteObject)</li> <li>is_running (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>instance (quite::manager::ProcessHandle)</li> <li>init_timer_ (quite::probe::ObjectTracker)</li> <li>install_application_hooks (quite::probe::ProbeContext)</li> <li>install_qt_hooks (quite::probe::ProbeContext)</li> <li>image_data (quite::proto::IProbeHandler::ImageData)</li> </ul>"},{"location":"quite/class_members/#k","title":"k","text":"<ul> <li>key_type (quite::meta::MapType)</li> </ul>"},{"location":"quite/class_members/#l","title":"l","text":"<ul> <li>last_value_ (quite::client::GrpcProperty)</li> <li>launch_application (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>lookup_type (quite::meta::MetaRegistry, quite::probe::QtMetaRegistry, quite::proto::MetaRegistryImpl)</li> <li>locker_ (quite::probe::ObjectTracker)</li> <li>launch_probe_application (quite::test::ProbeManager)</li> <li>local_ (quite::test::ProbeManager)</li> </ul>"},{"location":"quite/class_members/#m","title":"m","text":"<ul> <li>message (quite::Error)</li> <li>meta_object (quite::ObjectMeta)</li> <li>m_ptr_type (quite::QObjectOperationState)</li> <li>MemberPointer (quite::QObjectSender)</li> <li>member_ptr (quite::QObjectSender)</li> <li>meta_registry (quite::client::GrpcProbe, quite::client::Probe, quite::proto::GetMetaObjectRpcHandler, quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> <li>mouse_action (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>modifier (quite::core::MouseAction)</li> <li>methods (quite::meta::ObjectType)</li> <li>MethodInvoker (quite::probe::MethodInvoker)</li> <li>MouseInjector (quite::probe::MouseInjector)</li> <li>mouse_ (quite::probe::MouseInjector)</li> <li>meta_registry_ (quite::probe::ProbeContext, quite::proto::ProbeClientImpl, quite::proto::Server::Impl)</li> <li>mouse_injector_ (quite::probe::ProbeContext, quite::proto::ProbeClientImpl, quite::proto::Server::Impl)</li> <li>method_invoker_ (quite::probe::QtProbeHandler)</li> <li>MetaRegistryImpl (quite::proto::MetaRegistryImpl)</li> <li>meta_service_stub_ (quite::proto::MetaRegistryImpl, quite::proto::ProbeClientImpl)</li> <li>mouse_injector (quite::proto::MouseActionRpcHandler, quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> <li>MouseInjectorImpl (quite::proto::MouseInjectorImpl)</li> </ul>"},{"location":"quite/class_members/#n","title":"n","text":"<ul> <li>name_db_ (quite::ValueRegistry)</li> <li>named_property (quite::ValueRegistry)</li> <li>name (quite::client::GrpcProperty, quite::client::Property, quite::manager::ProcessId, quite::meta::EnumType, quite::meta::ListType, quite::meta::MapType, quite::meta::Method, quite::meta::ObjectType, quite::meta::Property)</li> <li>name_ (quite::client::GrpcProperty)</li> <li>noop_process (quite::manager::BasicProcessManager)</li> <li>next_add_qobject_hook_ (quite::probe::ProbeContext)</li> <li>next_remove_qobject_hook_ (quite::probe::ProbeContext)</li> <li>next_startup_hook_ (quite::probe::ProbeContext)</li> </ul>"},{"location":"quite/class_members/#o","title":"o","text":"<ul> <li>operator= (quite::Image, quite::ObjectQuery, quite::client::ProbeManager, quite::proto::Server, quite::test::Probe, quite::test::ProbeManager)</li> <li>object (quite::ObjectMeta, quite::QObjectSender)</li> <li>ObjectQuery (quite::ObjectQuery, quite::ObjectQueryBuilder)</li> <li>ObjectQueryBuilder (quite::ObjectQueryBuilder)</li> <li>object_id (quite::ObjectReference)</li> <li>obj_ (quite::QObjectOperationState, quite::QObjectSender, quite::test::RemoteObjectExpect)</li> <li>operation_state_concept (quite::QObjectOperationState, quite::QThreadOperationState)</li> <li>operator== (quite::QThreadScheduler, quite::test::RemoteObject)</li> <li>operator bool (quite::ServiceHandle)</li> <li>operator* (quite::ServiceHandle)</li> <li>operator-&gt; (quite::ServiceHandle, quite::client::ProbeHandle, quite::manager::ProcessHandle)</li> <li>object_tracker_ (quite::probe::MouseInjector, quite::probe::ProbeContext, quite::probe::QtProbeHandler)</li> <li>ObjectTracker (quite::probe::ObjectTracker)</li> <li>objects_to_track_ (quite::probe::ObjectTracker)</li> <li>own_ctx_ (quite::probe::ObjectTracker)</li> <li>object_instance (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>operator() (quite::proto::FindObjectRpcHandler, quite::proto::GetMetaObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::GetViewsRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::MouseActionRpcHandler, quite::proto::ProtocolVisitor, quite::proto::SetObjectPropertyRpcHandler, quite::proto::SnapshotRpcHandler, quite::QObjectOperationState::StopCallback)</li> <li>object_ (quite::test::RemoteObject)</li> </ul>"},{"location":"quite/class_members/#p","title":"p","text":"<ul> <li>PropertyMap (quite::GenericClass, quite::ObjectQuery, quite::proto::IProbeHandler)</li> <li>properties (quite::GenericClass, quite::ObjectQuery, quite::meta::ObjectType)</li> <li>ptr_ (quite::QObjectOperationState, quite::QObjectSender)</li> <li>PropertyNameMap (quite::ValueRegistry)</li> <li>property_names (quite::ValueRegistry)</li> <li>process (quite::client::BasicProbe)</li> <li>process_ (quite::client::BasicProbe, quite::manager::ProcessHandle, quite::manager::ProcessImpl)</li> <li>parent_ (quite::client::GrpcProperty)</li> <li>property (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>Probe (quite::client::Probe, quite::test::Probe)</li> <li>ProbeHandle (quite::client::ProbeHandle)</li> <li>probe_ (quite::client::ProbeHandle, quite::test::ProbeManager)</li> <li>ProbeManager (quite::client::ProbeManager, quite::test::Probe, quite::test::ProbeManager)</li> <li>Property (quite::client::Property, quite::test::Property)</li> <li>position (quite::core::MouseAction)</li> <li>ProcessHandle (quite::manager::ProcessHandle)</li> <li>ProcessImpl (quite::manager::ProcessImpl)</li> <li>ProcessManager (quite::manager::ProcessManager)</li> <li>ProcessManagerClient (quite::manager::ProcessManagerClient)</li> <li>parameters (quite::meta::Method)</li> <li>process_new_objects (quite::probe::ObjectTracker)</li> <li>ProbeContext (quite::probe::ProbeContext)</li> <li>probe_handler_ (quite::probe::ProbeContext, quite::proto::Server::Impl)</li> <li>probe_handler (quite::proto::FindObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::GetViewsRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::SetObjectPropertyRpcHandler, quite::proto::SnapshotRpcHandler)</li> <li>probe_service_stub_ (quite::proto::MouseInjectorImpl, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl)</li> <li>ProbeClient (quite::proto::ProbeClient)</li> <li>probe_service (quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> <li>ProbeClientImpl (quite::proto::ProbeClientImpl)</li> <li>probe_service_ (quite::proto::ProbeClientImpl)</li> <li>ProbeServiceImpl (quite::proto::ProbeServiceImpl)</li> <li>proto (quite::proto::ProtocolVisitor)</li> <li>property_ (quite::test::Property)</li> </ul>"},{"location":"quite/class_members/#q","title":"q","text":"<ul> <li>query_ (quite::ObjectQueryBuilder)</li> <li>QObjectOperationState (quite::QObjectOperationState)</li> <li>QObjectSender (quite::QObjectSender)</li> <li>query (quite::QObjectSender, quite::QThreadScheduler, quite::QThreadScheduler::DefaultEnv, quite::QThreadScheduler::QThreadSender, quite::QObjectSender::DefaultEnv)</li> <li>QThreadOperationState (quite::QThreadOperationState)</li> <li>Q_DISABLE_COPY_MOVE (quite::QThreadOperationState)</li> <li>QThreadScheduler (quite::QThreadScheduler)</li> <li>QThreadSender (quite::QThreadScheduler::QThreadSender)</li> <li>QUITE_DISABLE_COPY_MOVE (quite::client::GrpcProperty, quite::client::Probe, quite::client::Property, quite::probe::ProbeContext, quite::proto::Client, quite::proto::GrpcManager, quite::proto::ProbeClient)</li> <li>QUITE_DISABLE_COPY (quite::client::ProbeManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::Server, quite::proto::Server, quite::test::Probe, quite::test::ProbeManager)</li> <li>QUITE_DEFAULT_MOVE (quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::Server)</li> <li>qt_hook_add_object (quite::probe::ProbeContext)</li> <li>qt_hook_remove_object (quite::probe::ProbeContext)</li> <li>qt_hook_startup (quite::probe::ProbeContext)</li> <li>QtProbeHandler (quite::probe::QtProbeHandler)</li> <li>query_top_level_views (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> </ul>"},{"location":"quite/class_members/#r","title":"r","text":"<ul> <li>receiver_ (quite::QObjectOperationState, quite::QThreadOperationState)</li> <li>read (quite::client::GrpcProperty, quite::client::Property)</li> <li>RemoteObject (quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>request_exit (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>return_type (quite::meta::Method)</li> <li>remove_object (quite::probe::ObjectTracker)</li> <li>run_server_until_stopped (quite::proto::Server::Impl)</li> <li>RemoteException (quite::test::RemoteException)</li> <li>RemoteObjectExpect (quite::test::RemoteObjectExpect)</li> </ul>"},{"location":"quite/class_members/#s","title":"s","text":"<ul> <li>server_address (quite::GrpcServer)</li> <li>save_to (quite::Image)</li> <li>shared_ptr&lt; ObjectQuery &gt; (quite::ObjectQueryBuilder)</li> <li>skip_anti_aliasing (quite::PixelCompareOptions)</li> <li>start (quite::QObjectOperationState, quite::QThreadOperationState)</li> <li>stop_callback_ (quite::QObjectOperationState)</li> <li>stop_callback_type (quite::QObjectOperationState)</li> <li>stop_token_type (quite::QObjectOperationState)</li> <li>schedule (quite::QThreadScheduler)</li> <li>ServiceHandle (quite::ServiceHandle)</li> <li>service_ (quite::ServiceHandle)</li> <li>set_client (quite::client::GrpcValueConverter)</li> <li>single_action (quite::core::IMouseInjector, quite::probe::MouseInjector, quite::proto::MouseInjectorImpl)</li> <li>Server (quite::manager::Server, quite::proto::Server)</li> <li>start_timer (quite::probe::ObjectTracker)</li> <li>server_ (quite::probe::ProbeContext)</li> <li>set_property (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>set_object_property (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> <li>ssource_ (quite::proto::Server::Impl)</li> <li>self (quite::QObjectOperationState::StopCallback)</li> </ul>"},{"location":"quite/class_members/#t","title":"t","text":"<ul> <li>type_name (quite::ObjectQuery)</li> <li>type_id (quite::ObjectReference, quite::client::GrpcProperty, quite::client::GrpcRemoteObject, quite::client::Property, quite::client::RemoteObject)</li> <li>threshold (quite::PixelCompareOptions)</li> <li>thread_ (quite::QThreadOperationState, quite::QThreadScheduler::QThreadSender, quite::QThreadScheduler)</li> <li>thread (quite::QThreadScheduler::DefaultEnv, quite::QThreadScheduler::QThreadSender, quite::QThreadScheduler, quite::QObjectSender::DefaultEnv)</li> <li>Type (quite::ServiceHandle)</li> <li>type_id_ (quite::client::GrpcProperty, quite::client::GrpcRemoteObject)</li> <li>take_snapshot (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::RemoteObject)</li> <li>trigger (quite::core::MouseAction)</li> <li>terminate (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>type (quite::meta::Property)</li> <li>type_registry_ (quite::probe::MetaAdapter)</li> <li>top_level_views (quite::probe::ObjectTracker)</li> <li>top_level_views_ (quite::probe::ObjectTracker)</li> <li>tracked_objects_ (quite::probe::ObjectTracker)</li> <li>to_have_screenshot (quite::test::IExpectBuilder, quite::test::RemoteObjectExpect)</li> <li>try_find_object (quite::test::Probe)</li> </ul>"},{"location":"quite/class_members/#u","title":"u","text":"<ul> <li>underlying_object (quite::test::RemoteObject)</li> </ul>"},{"location":"quite/class_members/#v","title":"v","text":"<ul> <li>value_converter_ (quite::client::GrpcProbe, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl)</li> <li>value (quite::client::GrpcProperty, quite::client::Property, quite::test::Property)</li> <li>ValueName (quite::meta::EnumType)</li> <li>values (quite::meta::EnumType)</li> <li>value_type (quite::meta::ListType, quite::meta::MapType)</li> <li>value_registry_ (quite::probe::ProbeContext, quite::proto::Server::Impl)</li> <li>value_registry (quite::proto::FindObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::SetObjectPropertyRpcHandler)</li> <li>Value (quite::test::Property)</li> </ul>"},{"location":"quite/class_members/#w","title":"w","text":"<ul> <li>width_ (quite::Image::Impl)</li> <li>width (quite::ImageView, quite::proto::IProbeHandler::ImageData)</li> <li>with_parent (quite::ObjectQueryBuilder)</li> <li>with_property (quite::ObjectQueryBuilder)</li> <li>with_type (quite::ObjectQueryBuilder)</li> <li>wait_for_started (quite::client::GrpcProbe, quite::client::Probe)</li> <li>write (quite::client::GrpcProperty, quite::client::Property, quite::test::Property)</li> <li>write_property (quite::client::GrpcRemoteObject, quite::client::RemoteObject)</li> <li>wait_for_connected (quite::proto::ProbeClient, quite::proto::ProbeClientImpl, quite::test::Probe)</li> <li>wait_for_value (quite::test::Property)</li> </ul>"},{"location":"quite/class_members/#x","title":"x","text":"<ul> <li>x (quite::Vector2)</li> </ul>"},{"location":"quite/class_members/#y","title":"y","text":"<ul> <li>y (quite::Vector2)</li> </ul>"},{"location":"quite/class_members/#_1","title":"~","text":"<ul> <li>~Context (quite::Context)</li> <li>~Impl (quite::Image::Impl, quite::proto::Server::Impl)</li> <li>~Image (quite::Image)</li> <li>~ObjectQuery (quite::ObjectQuery)</li> <li>~QThreadOperationState (quite::QThreadOperationState)</li> <li>~GrpcProperty (quite::client::GrpcProperty)</li> <li>~Probe (quite::client::Probe, quite::test::Probe)</li> <li>~ProbeManager (quite::client::ProbeManager, quite::test::ProbeManager)</li> <li>~Property (quite::client::Property)</li> <li>~RemoteObject (quite::client::RemoteObject)</li> <li>~IMouseInjector (quite::core::IMouseInjector)</li> <li>~BasicProcessManager (quite::manager::BasicProcessManager)</li> <li>~Process (quite::manager::Process)</li> <li>~ProcessManager (quite::manager::ProcessManager)</li> <li>~ProcessManagerClient (quite::manager::ProcessManagerClient)</li> <li>~Server (quite::manager::Server, quite::proto::Server)</li> <li>~MetaRegistry (quite::meta::MetaRegistry)</li> <li>~MouseInjector (quite::probe::MouseInjector)</li> <li>~ObjectTracker (quite::probe::ObjectTracker)</li> <li>~ProbeContext (quite::probe::ProbeContext)</li> <li>~Client (quite::proto::Client)</li> <li>~GrpcManager (quite::proto::GrpcManager)</li> <li>~IProbeHandler (quite::proto::IProbeHandler)</li> <li>~IProbeService (quite::proto::IProbeService)</li> <li>~IValueConverter (quite::proto::IValueConverter)</li> <li>~ProbeClient (quite::proto::ProbeClient)</li> <li>~IExpectBuilder (quite::test::IExpectBuilder)</li> </ul>"},{"location":"quite/class_member_functions/","title":"Class Member Functions","text":""},{"location":"quite/class_member_functions/#a","title":"a","text":"<ul> <li>asio_context (quite::Context)</li> <li>application (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>async_wait_exit (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>add_object (quite::probe::ObjectTracker)</li> </ul>"},{"location":"quite/class_member_functions/#b","title":"b","text":"<ul> <li>backend_client (quite::Context)</li> <li>BasicProbe (quite::client::BasicProbe)</li> </ul>"},{"location":"quite/class_member_functions/#c","title":"c","text":"<ul> <li>Context (quite::Context)</li> <li>connect (quite::QObjectSender, quite::QThreadScheduler::QThreadSender, quite::client::ProbeManager)</li> <li>context (quite::ValueRegistry, quite::proto::GrpcManager)</li> <li>current_environment (quite::manager::ProcessManager, quite::manager::ProcessManagerClient)</li> <li>current_remote_environment (quite::manager::RemoteProcessManager)</li> <li>Client (quite::proto::Client)</li> <li>create_probe_client (quite::proto::Client)</li> <li>connect_to_probe (quite::test::ProbeManager)</li> </ul>"},{"location":"quite/class_member_functions/#d","title":"d","text":"<ul> <li>data (quite::Image)</li> <li>dispatch_mouse_event (quite::probe::MouseInjector)</li> </ul>"},{"location":"quite/class_member_functions/#e","title":"e","text":"<ul> <li>exit (quite::client::BasicProbe, quite::client::Probe, quite::test::Probe)</li> <li>exit_code (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> </ul>"},{"location":"quite/class_member_functions/#f","title":"f","text":"<ul> <li>format (fmt::formatter&lt; entt::meta_any &gt;, fmt)</li> <li>from_qobject (quite::ObjectMeta)</li> <li>find_object (quite::client::GrpcProbe, quite::client::Probe, quite::probe::ObjectTracker, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::Probe)</li> <li>fetch_properties (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>fetch_property (quite::client::GrpcRemoteObject)</li> <li>from (quite::client::GrpcValueConverter, quite::proto::IValueConverter, quite::proto::ProbeValueConverter)</li> <li>find_executable (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>find_type_by_id (quite::probe::MetaAdapter)</li> <li>find_object_by_query (quite::probe::ObjectTracker)</li> <li>fetch_windows (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>fetch (quite::test::Property)</li> </ul>"},{"location":"quite/class_member_functions/#g","title":"g","text":"<ul> <li>GrpcProbe (quite::client::GrpcProbe)</li> <li>get_views (quite::client::GrpcProbe, quite::client::Probe)</li> <li>GrpcProperty (quite::client::GrpcProperty)</li> <li>GrpcRemoteObject (quite::client::GrpcRemoteObject)</li> <li>get_object_by_id (quite::probe::ObjectTracker)</li> <li>GrpcManager (quite::proto::GrpcManager)</li> <li>get_object_properties (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> </ul>"},{"location":"quite/class_member_functions/#i","title":"i","text":"<ul> <li>Instance (quite::Context)</li> <li>Image (quite::Image)</li> <li>Impl (quite::Image::Impl, quite::proto::Server::Impl)</li> <li>invoke_method (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::MethodInvoker, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::RemoteObject)</li> <li>id (quite::client::RemoteObject)</li> <li>is_running (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>instance (quite::manager::ProcessHandle)</li> <li>install_application_hooks (quite::probe::ProbeContext)</li> <li>install_qt_hooks (quite::probe::ProbeContext)</li> </ul>"},{"location":"quite/class_member_functions/#l","title":"l","text":"<ul> <li>launch_application (quite::manager::BasicProcessManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::RemoteProcessManager)</li> <li>lookup_type (quite::meta::MetaRegistry, quite::probe::QtMetaRegistry, quite::proto::MetaRegistryImpl)</li> <li>launch_probe_application (quite::test::ProbeManager)</li> </ul>"},{"location":"quite/class_member_functions/#m","title":"m","text":"<ul> <li>member_ptr (quite::QObjectSender)</li> <li>meta_registry (quite::client::GrpcProbe, quite::client::Probe, quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> <li>mouse_action (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>MethodInvoker (quite::probe::MethodInvoker)</li> <li>MouseInjector (quite::probe::MouseInjector)</li> <li>MetaRegistryImpl (quite::proto::MetaRegistryImpl)</li> <li>MouseInjectorImpl (quite::proto::MouseInjectorImpl)</li> <li>mouse_injector (quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> </ul>"},{"location":"quite/class_member_functions/#n","title":"n","text":"<ul> <li>named_property (quite::ValueRegistry)</li> <li>name (quite::client::GrpcProperty, quite::client::Property)</li> <li>noop_process (quite::manager::BasicProcessManager)</li> </ul>"},{"location":"quite/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (quite::Image, quite::ObjectQuery, quite::client::ProbeManager, quite::proto::Server, quite::test::Probe, quite::test::ProbeManager)</li> <li>ObjectQuery (quite::ObjectQuery)</li> <li>ObjectQueryBuilder (quite::ObjectQueryBuilder)</li> <li>object (quite::QObjectSender)</li> <li>operator== (quite::QThreadScheduler, quite::test::RemoteObject)</li> <li>operator bool (quite::ServiceHandle)</li> <li>operator* (quite::ServiceHandle)</li> <li>operator-&gt; (quite::ServiceHandle, quite::client::ProbeHandle, quite::manager::ProcessHandle)</li> <li>ObjectTracker (quite::probe::ObjectTracker)</li> <li>object_instance (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>operator() (quite::proto::FindObjectRpcHandler, quite::proto::GetMetaObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::GetViewsRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::MouseActionRpcHandler, quite::proto::ProtocolVisitor, quite::proto::SetObjectPropertyRpcHandler, quite::proto::SnapshotRpcHandler, quite::QObjectOperationState::StopCallback)</li> </ul>"},{"location":"quite/class_member_functions/#p","title":"p","text":"<ul> <li>property_names (quite::ValueRegistry)</li> <li>process (quite::client::BasicProbe)</li> <li>property (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>Probe (quite::client::Probe, quite::test::Probe)</li> <li>ProbeHandle (quite::client::ProbeHandle)</li> <li>ProbeManager (quite::client::ProbeManager, quite::test::ProbeManager)</li> <li>Property (quite::client::Property, quite::test::Property)</li> <li>ProcessHandle (quite::manager::ProcessHandle)</li> <li>ProcessImpl (quite::manager::ProcessImpl)</li> <li>ProcessManager (quite::manager::ProcessManager)</li> <li>ProcessManagerClient (quite::manager::ProcessManagerClient)</li> <li>process_new_objects (quite::probe::ObjectTracker)</li> <li>ProbeContext (quite::probe::ProbeContext)</li> <li>ProbeClient (quite::proto::ProbeClient)</li> <li>probe_service (quite::proto::ProbeClient, quite::proto::ProbeClientImpl)</li> <li>ProbeClientImpl (quite::proto::ProbeClientImpl)</li> <li>ProbeServiceImpl (quite::proto::ProbeServiceImpl)</li> </ul>"},{"location":"quite/class_member_functions/#q","title":"q","text":"<ul> <li>QObjectOperationState (quite::QObjectOperationState)</li> <li>QObjectSender (quite::QObjectSender)</li> <li>query (quite::QObjectSender, quite::QThreadScheduler, quite::QThreadScheduler::DefaultEnv, quite::QThreadScheduler::QThreadSender, quite::QObjectSender::DefaultEnv)</li> <li>QThreadOperationState (quite::QThreadOperationState)</li> <li>Q_DISABLE_COPY_MOVE (quite::QThreadOperationState)</li> <li>QThreadScheduler (quite::QThreadScheduler)</li> <li>QThreadSender (quite::QThreadScheduler::QThreadSender)</li> <li>QUITE_DISABLE_COPY_MOVE (quite::client::GrpcProperty, quite::client::Probe, quite::client::Property, quite::probe::ProbeContext, quite::proto::Client, quite::proto::GrpcManager, quite::proto::ProbeClient)</li> <li>QUITE_DISABLE_COPY (quite::client::ProbeManager, quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::Server, quite::proto::Server, quite::test::Probe, quite::test::ProbeManager)</li> <li>QUITE_DEFAULT_MOVE (quite::manager::ProcessManager, quite::manager::ProcessManagerClient, quite::manager::Server)</li> <li>qt_hook_add_object (quite::probe::ProbeContext)</li> <li>qt_hook_remove_object (quite::probe::ProbeContext)</li> <li>qt_hook_startup (quite::probe::ProbeContext)</li> <li>QtProbeHandler (quite::probe::QtProbeHandler)</li> <li>query_top_level_views (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> </ul>"},{"location":"quite/class_member_functions/#r","title":"r","text":"<ul> <li>read (quite::client::GrpcProperty, quite::client::Property)</li> <li>RemoteObject (quite::client::RemoteObject, quite::test::RemoteObject)</li> <li>request_exit (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>remove_object (quite::probe::ObjectTracker)</li> <li>run_server_until_stopped (quite::proto::Server::Impl)</li> <li>RemoteException (quite::test::RemoteException)</li> <li>RemoteObjectExpect (quite::test::RemoteObjectExpect)</li> </ul>"},{"location":"quite/class_member_functions/#s","title":"s","text":"<ul> <li>save_to (quite::Image)</li> <li>shared_ptr&lt; ObjectQuery &gt; (quite::ObjectQueryBuilder)</li> <li>start (quite::QObjectOperationState, quite::QThreadOperationState)</li> <li>schedule (quite::QThreadScheduler)</li> <li>ServiceHandle (quite::ServiceHandle)</li> <li>set_client (quite::client::GrpcValueConverter)</li> <li>single_action (quite::core::IMouseInjector, quite::probe::MouseInjector, quite::proto::MouseInjectorImpl)</li> <li>Server (quite::manager::Server, quite::proto::Server)</li> <li>start_timer (quite::probe::ObjectTracker)</li> <li>set_property (quite::probe::QtProbeHandler, quite::proto::IProbeHandler)</li> <li>set_object_property (quite::proto::IProbeService, quite::proto::ProbeServiceImpl)</li> </ul>"},{"location":"quite/class_member_functions/#t","title":"t","text":"<ul> <li>thread (quite::QThreadScheduler::QThreadSender, quite::QThreadScheduler)</li> <li>type_id (quite::client::GrpcProperty, quite::client::GrpcRemoteObject, quite::client::Property, quite::client::RemoteObject)</li> <li>take_snapshot (quite::client::GrpcRemoteObject, quite::client::RemoteObject, quite::probe::QtProbeHandler, quite::proto::IProbeHandler, quite::proto::IProbeService, quite::proto::ProbeServiceImpl, quite::test::RemoteObject)</li> <li>terminate (quite::manager::NoopProcess, quite::manager::Process, quite::manager::ProcessImpl)</li> <li>top_level_views (quite::probe::ObjectTracker)</li> <li>to_have_screenshot (quite::test::IExpectBuilder, quite::test::RemoteObjectExpect)</li> <li>try_find_object (quite::test::Probe)</li> </ul>"},{"location":"quite/class_member_functions/#u","title":"u","text":"<ul> <li>underlying_object (quite::test::RemoteObject)</li> </ul>"},{"location":"quite/class_member_functions/#v","title":"v","text":"<ul> <li>value (quite::client::GrpcProperty, quite::client::Property, quite::test::Property)</li> </ul>"},{"location":"quite/class_member_functions/#w","title":"w","text":"<ul> <li>with_parent (quite::ObjectQueryBuilder)</li> <li>with_property (quite::ObjectQueryBuilder)</li> <li>with_type (quite::ObjectQueryBuilder)</li> <li>wait_for_started (quite::client::GrpcProbe, quite::client::Probe)</li> <li>write (quite::client::GrpcProperty, quite::client::Property, quite::test::Property)</li> <li>write_property (quite::client::GrpcRemoteObject, quite::client::RemoteObject)</li> <li>wait_for_connected (quite::proto::ProbeClient, quite::proto::ProbeClientImpl, quite::test::Probe)</li> <li>wait_for_value (quite::test::Property)</li> </ul>"},{"location":"quite/class_member_functions/#_1","title":"~","text":"<ul> <li>~Context (quite::Context)</li> <li>~Impl (quite::Image::Impl, quite::proto::Server::Impl)</li> <li>~Image (quite::Image)</li> <li>~ObjectQuery (quite::ObjectQuery)</li> <li>~QThreadOperationState (quite::QThreadOperationState)</li> <li>~GrpcProperty (quite::client::GrpcProperty)</li> <li>~Probe (quite::client::Probe, quite::test::Probe)</li> <li>~ProbeManager (quite::client::ProbeManager, quite::test::ProbeManager)</li> <li>~Property (quite::client::Property)</li> <li>~RemoteObject (quite::client::RemoteObject)</li> <li>~IMouseInjector (quite::core::IMouseInjector)</li> <li>~BasicProcessManager (quite::manager::BasicProcessManager)</li> <li>~Process (quite::manager::Process)</li> <li>~ProcessManager (quite::manager::ProcessManager)</li> <li>~ProcessManagerClient (quite::manager::ProcessManagerClient)</li> <li>~Server (quite::manager::Server, quite::proto::Server)</li> <li>~MetaRegistry (quite::meta::MetaRegistry)</li> <li>~MouseInjector (quite::probe::MouseInjector)</li> <li>~ObjectTracker (quite::probe::ObjectTracker)</li> <li>~ProbeContext (quite::probe::ProbeContext)</li> <li>~Client (quite::proto::Client)</li> <li>~GrpcManager (quite::proto::GrpcManager)</li> <li>~IProbeHandler (quite::proto::IProbeHandler)</li> <li>~IProbeService (quite::proto::IProbeService)</li> <li>~IValueConverter (quite::proto::IValueConverter)</li> <li>~ProbeClient (quite::proto::ProbeClient)</li> <li>~IExpectBuilder (quite::test::IExpectBuilder)</li> </ul>"},{"location":"quite/class_member_variables/","title":"Class Member Variables","text":""},{"location":"quite/class_member_variables/#a","title":"a","text":"<ul> <li>alpha (quite::PixelCompareOptions)</li> <li>anti_aliased_color (quite::PixelCompareOptions)</li> <li>applications_ (quite::manager::ProcessManager::Impl)</li> </ul>"},{"location":"quite/class_member_variables/#b","title":"b","text":"<ul> <li>button (quite::core::MouseAction)</li> <li>builder_ (quite::proto::Server::Impl)</li> </ul>"},{"location":"quite/class_member_variables/#c","title":"c","text":"<ul> <li>client_ (quite::Context, quite::client::GrpcProbe, quite::client::GrpcRemoteObject, quite::client::GrpcValueConverter)</li> <li>code (quite::Error)</li> <li>channels_ (quite::Image::Impl)</li> <li>channels (quite::ImageView)</li> <li>container (quite::ObjectQuery)</li> <li>completed_ (quite::QObjectOperationState)</li> <li>connection_ (quite::QObjectOperationState)</li> <li>context_ (quite::ValueRegistry)</li> <li>constructors (quite::meta::ObjectType)</li> </ul>"},{"location":"quite/class_member_variables/#d","title":"d","text":"<ul> <li>diff (quite::ImageCompareResult)</li> <li>diff_image (quite::ImageCompareResult)</li> <li>data (quite::ImageView)</li> <li>diff_color (quite::PixelCompareOptions)</li> <li>diff_color_alt (quite::PixelCompareOptions)</li> <li>diff_mask (quite::PixelCompareOptions)</li> </ul>"},{"location":"quite/class_member_variables/#e","title":"e","text":"<ul> <li>executor_ (quite::manager::ProcessManager::Impl)</li> </ul>"},{"location":"quite/class_member_variables/#g","title":"g","text":"<ul> <li>grpc_ (quite::proto::Client::Impl)</li> <li>grpc_context_ (quite::proto::GrpcManager, quite::proto::MetaRegistryImpl, quite::proto::MouseInjectorImpl, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl, quite::proto::Server::Impl)</li> <li>grpc_thread_ (quite::proto::GrpcManager)</li> <li>grpc_channel_ (quite::proto::ProbeClientImpl)</li> <li>grpc_runner_ (quite::proto::Server::Impl)</li> <li>grpc_server_ (quite::proto::Server::Impl)</li> </ul>"},{"location":"quite/class_member_variables/#h","title":"h","text":"<ul> <li>height_ (quite::Image::Impl)</li> <li>height (quite::ImageView, quite::proto::IProbeHandler::ImageData)</li> <li>handle_ (quite::test::Probe)</li> </ul>"},{"location":"quite/class_member_variables/#i","title":"i","text":"<ul> <li>impl_ (quite::Image, quite::client::ProbeManager, quite::manager::ProcessManager, quite::manager::Server, quite::proto::Client, quite::proto::Server)</li> <li>image_data_ (quite::Image::Impl)</li> <li>id_ (quite::client::RemoteObject)</li> <li>id (quite::meta::EnumType, quite::meta::ListType, quite::meta::MapType, quite::meta::ObjectType)</li> <li>init_timer_ (quite::probe::ObjectTracker)</li> <li>image_data (quite::proto::IProbeHandler::ImageData)</li> </ul>"},{"location":"quite/class_member_variables/#k","title":"k","text":"<ul> <li>key_type (quite::meta::MapType)</li> </ul>"},{"location":"quite/class_member_variables/#l","title":"l","text":"<ul> <li>last_value_ (quite::client::GrpcProperty)</li> <li>locker_ (quite::probe::ObjectTracker)</li> <li>local_ (quite::test::ProbeManager)</li> </ul>"},{"location":"quite/class_member_variables/#m","title":"m","text":"<ul> <li>message (quite::Error)</li> <li>meta_object (quite::ObjectMeta)</li> <li>modifier (quite::core::MouseAction)</li> <li>methods (quite::meta::ObjectType)</li> <li>mouse_ (quite::probe::MouseInjector)</li> <li>meta_registry_ (quite::probe::ProbeContext, quite::proto::ProbeClientImpl, quite::proto::Server::Impl)</li> <li>mouse_injector_ (quite::probe::ProbeContext, quite::proto::ProbeClientImpl, quite::proto::Server::Impl)</li> <li>method_invoker_ (quite::probe::QtProbeHandler)</li> <li>meta_registry (quite::proto::GetMetaObjectRpcHandler)</li> <li>meta_service_stub_ (quite::proto::MetaRegistryImpl, quite::proto::ProbeClientImpl)</li> <li>mouse_injector (quite::proto::MouseActionRpcHandler)</li> </ul>"},{"location":"quite/class_member_variables/#n","title":"n","text":"<ul> <li>name_db_ (quite::ValueRegistry)</li> <li>name_ (quite::client::GrpcProperty)</li> <li>name (quite::manager::ProcessId, quite::meta::EnumType, quite::meta::ListType, quite::meta::MapType, quite::meta::Method, quite::meta::ObjectType, quite::meta::Property)</li> <li>next_add_qobject_hook_ (quite::probe::ProbeContext)</li> <li>next_remove_qobject_hook_ (quite::probe::ProbeContext)</li> <li>next_startup_hook_ (quite::probe::ProbeContext)</li> </ul>"},{"location":"quite/class_member_variables/#o","title":"o","text":"<ul> <li>object (quite::ObjectMeta)</li> <li>ObjectQuery (quite::ObjectQueryBuilder)</li> <li>object_id (quite::ObjectReference)</li> <li>obj_ (quite::QObjectOperationState, quite::QObjectSender, quite::test::RemoteObjectExpect)</li> <li>object_tracker_ (quite::probe::MouseInjector, quite::probe::ProbeContext, quite::probe::QtProbeHandler)</li> <li>objects_to_track_ (quite::probe::ObjectTracker)</li> <li>own_ctx_ (quite::probe::ObjectTracker)</li> <li>object_ (quite::test::RemoteObject)</li> </ul>"},{"location":"quite/class_member_variables/#p","title":"p","text":"<ul> <li>properties (quite::GenericClass, quite::ObjectQuery, quite::meta::ObjectType)</li> <li>ptr_ (quite::QObjectOperationState, quite::QObjectSender)</li> <li>process_ (quite::client::BasicProbe, quite::manager::ProcessHandle, quite::manager::ProcessImpl)</li> <li>parent_ (quite::client::GrpcProperty)</li> <li>probe_ (quite::client::ProbeHandle, quite::test::ProbeManager)</li> <li>position (quite::core::MouseAction)</li> <li>parameters (quite::meta::Method)</li> <li>probe_handler_ (quite::probe::ProbeContext, quite::proto::Server::Impl)</li> <li>probe_handler (quite::proto::FindObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::GetViewsRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::SetObjectPropertyRpcHandler, quite::proto::SnapshotRpcHandler)</li> <li>probe_service_stub_ (quite::proto::MouseInjectorImpl, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl)</li> <li>probe_service_ (quite::proto::ProbeClientImpl)</li> <li>proto (quite::proto::ProtocolVisitor)</li> <li>ProbeManager (quite::test::Probe)</li> <li>property_ (quite::test::Property)</li> </ul>"},{"location":"quite/class_member_variables/#q","title":"q","text":"<ul> <li>query_ (quite::ObjectQueryBuilder)</li> </ul>"},{"location":"quite/class_member_variables/#r","title":"r","text":"<ul> <li>receiver_ (quite::QObjectOperationState, quite::QThreadOperationState)</li> <li>return_type (quite::meta::Method)</li> </ul>"},{"location":"quite/class_member_variables/#s","title":"s","text":"<ul> <li>server_address (quite::GrpcServer)</li> <li>skip_anti_aliasing (quite::PixelCompareOptions)</li> <li>stop_callback_ (quite::QObjectOperationState)</li> <li>service_ (quite::ServiceHandle)</li> <li>server_ (quite::probe::ProbeContext)</li> <li>ssource_ (quite::proto::Server::Impl)</li> <li>self (quite::QObjectOperationState::StopCallback)</li> </ul>"},{"location":"quite/class_member_variables/#t","title":"t","text":"<ul> <li>type_name (quite::ObjectQuery)</li> <li>type_id (quite::ObjectReference)</li> <li>threshold (quite::PixelCompareOptions)</li> <li>thread_ (quite::QThreadOperationState, quite::QThreadScheduler::QThreadSender, quite::QThreadScheduler)</li> <li>thread (quite::QThreadScheduler::DefaultEnv, quite::QObjectSender::DefaultEnv)</li> <li>type_id_ (quite::client::GrpcProperty, quite::client::GrpcRemoteObject)</li> <li>trigger (quite::core::MouseAction)</li> <li>type (quite::meta::Property)</li> <li>type_registry_ (quite::probe::MetaAdapter)</li> <li>top_level_views_ (quite::probe::ObjectTracker)</li> <li>tracked_objects_ (quite::probe::ObjectTracker)</li> </ul>"},{"location":"quite/class_member_variables/#v","title":"v","text":"<ul> <li>value_converter_ (quite::client::GrpcProbe, quite::proto::ProbeClientImpl, quite::proto::ProbeServiceImpl)</li> <li>values (quite::meta::EnumType)</li> <li>value_type (quite::meta::ListType, quite::meta::MapType)</li> <li>value_registry_ (quite::probe::ProbeContext, quite::proto::Server::Impl)</li> <li>value_registry (quite::proto::FindObjectRpcHandler, quite::proto::GetObjectPropertiesRpcHandler, quite::proto::InvokeMethodRpcHandler, quite::proto::SetObjectPropertyRpcHandler)</li> </ul>"},{"location":"quite/class_member_variables/#w","title":"w","text":"<ul> <li>width_ (quite::Image::Impl)</li> <li>width (quite::ImageView, quite::proto::IProbeHandler::ImageData)</li> </ul>"},{"location":"quite/class_member_variables/#x","title":"x","text":"<ul> <li>x (quite::Vector2)</li> </ul>"},{"location":"quite/class_member_variables/#y","title":"y","text":"<ul> <li>y (quite::Vector2)</li> </ul>"},{"location":"quite/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"quite/class_member_typedefs/#c","title":"c","text":"<ul> <li>completion_signatures (quite::QObjectSender, quite::QThreadScheduler::QThreadSender)</li> </ul>"},{"location":"quite/class_member_typedefs/#e","title":"e","text":"<ul> <li>Environment (quite::manager::BasicProcessManager)</li> </ul>"},{"location":"quite/class_member_typedefs/#i","title":"i","text":"<ul> <li>is_sender (quite::QObjectSender, quite::QThreadScheduler::QThreadSender)</li> </ul>"},{"location":"quite/class_member_typedefs/#m","title":"m","text":"<ul> <li>m_ptr_type (quite::QObjectOperationState)</li> <li>MemberPointer (quite::QObjectSender)</li> </ul>"},{"location":"quite/class_member_typedefs/#o","title":"o","text":"<ul> <li>operation_state_concept (quite::QObjectOperationState, quite::QThreadOperationState)</li> </ul>"},{"location":"quite/class_member_typedefs/#p","title":"p","text":"<ul> <li>PropertyMap (quite::GenericClass, quite::ObjectQuery, quite::proto::IProbeHandler)</li> <li>PropertyNameMap (quite::ValueRegistry)</li> </ul>"},{"location":"quite/class_member_typedefs/#s","title":"s","text":"<ul> <li>stop_callback_type (quite::QObjectOperationState)</li> <li>stop_token_type (quite::QObjectOperationState)</li> </ul>"},{"location":"quite/class_member_typedefs/#t","title":"t","text":"<ul> <li>Type (quite::ServiceHandle)</li> </ul>"},{"location":"quite/class_member_typedefs/#v","title":"v","text":"<ul> <li>ValueName (quite::meta::EnumType)</li> <li>Value (quite::test::Property)</li> </ul>"},{"location":"quite/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"quite/namespace_members/","title":"Namespace Members","text":""},{"location":"quite/namespace_members/#a","title":"a","text":"<ul> <li>AsyncResult (quite)</li> <li>asio_context (quite::client)</li> </ul>"},{"location":"quite/namespace_members/#c","title":"c","text":"<ul> <li>collect_properties (quite)</li> <li>create_logger (quite)</li> <li>configure_client_context (quite::proto)</li> <li>convert_value (quite::proto)</li> <li>create_value (quite::proto)</li> <li>create_screenshot_expect (quite::test)</li> <li>create_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_members/#d","title":"d","text":"<ul> <li>dump_properties (quite::client)</li> </ul>"},{"location":"quite/namespace_members/#e","title":"e","text":"<ul> <li>ErrorCode (quite)</li> <li>EnumTypePtr (quite::meta)</li> <li>expect (quite::test)</li> </ul>"},{"location":"quite/namespace_members/#f","title":"f","text":"<ul> <li>from_object_id (quite::probe)</li> <li>FindObjectRPC (quite::proto)</li> <li>FindTypeRPC (quite::proto)</li> <li>from_protocol (quite::proto)</li> </ul>"},{"location":"quite/namespace_members/#g","title":"g","text":"<ul> <li>get_executor (quite)</li> <li>GetObjectPropertiesRPC (quite::proto)</li> <li>GetViewsRPC (quite::proto)</li> <li>grpc_status2result (quite::proto)</li> </ul>"},{"location":"quite/namespace_members/#h","title":"h","text":"<ul> <li>has_screenshot_expect (quite::test)</li> <li>has_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_members/#i","title":"i","text":"<ul> <li>InvokeMethodRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_members/#k","title":"k","text":"<ul> <li>KeyboardModifier (quite::core)</li> </ul>"},{"location":"quite/namespace_members/#m","title":"m","text":"<ul> <li>make_error_result (quite)</li> <li>make_query (quite)</li> <li>MouseButton (quite::core)</li> <li>MouseTrigger (quite::core)</li> <li>MouseActionRPC (quite::proto)</li> <li>make_rpc_fetch_object_properties (quite::proto)</li> <li>make_rpc_fetch_windows (quite::proto)</li> <li>make_rpc_find_object (quite::proto)</li> <li>make_rpc_invoke_method (quite::proto)</li> <li>make_rpc_meta_find_type (quite::proto)</li> <li>make_rpc_mouse_injection (quite::proto)</li> <li>make_rpc_set_object_property (quite::proto)</li> <li>make_rpc_snapshot (quite::proto)</li> </ul>"},{"location":"quite/namespace_members/#o","title":"o","text":"<ul> <li>ObjectId (quite, quite::client)</li> <li>ObjectQueryBuilder (quite)</li> <li>ObjectTypePtr (quite::meta)</li> </ul>"},{"location":"quite/namespace_members/#p","title":"p","text":"<ul> <li>PixelData (quite)</li> <li>pixel_match (quite)</li> <li>PropertyPtr (quite::client)</li> <li>PrimitiveType (quite::meta)</li> <li>ProbeHandlerHandle (quite::proto)</li> </ul>"},{"location":"quite/namespace_members/#q","title":"q","text":"<ul> <li>qobject_as_sender (quite)</li> <li>qobject_as_tuple_sender (quite)</li> <li>qthread_as_scheduler (quite)</li> </ul>"},{"location":"quite/namespace_members/#r","title":"r","text":"<ul> <li>Result (quite)</li> <li>RemoteObjectPtr (quite::client)</li> <li>register_converters (quite::probe)</li> <li>RpcSnapshot (quite::proto)</li> <li>result2grpc_status (quite::proto)</li> <li>read_property (quite)</li> </ul>"},{"location":"quite/namespace_members/#s","title":"s","text":"<ul> <li>SetObjectPropertyRPC (quite::proto)</li> <li>setup_hooks (quite)</li> <li>setup_logger (quite)</li> </ul>"},{"location":"quite/namespace_members/#t","title":"t","text":"<ul> <li>to_json (entt, quite)</li> <li>Type (quite::meta)</li> <li>TypeId (quite::meta)</li> <li>take_snapshot_of_qobject (quite::probe)</li> <li>to_object_id (quite::probe)</li> <li>try_get_qt_meta_object (quite::probe)</li> <li>try_get_qt_meta_type (quite::probe)</li> <li>to_protocol (quite::proto)</li> <li>throw_unexpected (quite::test)</li> <li>thread_pool (quite)</li> </ul>"},{"location":"quite/namespace_members/#v","title":"v","text":"<ul> <li>verify_screenshot_expect (quite::test)</li> <li>verify_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_members/#w","title":"w","text":"<ul> <li>write_property (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"quite/namespace_member_functions/#a","title":"a","text":"<ul> <li>asio_context (quite::client)</li> </ul>"},{"location":"quite/namespace_member_functions/#c","title":"c","text":"<ul> <li>collect_properties (quite)</li> <li>create_logger (quite)</li> <li>configure_client_context (quite::proto)</li> <li>convert_value (quite::proto)</li> <li>create_value (quite::proto)</li> <li>create_screenshot_expect (quite::test)</li> <li>create_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_member_functions/#d","title":"d","text":"<ul> <li>dump_properties (quite::client)</li> </ul>"},{"location":"quite/namespace_member_functions/#e","title":"e","text":"<ul> <li>expect (quite::test)</li> </ul>"},{"location":"quite/namespace_member_functions/#f","title":"f","text":"<ul> <li>from_object_id (quite::probe)</li> <li>from_protocol (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_executor (quite)</li> <li>grpc_status2result (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_functions/#h","title":"h","text":"<ul> <li>has_screenshot_expect (quite::test)</li> <li>has_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_member_functions/#m","title":"m","text":"<ul> <li>make_error_result (quite)</li> <li>make_query (quite)</li> <li>make_rpc_fetch_object_properties (quite::proto)</li> <li>make_rpc_fetch_windows (quite::proto)</li> <li>make_rpc_find_object (quite::proto)</li> <li>make_rpc_invoke_method (quite::proto)</li> <li>make_rpc_meta_find_type (quite::proto)</li> <li>make_rpc_mouse_injection (quite::proto)</li> <li>make_rpc_set_object_property (quite::proto)</li> <li>make_rpc_snapshot (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_functions/#p","title":"p","text":"<ul> <li>pixel_match (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/#q","title":"q","text":"<ul> <li>qobject_as_sender (quite)</li> <li>qobject_as_tuple_sender (quite)</li> <li>qthread_as_scheduler (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/#r","title":"r","text":"<ul> <li>register_converters (quite::probe)</li> <li>result2grpc_status (quite::proto)</li> <li>read_property (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/#s","title":"s","text":"<ul> <li>setup_hooks (quite)</li> <li>setup_logger (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/#t","title":"t","text":"<ul> <li>to_json (entt, quite)</li> <li>take_snapshot_of_qobject (quite::probe)</li> <li>to_object_id (quite::probe)</li> <li>try_get_qt_meta_object (quite::probe)</li> <li>try_get_qt_meta_type (quite::probe)</li> <li>to_protocol (quite::proto)</li> <li>throw_unexpected (quite::test)</li> <li>thread_pool (quite)</li> </ul>"},{"location":"quite/namespace_member_functions/#v","title":"v","text":"<ul> <li>verify_screenshot_expect (quite::test)</li> <li>verify_verification_point (quite::testing)</li> </ul>"},{"location":"quite/namespace_member_functions/#w","title":"w","text":"<ul> <li>write_property (quite)</li> </ul>"},{"location":"quite/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"quite/namespace_member_variables/#o","title":"o","text":"<ul> <li>ObjectQueryBuilder (quite)</li> </ul>"},{"location":"quite/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"quite/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>AsyncResult (quite)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>EnumTypePtr (quite::meta)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>FindObjectRPC (quite::proto)</li> <li>FindTypeRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#g","title":"g","text":"<ul> <li>GetObjectPropertiesRPC (quite::proto)</li> <li>GetViewsRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>InvokeMethodRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>MouseActionRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#o","title":"o","text":"<ul> <li>ObjectId (quite, quite::client)</li> <li>ObjectTypePtr (quite::meta)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>PixelData (quite)</li> <li>PropertyPtr (quite::client)</li> <li>ProbeHandlerHandle (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>Result (quite)</li> <li>RemoteObjectPtr (quite::client)</li> <li>RpcSnapshot (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>SetObjectPropertyRPC (quite::proto)</li> </ul>"},{"location":"quite/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>Type (quite::meta)</li> <li>TypeId (quite::meta)</li> </ul>"},{"location":"quite/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"quite/namespace_member_enums/#e","title":"e","text":"<ul> <li>ErrorCode (quite)</li> </ul>"},{"location":"quite/namespace_member_enums/#k","title":"k","text":"<ul> <li>KeyboardModifier (quite::core)</li> </ul>"},{"location":"quite/namespace_member_enums/#m","title":"m","text":"<ul> <li>MouseButton (quite::core)</li> <li>MouseTrigger (quite::core)</li> </ul>"},{"location":"quite/namespace_member_enums/#p","title":"p","text":"<ul> <li>PrimitiveType (quite::meta)</li> </ul>"},{"location":"quite/functions/","title":"Functions","text":""},{"location":"quite/functions/#d","title":"d","text":"<ul> <li>DEFINE_LOGGER (grpc_remote_object.cpp, qt_meta_registry.cpp, meta_registry_impl.cpp, server.cpp, property.cpp)</li> </ul>"},{"location":"quite/functions/#m","title":"m","text":"<ul> <li>main (main.cpp, main.cpp, runnable_exe.cpp, main.cpp, main.cpp)</li> </ul>"},{"location":"quite/functions/#t","title":"t","text":"<ul> <li>TEST_CASE (test_process_manager.cpp)</li> </ul>"},{"location":"quite/macros/","title":"Macros","text":""},{"location":"quite/macros/#d","title":"d","text":"<ul> <li>DEFINE_LOGGER (logger.hpp)</li> </ul>"},{"location":"quite/macros/#q","title":"q","text":"<ul> <li>QUITE_DEFAULT_MOVE (disable_copy_move.hpp)</li> <li>QUITE_DISABLE_COPY (disable_copy_move.hpp)</li> <li>QUITE_DISABLE_COPY_MOVE (disable_copy_move.hpp)</li> </ul>"},{"location":"quite/macros/#r","title":"r","text":"<ul> <li>REGISTER_QT_TYPES_FUNCTION (value_converters.cpp)</li> </ul>"},{"location":"quite/macros/#s","title":"s","text":"<ul> <li>STB_IMAGE_IMPLEMENTATION (image.cpp)</li> <li>STB_IMAGE_WRITE_IMPLEMENTATION (image.cpp)</li> </ul>"},{"location":"quite/macros/#t","title":"t","text":"<ul> <li>TEST_PRIMITIVE_TYPE (test_value_containers.cpp)</li> <li>TRY_RETURN_PRIMITIVE (qt_meta_registry.cpp)</li> </ul>"},{"location":"quite/variables/","title":"Variables","text":""},{"location":"quite/variables/#j","title":"j","text":"<ul> <li>json (dump_properties.cpp)</li> </ul>"},{"location":"quite/variables/#k","title":"k","text":"<ul> <li>kRunnablePath (runnable_path.in.hpp)</li> </ul>"},{"location":"quite/variables/#m","title":"m","text":"<ul> <li>meta_type (method_invoker.cpp)</li> </ul>"},{"location":"quite/variables/#_","title":"_","text":"<ul> <li>_ (test_error.cpp, test_method_invoker.cpp, test_object_tracker.cpp, test_probe_context.cpp, test_property_collector.cpp, test_qt_probe_handler.cpp, test_value_containers.cpp, test_server.cpp)</li> </ul>"},{"location":"quite/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/general/","title":"General","text":""}]}